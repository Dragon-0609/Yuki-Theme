<?xml version="1.0"?>
<doc>
    <assembly>
        <name>FluentListView</name>
    </assembly>
    <members>
        <member name="T:Fluent.CellEditAtEdgeBehaviour">
            <summary>
            Indicates the behavior of a key when a cell "on the edge" is being edited.
            and the normal behavior of that key would exceed the edge. For example,
            for a key that normally moves one column to the left, the "edge" would be 
            the left most column, since the normal action of the key cannot be taken
            (since there are no more columns to the left).
            </summary>
        </member>
        <member name="F:Fluent.CellEditAtEdgeBehaviour.Ignore">
            <summary>
            The key press will be ignored
            </summary>
        </member>
        <member name="F:Fluent.CellEditAtEdgeBehaviour.Wrap">
            <summary>
            The key press will result in the cell editing wrapping to the 
            cell on the opposite edge.
            </summary>
        </member>
        <member name="F:Fluent.CellEditAtEdgeBehaviour.ChangeColumn">
            <summary>
            The key press will wrap, but the column will be changed to the 
            appropiate adjacent column. This only makes sense for keys where
            the normal action is ChangeRow.
            </summary>
        </member>
        <member name="F:Fluent.CellEditAtEdgeBehaviour.ChangeRow">
            <summary>
            The key press will wrap, but the row will be changed to the 
            appropiate adjacent row. This only makes sense for keys where
            the normal action is ChangeColumn.
            </summary>        
        </member>
        <member name="F:Fluent.CellEditAtEdgeBehaviour.EndEdit">
            <summary>
            The key will result in the current edit operation being ended.
            </summary>
        </member>
        <member name="T:Fluent.CellEditCharacterBehaviour">
            <summary>
            Indicates the normal behaviour of a key when used during a cell edit
            operation.
            </summary>
        </member>
        <member name="F:Fluent.CellEditCharacterBehaviour.Ignore">
            <summary>
            The key press will be ignored
            </summary>
        </member>
        <member name="F:Fluent.CellEditCharacterBehaviour.ChangeColumnLeft">
            <summary>
            The key press will end the current edit and begin an edit
            operation on the next editable cell to the left.
            </summary>
        </member>
        <member name="F:Fluent.CellEditCharacterBehaviour.ChangeColumnRight">
            <summary>
            The key press will end the current edit and begin an edit
            operation on the next editable cell to the right.
            </summary>
        </member>
        <member name="F:Fluent.CellEditCharacterBehaviour.ChangeRowUp">
            <summary>
            The key press will end the current edit and begin an edit
            operation on the row above.
            </summary>
        </member>
        <member name="F:Fluent.CellEditCharacterBehaviour.ChangeRowDown">
            <summary>
            The key press will end the current edit and begin an edit
            operation on the row below
            </summary>
        </member>
        <member name="F:Fluent.CellEditCharacterBehaviour.CancelEdit">
            <summary>
            The key press will cancel the current edit
            </summary>
        </member>
        <member name="F:Fluent.CellEditCharacterBehaviour.EndEdit">
            <summary>
            The key press will finish the current edit operation
            </summary>
        </member>
        <member name="F:Fluent.CellEditCharacterBehaviour.CustomVerb1">
            <summary>
            Custom verb that can be used for specialized actions.
            </summary>
        </member>
        <member name="F:Fluent.CellEditCharacterBehaviour.CustomVerb2">
            <summary>
            Custom verb that can be used for specialized actions.
            </summary>
        </member>
        <member name="F:Fluent.CellEditCharacterBehaviour.CustomVerb3">
            <summary>
            Custom verb that can be used for specialized actions.
            </summary>
        </member>
        <member name="F:Fluent.CellEditCharacterBehaviour.CustomVerb4">
            <summary>
            Custom verb that can be used for specialized actions.
            </summary>
        </member>
        <member name="F:Fluent.CellEditCharacterBehaviour.CustomVerb5">
            <summary>
            Custom verb that can be used for specialized actions.
            </summary>
        </member>
        <member name="F:Fluent.CellEditCharacterBehaviour.CustomVerb6">
            <summary>
            Custom verb that can be used for specialized actions.
            </summary>
        </member>
        <member name="F:Fluent.CellEditCharacterBehaviour.CustomVerb7">
            <summary>
            Custom verb that can be used for specialized actions.
            </summary>
        </member>
        <member name="F:Fluent.CellEditCharacterBehaviour.CustomVerb8">
            <summary>
            Custom verb that can be used for specialized actions.
            </summary>
        </member>
        <member name="F:Fluent.CellEditCharacterBehaviour.CustomVerb9">
            <summary>
            Custom verb that can be used for specialized actions.
            </summary>
        </member>
        <member name="F:Fluent.CellEditCharacterBehaviour.CustomVerb10">
            <summary>
            Custom verb that can be used for specialized actions.
            </summary>
        </member>
        <member name="T:Fluent.CellEditKeyEngine">
            <summary>
            Instances of this class handle key presses during a cell edit operation.
            </summary>
        </member>
        <member name="M:Fluent.CellEditKeyEngine.SetKeyBehaviour(System.Windows.Forms.Keys,Fluent.CellEditCharacterBehaviour,Fluent.CellEditAtEdgeBehaviour)">
            <summary>
            Sets the behaviour of a given key
            </summary>
            <param name="key"></param>
            <param name="normalBehaviour"></param>
            <param name="atEdgeBehaviour"></param>
        </member>
        <member name="M:Fluent.CellEditKeyEngine.HandleKey(Fluent.Lists.AdvancedListView,System.Windows.Forms.Keys)">
            <summary>
            Handle a key press
            </summary>
            <param name="olv"></param>
            <param name="keyData"></param>
            <returns>True if the key was completely handled.</returns>
        </member>
        <member name="P:Fluent.CellEditKeyEngine.ListView">
            <summary>
            Gets or sets the FluentListView on which the current key is being handled.
            This cannot be null.
            </summary>
        </member>
        <member name="P:Fluent.CellEditKeyEngine.ItemBeingEdited">
            <summary>
            Gets the row of the cell that is currently being edited
            </summary>
        </member>
        <member name="P:Fluent.CellEditKeyEngine.SubItemIndexBeingEdited">
            <summary>
            Gets the index of the column of the cell that is being edited
            </summary>
        </member>
        <member name="P:Fluent.CellEditKeyEngine.CellEditKeyMap">
            <summary>
            Gets or sets the map that remembers the normal behaviour of keys
            </summary>
        </member>
        <member name="P:Fluent.CellEditKeyEngine.CellEditKeyAtEdgeBehaviourMap">
            <summary>
            Gets or sets the map that remembers the desired behaviour of keys 
            on edge cases.
            </summary>
        </member>
        <member name="M:Fluent.CellEditKeyEngine.InitializeCellEditKeyMaps">
            <summary>
            Setup the default key mapping
            </summary>
        </member>
        <member name="M:Fluent.CellEditKeyEngine.HandleEndEdit">
            <summary>
            Handle the end edit command
            </summary>
        </member>
        <member name="M:Fluent.CellEditKeyEngine.HandleCancelEdit">
            <summary>
            Handle the cancel edit command
            </summary>
        </member>
        <member name="M:Fluent.CellEditKeyEngine.HandleCustomVerb(System.Windows.Forms.Keys,Fluent.CellEditCharacterBehaviour)">
            <summary>
            Placeholder that subclasses can override to handle any custom verbs
            </summary>
            <param name="keyData"></param>
            <param name="behaviour"></param>
            <returns></returns>
        </member>
        <member name="M:Fluent.CellEditKeyEngine.HandleRowChange(System.Windows.Forms.Keys,Fluent.CellEditCharacterBehaviour)">
            <summary>
            Handle a change row command
            </summary>
            <param name="keyData"></param>
            <param name="behaviour"></param>
        </member>
        <member name="M:Fluent.CellEditKeyEngine.HandleColumnChange(System.Windows.Forms.Keys,Fluent.CellEditCharacterBehaviour)">
            <summary>
            Handle a change column command
            </summary>
            <param name="keyData"></param>
            <param name="behaviour"></param>
        </member>
        <member name="M:Fluent.CellEditKeyEngine.StartCellEditIfDifferent(Fluent.OLVListItem,System.Int32)">
            <summary>
            Start editing the indicated cell if that cell is not already being edited
            </summary>
            <param name="olvi">The row to edit</param>
            <param name="subItemIndex">The cell within that row to edit</param>
        </member>
        <member name="M:Fluent.CellEditKeyEngine.GetAdjacentItemOrNull(Fluent.OLVListItem,System.Boolean)">
            <summary>
            Gets the adjacent item to the given item in the given direction.
            If that item is disabled, continue in that direction until an enabled item is found.
            </summary>
            <param name="olvi">The row whose neighbour is sought</param>
            <param name="up">The direction of the adjacentness</param>
            <returns>An OLVListView adjacent to the given item, or null if there are no more enabled items in that direction.</returns>
        </member>
        <member name="M:Fluent.CellEditKeyEngine.GetAdjacentItem(Fluent.OLVListItem,System.Boolean)">
            <summary>
            Gets the adjacent item to the given item in the given direction, wrapping if needed.
            </summary>
            <param name="olvi">The row whose neighbour is sought</param>
            <param name="up">The direction of the adjacentness</param>
            <returns>An OLVListView adjacent to the given item, or null if there are no more items in that direction.</returns>
        </member>
        <member name="P:Fluent.CellEditKeyEngine.EditableColumnsInDisplayOrder">
            <summary>
            Gets a collection of columns that are editable in the order they are shown to the user
            </summary>
        </member>
        <member name="T:Fluent.ComboBoxItem">
            <summary>
            These items allow combo boxes to remember a value and its description.
            </summary>
        </member>
        <member name="M:Fluent.ComboBoxItem.#ctor(System.Object,System.String)">
            <summary>
            
            </summary>
            <param name="key"></param>
            <param name="description"></param>
        </member>
        <member name="P:Fluent.ComboBoxItem.Key">
            <summary>
            
            </summary>
        </member>
        <member name="M:Fluent.ComboBoxItem.ToString">
            <summary>
            Returns a string that represents the current object.
            </summary>
            <returns>
            A string that represents the current object.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="T:Fluent.AutoCompleteCellEditor">
            <summary>
            This editor shows and auto completes values from the given listview column.
            </summary>
        </member>
        <member name="M:Fluent.AutoCompleteCellEditor.#ctor(Fluent.Lists.AdvancedListView,Fluent.OLVColumn)">
            <summary>
            Create an AutoCompleteCellEditor
            </summary>
            <param name="lv"></param>
            <param name="column"></param>
        </member>
        <member name="T:Fluent.EnumCellEditor">
            <summary>
            This combo box is specialised to allow editing of an enum.
            </summary>
        </member>
        <member name="M:Fluent.EnumCellEditor.#ctor(System.Type)">
            <summary>
            
            </summary>
            <param name="type"></param>
        </member>
        <member name="T:Fluent.IntUpDown">
            <summary>
            This editor simply shows and edits integer values.
            </summary>
        </member>
        <member name="M:Fluent.IntUpDown.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="P:Fluent.IntUpDown.Value">
            <summary>
            Gets or sets the value shown by this editor
            </summary>
        </member>
        <member name="T:Fluent.UintUpDown">
            <summary>
            This editor simply shows and edits unsigned integer values.
            </summary>
            <remarks>This class can't be made public because unsigned int is not a
            CLS-compliant type. If you want to use, just copy the code to this class
            into your project and use it from there.</remarks>
        </member>
        <member name="T:Fluent.BooleanCellEditor">
            <summary>
            This editor simply shows and edits boolean values.
            </summary>
        </member>
        <member name="M:Fluent.BooleanCellEditor.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="T:Fluent.BooleanCellEditor2">
            <summary>
            This editor simply shows and edits boolean values using a checkbox
            </summary>
        </member>
        <member name="P:Fluent.BooleanCellEditor2.Value">
            <summary>
            Gets or sets the value shown by this editor
            </summary>
        </member>
        <member name="P:Fluent.BooleanCellEditor2.TextAlign">
            <summary>
            Gets or sets how the checkbox will be aligned
            </summary>
        </member>
        <member name="T:Fluent.FloatCellEditor">
            <summary>
            This editor simply shows and edits floating point values.
            </summary>
            <remarks>You can intercept the CellEditStarting event if you want
            to change the characteristics of the editor. For example, by increasing
            the number of decimal places.</remarks>
        </member>
        <member name="M:Fluent.FloatCellEditor.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="P:Fluent.FloatCellEditor.Value">
            <summary>
            Gets or sets the value shown by this editor
            </summary>
        </member>
        <member name="T:Fluent.EditorCreatorDelegate">
            <summary>
            A delegate that creates an editor for the given value
            </summary>
            <param name="model">The model from which that value came</param>
            <param name="column">The column for which the editor is being created</param>
            <param name="value">A representative value of the type to be edited. This value may not be the exact
            value for the column/model combination. It could be simply representative of
            the appropriate type of value.</param>
            <returns>A control which can edit the given value</returns>
        </member>
        <member name="T:Fluent.EditorRegistry">
            <summary>
            An editor registry gives a way to decide what cell editor should be used to edit
            the value of a cell. Programmers can register non-standard types and the control that 
            should be used to edit instances of that type. 
            </summary>
            <remarks>
            <para>All FluentListViews share the same editor registry.</para>
            </remarks>
        </member>
        <member name="M:Fluent.EditorRegistry.#ctor">
            <summary>
            Create an EditorRegistry
            </summary>
        </member>
        <member name="M:Fluent.EditorRegistry.Register(System.Type,System.Type)">
            <summary>
            Register that values of 'type' should be edited by instances of 'controlType'.
            </summary>
            <param name="type">The type of value to be edited</param>
            <param name="controlType">The type of the Control that will edit values of 'type'</param>
            <example>
            FluentListView.EditorRegistry.Register(typeof(Color), typeof(MySpecialColorEditor));
            </example>
        </member>
        <member name="M:Fluent.EditorRegistry.Register(System.Type,Fluent.EditorCreatorDelegate)">
            <summary>
            Register the given delegate so that it is called to create editors
            for values of the given type
            </summary>
            <param name="type">The type of value to be edited</param>
            <param name="creator">The delegate that will create a control that can edit values of 'type'</param>
            <example>
            FluentListView.EditorRegistry.Register(typeof(Color), CreateColorEditor);
            ...
            public Control CreateColorEditor(Object model, OLVColumn column, Object value)
            {
                return new MySpecialColorEditor();
            }
            </example>
        </member>
        <member name="M:Fluent.EditorRegistry.RegisterDefault(Fluent.EditorCreatorDelegate)">
            <summary>
            Register a delegate that will be called to create an editor for values
            that have not been handled.
            </summary>
            <param name="creator">The delegate that will create a editor for all other types</param>
        </member>
        <member name="M:Fluent.EditorRegistry.RegisterFirstChance(Fluent.EditorCreatorDelegate)">
            <summary>
            Register a delegate that will be given a chance to create a control
            before any other option is considered.
            </summary>
            <param name="creator">The delegate that will create a control</param>
        </member>
        <member name="M:Fluent.EditorRegistry.Unregister(System.Type)">
            <summary>
            Remove the registered handler for the given type
            </summary>
            <remarks>Does nothing if the given type doesn't exist</remarks>
            <param name="type">The type whose registration is to be removed</param>
        </member>
        <member name="M:Fluent.EditorRegistry.GetEditor(System.Object,Fluent.OLVColumn,System.Object)">
            <summary>
            Create and return an editor that is appropriate for the given value.
            Return null if no appropriate editor can be found.
            </summary>
            <param name="model">The model involved</param>
            <param name="column">The column to be edited</param>
            <param name="value">The value to be edited. This value may not be the exact
            value for the column/model combination. It could be simply representative of
            the appropriate type of value.</param>
            <returns>A Control that can edit the given type of values</returns>
        </member>
        <member name="M:Fluent.EditorRegistry.CreateEnumEditor(System.Type)">
            <summary>
            Create and return an editor that will edit values of the given type
            </summary>
            <param name="type">A enum type</param>
        </member>
        <member name="T:Fluent.IDragSource">
            <summary>
            An IDragSource controls how drag out from the FluentListView will behave
            </summary>
        </member>
        <member name="M:Fluent.IDragSource.StartDrag(Fluent.Lists.AdvancedListView,System.Windows.Forms.MouseButtons,Fluent.OLVListItem)">
            <summary>
            A drag operation is beginning. Return the data object that will be used 
            for data transfer. Return null to prevent the drag from starting. The data
            object will normally include all the selected objects.
            </summary>
            <remarks>
            The returned object is later passed to the GetAllowedEffect() and EndDrag()
            methods.
            </remarks>
            <param name="olv">What FluentListView is being dragged from.</param>
            <param name="button">Which mouse button is down?</param>
            <param name="item">What item was directly dragged by the user? There may be more than just this 
            item selected.</param>
            <returns>The data object that will be used for data transfer. This will often be a subclass
            of DataObject, but does not need to be.</returns>
        </member>
        <member name="M:Fluent.IDragSource.GetAllowedEffects(System.Object)">
            <summary>
            What operations are possible for this drag? This controls the icon shown during the drag
            </summary>
            <param name="dragObject">The data object returned by StartDrag()</param>
            <returns>A combination of DragDropEffects flags</returns>
        </member>
        <member name="M:Fluent.IDragSource.EndDrag(System.Object,System.Windows.Forms.DragDropEffects)">
            <summary>
            The drag operation is complete. Do whatever is necessary to complete the action.
            </summary>
            <param name="dragObject">The data object returned by StartDrag()</param>
            <param name="effect">The value returned from GetAllowedEffects()</param>
        </member>
        <member name="T:Fluent.AbstractDragSource">
            <summary>
            A do-nothing implementation of IDragSource that can be safely subclassed.
            </summary>
        </member>
        <member name="M:Fluent.AbstractDragSource.StartDrag(Fluent.Lists.AdvancedListView,System.Windows.Forms.MouseButtons,Fluent.OLVListItem)">
            <summary>
            See IDragSource documentation
            </summary>
            <param name="olv"></param>
            <param name="button"></param>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:Fluent.AbstractDragSource.GetAllowedEffects(System.Object)">
            <summary>
            See IDragSource documentation
            </summary>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="M:Fluent.AbstractDragSource.EndDrag(System.Object,System.Windows.Forms.DragDropEffects)">
            <summary>
            See IDragSource documentation
            </summary>
            <param name="dragObject"></param>
            <param name="effect"></param>
        </member>
        <member name="T:Fluent.SimpleDragSource">
            <summary>
            A reasonable implementation of IDragSource that provides normal
            drag source functionality. It creates a data object that supports
            inter-application dragging of text and HTML representation of 
            the dragged rows. It can optionally force a refresh of all dragged
            rows when the drag is complete.
            </summary>
            <remarks>Subclasses can override GetDataObject() to add new
            data formats to the data transfer object.</remarks>
        </member>
        <member name="M:Fluent.SimpleDragSource.#ctor">
            <summary>
            Construct a SimpleDragSource
            </summary>
        </member>
        <member name="M:Fluent.SimpleDragSource.#ctor(System.Boolean)">
            <summary>
            Construct a SimpleDragSource that refreshes the dragged rows when
            the drag is complete
            </summary>
            <param name="refreshAfterDrop"></param>
        </member>
        <member name="P:Fluent.SimpleDragSource.RefreshAfterDrop">
            <summary>
            Gets or sets whether the dragged rows should be refreshed when the 
            drag operation is complete.
            </summary>
        </member>
        <member name="M:Fluent.SimpleDragSource.StartDrag(Fluent.Lists.AdvancedListView,System.Windows.Forms.MouseButtons,Fluent.OLVListItem)">
            <summary>
            Create a DataObject when the user does a left mouse drag operation.
            See IDragSource for further information.
            </summary>
            <param name="olv"></param>
            <param name="button"></param>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:Fluent.SimpleDragSource.GetAllowedEffects(System.Object)">
            <summary>
            Which operations are allowed in the operation? By default, all operations are supported.
            </summary>
            <param name="data"></param>
            <returns>All opertions are supported</returns>
        </member>
        <member name="M:Fluent.SimpleDragSource.EndDrag(System.Object,System.Windows.Forms.DragDropEffects)">
            <summary>
            The drag operation is finished. Refreshe the dragged rows if so configured.
            </summary>
            <param name="dragObject"></param>
            <param name="effect"></param>
        </member>
        <member name="M:Fluent.SimpleDragSource.CreateDataObject(Fluent.Lists.AdvancedListView)">
            <summary>
            Create a data object that will be used to as the data object
            for the drag operation.
            </summary>
            <remarks>
            Subclasses can override this method add new formats to the data object.
            </remarks>
            <param name="olv">The FluentListView that is the source of the drag</param>
            <returns>A data object for the drag</returns>
        </member>
        <member name="T:Fluent.IDropSink">
            <summary>
            Objects that implement this interface can acts as the receiver for drop
            operation for an FluentListView.
            </summary>
        </member>
        <member name="P:Fluent.IDropSink.ListView">
            <summary>
            Gets or sets the FluentListView that is the drop sink
            </summary>
        </member>
        <member name="M:Fluent.IDropSink.DrawFeedback(System.Drawing.Graphics,System.Drawing.Rectangle)">
            <summary>
            Draw any feedback that is appropriate to the current drop state.
            </summary>
            <remarks>
            Any drawing is done over the top of the ListView. This operation should disturb
            the Graphic as little as possible. Specifically, do not erase the area into which
            you draw. 
            </remarks>
            <param name="g">A Graphic for drawing</param>
            <param name="bounds">The contents bounds of the ListView (not including any header)</param>
        </member>
        <member name="M:Fluent.IDropSink.Drop(System.Windows.Forms.DragEventArgs)">
            <summary>
            The user has released the drop over this control
            </summary>
            <remarks>
            Implementators should set args.Effect to the appropriate DragDropEffects. This value is returned
            to the originator of the drag.
            </remarks>
            <param name="args"></param>
        </member>
        <member name="M:Fluent.IDropSink.Enter(System.Windows.Forms.DragEventArgs)">
            <summary>
            A drag has entered this control.
            </summary>
            <remarks>Implementators should set args.Effect to the appropriate DragDropEffects.</remarks>
            <param name="args"></param>
        </member>
        <member name="M:Fluent.IDropSink.GiveFeedback(System.Windows.Forms.GiveFeedbackEventArgs)">
            <summary>
            Change the cursor to reflect the current drag operation.
            </summary>
            <param name="args"></param>
        </member>
        <member name="M:Fluent.IDropSink.Leave">
            <summary>
            The drag has left the bounds of this control
            </summary>
        </member>
        <member name="M:Fluent.IDropSink.Over(System.Windows.Forms.DragEventArgs)">
            <summary>
            The drag is moving over this control.
            </summary>
            <remarks>This is where any drop target should be calculated.
            Implementators should set args.Effect to the appropriate DragDropEffects.
            </remarks>
            <param name="args"></param>
        </member>
        <member name="M:Fluent.IDropSink.QueryContinue(System.Windows.Forms.QueryContinueDragEventArgs)">
            <summary>
            Should the drag be allowed to continue?
            </summary>
            <param name="args"></param>
        </member>
        <member name="T:Fluent.AbstractDropSink">
            <summary>
            This is a do-nothing implementation of IDropSink that is a useful
            base class for more sophisticated implementations.
            </summary>
        </member>
        <member name="P:Fluent.AbstractDropSink.ListView">
            <summary>
            Gets or sets the FluentListView that is the drop sink
            </summary>
        </member>
        <member name="M:Fluent.AbstractDropSink.DrawFeedback(System.Drawing.Graphics,System.Drawing.Rectangle)">
            <summary>
            Draw any feedback that is appropriate to the current drop state.
            </summary>
            <remarks>
            Any drawing is done over the top of the ListView. This operation should disturb
            the Graphic as little as possible. Specifically, do not erase the area into which
            you draw. 
            </remarks>
            <param name="g">A Graphic for drawing</param>
            <param name="bounds">The contents bounds of the ListView (not including any header)</param>
        </member>
        <member name="M:Fluent.AbstractDropSink.Drop(System.Windows.Forms.DragEventArgs)">
            <summary>
            The user has released the drop over this control
            </summary>
            <remarks>
            Implementators should set args.Effect to the appropriate DragDropEffects. This value is returned
            to the originator of the drag.
            </remarks>
            <param name="args"></param>
        </member>
        <member name="M:Fluent.AbstractDropSink.Enter(System.Windows.Forms.DragEventArgs)">
            <summary>
            A drag has entered this control.
            </summary>
            <remarks>Implementators should set args.Effect to the appropriate DragDropEffects.</remarks>
            <param name="args"></param>
        </member>
        <member name="M:Fluent.AbstractDropSink.Leave">
            <summary>
            The drag has left the bounds of this control
            </summary>
        </member>
        <member name="M:Fluent.AbstractDropSink.Over(System.Windows.Forms.DragEventArgs)">
            <summary>
            The drag is moving over this control.
            </summary>
            <remarks>This is where any drop target should be calculated.
            Implementators should set args.Effect to the appropriate DragDropEffects.
            </remarks>
            <param name="args"></param>
        </member>
        <member name="M:Fluent.AbstractDropSink.GiveFeedback(System.Windows.Forms.GiveFeedbackEventArgs)">
            <summary>
            Change the cursor to reflect the current drag operation.
            </summary>
            <remarks>You only need to override this if you want non-standard cursors.
            The standard cursors are supplied automatically.</remarks>
            <param name="args"></param>
        </member>
        <member name="M:Fluent.AbstractDropSink.QueryContinue(System.Windows.Forms.QueryContinueDragEventArgs)">
            <summary>
            Should the drag be allowed to continue?
            </summary>
            <remarks>
            You only need to override this if you want the user to be able
            to end the drop in some non-standard way, e.g. dragging to a
            certain point even without releasing the mouse, or going outside
            the bounds of the application. 
            </remarks>
            <param name="args"></param>
        </member>
        <member name="M:Fluent.AbstractDropSink.Cleanup">
            <summary>
            This is called when the mouse leaves the drop region and after the
            drop has completed.
            </summary>
        </member>
        <member name="T:Fluent.DropTargetLocation">
            <summary>
            The enum indicates which target has been found for a drop operation
            </summary>
        </member>
        <member name="F:Fluent.DropTargetLocation.None">
            <summary>
            No applicable target has been found
            </summary>
        </member>
        <member name="F:Fluent.DropTargetLocation.Background">
            <summary>
            The list itself is the target of the drop
            </summary>
        </member>
        <member name="F:Fluent.DropTargetLocation.Item">
            <summary>
            An item is the target
            </summary>
        </member>
        <member name="F:Fluent.DropTargetLocation.BetweenItems">
            <summary>
            Between two items (or above the top item or below the bottom item)
            can be the target. This is not actually ever a target, only a value indicate
            that it is valid to drop between items
            </summary>
        </member>
        <member name="F:Fluent.DropTargetLocation.AboveItem">
            <summary>
            Above an item is the target
            </summary>
        </member>
        <member name="F:Fluent.DropTargetLocation.BelowItem">
            <summary>
            Below an item is the target
            </summary>
        </member>
        <member name="F:Fluent.DropTargetLocation.SubItem">
            <summary>
            A subitem is the target of the drop
            </summary>
        </member>
        <member name="F:Fluent.DropTargetLocation.RightOfItem">
            <summary>
            On the right of an item is the target (not currently used)
            </summary>
        </member>
        <member name="F:Fluent.DropTargetLocation.LeftOfItem">
            <summary>
            On the left of an item is the target (not currently used)
            </summary>
        </member>
        <member name="T:Fluent.SimpleDropSink">
            <summary>
            This class represents a simple implementation of a drop sink.
            </summary>
            <remarks>
            Actually, it should be called CleverDropSink -- it's far from simple and can do quite a lot in its own right.
            </remarks>
        </member>
        <member name="M:Fluent.SimpleDropSink.#ctor">
            <summary>
            Make a new drop sink
            </summary>
        </member>
        <member name="P:Fluent.SimpleDropSink.AcceptableLocations">
            <summary>
            Get or set the locations where a drop is allowed to occur (OR-ed together)
            </summary>
        </member>
        <member name="P:Fluent.SimpleDropSink.AcceptExternal">
            <summary>
            Gets or sets whether this sink allows model objects to be dragged from other lists. Defaults to true.
            </summary>
        </member>
        <member name="P:Fluent.SimpleDropSink.AutoScroll">
            <summary>
            Gets or sets whether the FluentListView should scroll when the user drags
            something near to the top or bottom rows. Defaults to true.
            </summary>
            <remarks>AutoScroll does not scroll horizontally.</remarks>
        </member>
        <member name="P:Fluent.SimpleDropSink.Billboard">
            <summary>
            Gets the billboard overlay that will be used to display feedback
            messages during a drag operation. 
            </summary>
            <remarks>Set this to null to stop the feedback.</remarks>
        </member>
        <member name="P:Fluent.SimpleDropSink.CanDropBetween">
            <summary>
            Get or set whether a drop can occur between items of the list
            </summary>
        </member>
        <member name="P:Fluent.SimpleDropSink.CanDropOnBackground">
            <summary>
            Get or set whether a drop can occur on the listview itself
            </summary>
        </member>
        <member name="P:Fluent.SimpleDropSink.CanDropOnItem">
            <summary>
            Get or set whether a drop can occur on items in the list
            </summary>
        </member>
        <member name="P:Fluent.SimpleDropSink.CanDropOnSubItem">
            <summary>
            Get or set whether a drop can occur on a subitem in the list
            </summary>
        </member>
        <member name="P:Fluent.SimpleDropSink.EnableFeedback">
            <summary>
            Gets or sets whether the drop sink should draw feedback onto the given list
            during the drag operation. Defaults to true.
            </summary>
            <remarks>If this is false, you will have to give the user feedback in some
            other fashion, like cursor changes</remarks>
        </member>
        <member name="P:Fluent.SimpleDropSink.DropTargetIndex">
            <summary>
            Get or set the index of the item that is the target of the drop
            </summary>
        </member>
        <member name="P:Fluent.SimpleDropSink.DropTargetItem">
            <summary>
            Get the item that is the target of the drop
            </summary>
        </member>
        <member name="P:Fluent.SimpleDropSink.DropTargetLocation">
            <summary>
            Get or set the location of the target of the drop
            </summary>
        </member>
        <member name="P:Fluent.SimpleDropSink.DropTargetSubItemIndex">
            <summary>
            Get or set the index of the subitem that is the target of the drop
            </summary>
        </member>
        <member name="P:Fluent.SimpleDropSink.FeedbackColor">
            <summary>
            Get or set the color that will be used to provide drop feedback
            </summary>
        </member>
        <member name="P:Fluent.SimpleDropSink.IsAltDown">
            <summary>
            Get whether the alt key was down during this drop event
            </summary>
        </member>
        <member name="P:Fluent.SimpleDropSink.IsAnyModifierDown">
            <summary>
            Get whether any modifier key was down during this drop event
            </summary>
        </member>
        <member name="P:Fluent.SimpleDropSink.IsControlDown">
            <summary>
            Get whether the control key was down during this drop event
            </summary>
        </member>
        <member name="P:Fluent.SimpleDropSink.IsLeftMouseButtonDown">
            <summary>
            Get whether the left mouse button was down during this drop event
            </summary>
        </member>
        <member name="P:Fluent.SimpleDropSink.IsMiddleMouseButtonDown">
            <summary>
            Get whether the right mouse button was down during this drop event
            </summary>
        </member>
        <member name="P:Fluent.SimpleDropSink.IsRightMouseButtonDown">
            <summary>
            Get whether the right mouse button was down during this drop event
            </summary>
        </member>
        <member name="P:Fluent.SimpleDropSink.IsShiftDown">
            <summary>
            Get whether the shift key was down during this drop event
            </summary>
        </member>
        <member name="P:Fluent.SimpleDropSink.KeyState">
            <summary>
            Get or set the state of the keys during this drop event
            </summary>
        </member>
        <member name="P:Fluent.SimpleDropSink.UseDefaultCursors">
            <summary>
            Gets or sets whether the drop sink will automatically use cursors
            based on the drop effect. By default, this is true. If this is
            set to false, you must set the Cursor yourself.
            </summary>
        </member>
        <member name="E:Fluent.SimpleDropSink.CanDrop">
            <summary>
            Triggered when the sink needs to know if a drop can occur.
            </summary>
            <remarks>
            Handlers should set Effect to indicate what is possible.
            Handlers can change any of the DropTarget* setttings to change
            the target of the drop.
            </remarks>
        </member>
        <member name="E:Fluent.SimpleDropSink.Dropped">
            <summary>
            Triggered when the drop is made.
            </summary>
        </member>
        <member name="E:Fluent.SimpleDropSink.ModelCanDrop">
            <summary>
            Triggered when the sink needs to know if a drop can occur
            AND the source is an FluentListView
            </summary>
            <remarks>
            Handlers should set Effect to indicate what is possible.
            Handlers can change any of the DropTarget* setttings to change
            the target of the drop.
            </remarks>
        </member>
        <member name="E:Fluent.SimpleDropSink.ModelDropped">
            <summary>
            Triggered when the drop is made.
            AND the source is an FluentListView
            </summary>
        </member>
        <member name="M:Fluent.SimpleDropSink.Cleanup">
            <summary>
            Cleanup the drop sink when the mouse has left the control or 
            the drag has finished.
            </summary>
        </member>
        <member name="M:Fluent.SimpleDropSink.DrawFeedback(System.Drawing.Graphics,System.Drawing.Rectangle)">
            <summary>
            Draw any feedback that is appropriate to the current drop state.
            </summary>
            <remarks>
            Any drawing is done over the top of the ListView. This operation should disturb
            the Graphic as little as possible. Specifically, do not erase the area into which
            you draw. 
            </remarks>
            <param name="g">A Graphic for drawing</param>
            <param name="bounds">The contents bounds of the ListView (not including any header)</param>
        </member>
        <member name="M:Fluent.SimpleDropSink.Drop(System.Windows.Forms.DragEventArgs)">
            <summary>
            The user has released the drop over this control
            </summary>
            <param name="args"></param>
        </member>
        <member name="M:Fluent.SimpleDropSink.Enter(System.Windows.Forms.DragEventArgs)">
            <summary>
            A drag has entered this control.
            </summary>
            <remarks>Implementators should set args.Effect to the appropriate DragDropEffects.</remarks>
            <param name="args"></param>
        </member>
        <member name="M:Fluent.SimpleDropSink.GiveFeedback(System.Windows.Forms.GiveFeedbackEventArgs)">
            <summary>
            Change the cursor to reflect the current drag operation.
            </summary>
            <param name="args"></param>
        </member>
        <member name="M:Fluent.SimpleDropSink.Over(System.Windows.Forms.DragEventArgs)">
            <summary>
            The drag is moving over this control.
            </summary>
            <param name="args"></param>
        </member>
        <member name="M:Fluent.SimpleDropSink.TriggerDroppedEvent(System.Windows.Forms.DragEventArgs)">
            <summary>
            Trigger the Dropped events
            </summary>
            <param name="args"></param>
        </member>
        <member name="M:Fluent.SimpleDropSink.OnCanDrop(Fluent.OlvDropEventArgs)">
            <summary>
            Trigger CanDrop
            </summary>
            <param name="args"></param>
        </member>
        <member name="M:Fluent.SimpleDropSink.OnDropped(Fluent.OlvDropEventArgs)">
            <summary>
            Trigger Dropped
            </summary>
            <param name="args"></param>
        </member>
        <member name="M:Fluent.SimpleDropSink.OnModelCanDrop(Fluent.ModelDropEventArgs)">
            <summary>
            Trigger ModelCanDrop
            </summary>
            <param name="args"></param>
        </member>
        <member name="M:Fluent.SimpleDropSink.OnModelDropped(Fluent.ModelDropEventArgs)">
            <summary>
            Trigger ModelDropped
            </summary>
            <param name="args"></param>
        </member>
        <member name="M:Fluent.SimpleDropSink.HandleTimerTick">
            <summary>
            Handle the timer tick event, which is sent when the listview should
            scroll
            </summary>
        </member>
        <member name="M:Fluent.SimpleDropSink.CalculateDropTarget(Fluent.OlvDropEventArgs,System.Drawing.Point)">
            <summary>
            When the mouse is at the given point, what should the target of the drop be?
            </summary>
            <remarks>This method should update the DropTarget* members of the given arg block</remarks>
            <param name="args"></param>
            <param name="pt">The mouse point, in client co-ordinates</param>
        </member>
        <member name="M:Fluent.SimpleDropSink.CalculateDropAction(System.Windows.Forms.DragEventArgs,System.Drawing.Point)">
            <summary>
            What sort of action is possible when the mouse is at the given point?
            </summary>
            <remarks>
            </remarks>
            <param name="args"></param>
            <param name="pt"></param>
            <returns></returns>
        </member>
        <member name="M:Fluent.SimpleDropSink.CalculateStandardDropActionFromKeys">
            <summary>
            Based solely on the state of the modifier keys, what drop operation should
            be used?
            </summary>
            <returns>The drop operation that matches the state of the keys</returns>
        </member>
        <member name="M:Fluent.SimpleDropSink.CheckScrolling(System.Drawing.Point)">
            <summary>
            Should the listview be made to scroll when the mouse is at the given point?
            </summary>
            <param name="pt"></param>
        </member>
        <member name="M:Fluent.SimpleDropSink.UpdateAfterCanDropEvent(Fluent.OlvDropEventArgs)">
            <summary>
            Update the state of our sink to reflect the information that 
            may have been written into the drop event args.
            </summary>
            <param name="args"></param>
        </member>
        <member name="M:Fluent.SimpleDropSink.DrawFeedbackBackgroundTarget(System.Drawing.Graphics,System.Drawing.Rectangle)">
            <summary>
            Draw the feedback that shows that the background is the target
            </summary>
            <param name="g"></param>
            <param name="bounds"></param>
        </member>
        <member name="M:Fluent.SimpleDropSink.DrawFeedbackItemTarget(System.Drawing.Graphics,System.Drawing.Rectangle)">
            <summary>
            Draw the feedback that shows that an item (or a subitem) is the target
            </summary>
            <param name="g"></param>
            <param name="bounds"></param>
            <remarks>
            DropTargetItem and DropTargetSubItemIndex tells what is the target
            </remarks>
        </member>
        <member name="M:Fluent.SimpleDropSink.DrawFeedbackAboveItemTarget(System.Drawing.Graphics,System.Drawing.Rectangle)">
            <summary>
            Draw the feedback that shows the drop will occur before target
            </summary>
            <param name="g"></param>
            <param name="bounds"></param>
        </member>
        <member name="M:Fluent.SimpleDropSink.DrawFeedbackBelowItemTarget(System.Drawing.Graphics,System.Drawing.Rectangle)">
            <summary>
            Draw the feedback that shows the drop will occur after target
            </summary>
            <param name="g"></param>
            <param name="bounds"></param>
        </member>
        <member name="M:Fluent.SimpleDropSink.GetRoundedRect(System.Drawing.Rectangle,System.Single)">
            <summary>
            Return a GraphicPath that is round corner rectangle.
            </summary>
            <param name="rect"></param>
            <param name="diameter"></param>
            <returns></returns>
        </member>
        <member name="M:Fluent.SimpleDropSink.CalculateDropTargetRectangle(Fluent.OLVListItem,System.Int32)">
            <summary>
            Calculate the target rectangle when the given item (and possible subitem)
            is the target of the drop.
            </summary>
            <param name="item"></param>
            <param name="subItem"></param>
            <returns></returns>
        </member>
        <member name="M:Fluent.SimpleDropSink.DrawBetweenLine(System.Drawing.Graphics,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Draw a "between items" line at the given co-ordinates
            </summary>
            <param name="g"></param>
            <param name="x1"></param>
            <param name="y1"></param>
            <param name="x2"></param>
            <param name="y2"></param>
        </member>
        <member name="T:Fluent.RearrangingDropSink">
            <summary>
            This drop sink allows items within the same list to be rearranged,
            as well as allowing items to be dropped from other lists.
            </summary>
            <remarks>
            <para>
            This class can only be used on plain FluentListViews and FastFluentListViews.
            The other flavours have no way to implement the insert operation that is required.
            </para>
            <para>
            This class does not work with grouping.
            </para>
            <para>
            This class works when the OLV is sorted, but it is up to the programmer
            to decide what rearranging such lists "means". Example: if the control is sorting
            students by academic grade, and the user drags a "Fail" grade student up amonst the "A+"
            students, it is the responsibility of the programmer to makes the appropriate changes
            to the model and redraw/rebuild the control so that the users action makes sense.
            </para>
            <para>
            Users of this class should listen for the CanDrop event to decide
            if models from another OLV can be moved to OLV under this sink.
            </para>
            </remarks>
        </member>
        <member name="M:Fluent.RearrangingDropSink.#ctor">
            <summary>
            Create a RearrangingDropSink
            </summary>
        </member>
        <member name="M:Fluent.RearrangingDropSink.#ctor(System.Boolean)">
            <summary>
            Create a RearrangingDropSink
            </summary>
            <param name="acceptDropsFromOtherLists"></param>
        </member>
        <member name="M:Fluent.RearrangingDropSink.OnModelCanDrop(Fluent.ModelDropEventArgs)">
            <summary>
            Trigger OnModelCanDrop
            </summary>
            <param name="args"></param>
        </member>
        <member name="M:Fluent.RearrangingDropSink.OnModelDropped(Fluent.ModelDropEventArgs)">
            <summary>
            Trigger OnModelDropped
            </summary>
            <param name="args"></param>
        </member>
        <member name="M:Fluent.RearrangingDropSink.RearrangeModels(Fluent.ModelDropEventArgs)">
            <summary>
            Do the work of processing the dropped items
            </summary>
            <param name="args"></param>
        </member>
        <member name="T:Fluent.OlvDropEventArgs">
            <summary>
            When a drop sink needs to know if something can be dropped, or
            to notify that a drop has occured, it uses an instance of this class.
            </summary>
        </member>
        <member name="M:Fluent.OlvDropEventArgs.#ctor">
            <summary>
            Create a OlvDropEventArgs
            </summary>
        </member>
        <member name="P:Fluent.OlvDropEventArgs.DragEventArgs">
            <summary>
            Get the original drag-drop event args
            </summary>
        </member>
        <member name="P:Fluent.OlvDropEventArgs.DataObject">
            <summary>
            Get the data object that is being dragged
            </summary>
        </member>
        <member name="P:Fluent.OlvDropEventArgs.DropSink">
            <summary>
            Get the drop sink that originated this event
            </summary>
        </member>
        <member name="P:Fluent.OlvDropEventArgs.DropTargetIndex">
            <summary>
            Get or set the index of the item that is the target of the drop
            </summary>
        </member>
        <member name="P:Fluent.OlvDropEventArgs.DropTargetLocation">
            <summary>
            Get or set the location of the target of the drop
            </summary>
        </member>
        <member name="P:Fluent.OlvDropEventArgs.DropTargetSubItemIndex">
            <summary>
            Get or set the index of the subitem that is the target of the drop
            </summary>
        </member>
        <member name="P:Fluent.OlvDropEventArgs.DropTargetItem">
            <summary>
            Get the item that is the target of the drop
            </summary>
        </member>
        <member name="P:Fluent.OlvDropEventArgs.Effect">
            <summary>
            Get or set the drag effect that should be used for this operation
            </summary>
        </member>
        <member name="P:Fluent.OlvDropEventArgs.Handled">
            <summary>
            Get or set if this event was handled. No further processing will be done for a handled event.
            </summary>
        </member>
        <member name="P:Fluent.OlvDropEventArgs.InfoMessage">
            <summary>
            Get or set the feedback message for this operation
            </summary>
            <remarks>
            If this is not null, it will be displayed as a feedback message
            during the drag.
            </remarks>
        </member>
        <member name="P:Fluent.OlvDropEventArgs.ListView">
            <summary>
            Get the FluentListView that is being dropped on
            </summary>
        </member>
        <member name="P:Fluent.OlvDropEventArgs.MouseLocation">
            <summary>
            Get the location of the mouse (in target ListView co-ords)
            </summary>
        </member>
        <member name="P:Fluent.OlvDropEventArgs.StandardDropActionFromKeys">
            <summary>
            Get the drop action indicated solely by the state of the modifier keys
            </summary>
        </member>
        <member name="T:Fluent.ModelDropEventArgs">
            <summary>
            These events are triggered when the drag source is an FluentListView.
            </summary>
        </member>
        <member name="M:Fluent.ModelDropEventArgs.#ctor">
            <summary>
            Create a ModelDropEventArgs
            </summary>
        </member>
        <member name="P:Fluent.ModelDropEventArgs.SourceModels">
            <summary>
            Gets the model objects that are being dragged.
            </summary>
        </member>
        <member name="P:Fluent.ModelDropEventArgs.SourceListView">
            <summary>
            Gets the FluentListView that is the source of the dragged objects.
            </summary>
        </member>
        <member name="P:Fluent.ModelDropEventArgs.TargetModel">
            <summary>
            Get the model object that is being dropped upon.
            </summary>
            <remarks>This is only value for TargetLocation == Item</remarks>
        </member>
        <member name="M:Fluent.ModelDropEventArgs.RefreshObjects">
            <summary>
            Refresh all the objects involved in the operation
            </summary>
        </member>
        <member name="T:Fluent.OLVDataObject">
            <summary>
            A data transfer object that knows how to transform a list of model
            objects into a text and HTML representation.
            </summary>
        </member>
        <member name="M:Fluent.OLVDataObject.#ctor(Fluent.Lists.AdvancedListView)">
            <summary>
            Create a data object from the selected objects in the given FluentListView
            </summary>
            <param name="olv">The source of the data object</param>
        </member>
        <member name="M:Fluent.OLVDataObject.#ctor(Fluent.Lists.AdvancedListView,System.Collections.IList)">
            <summary>
            Create a data object which operates on the given model objects 
            in the given FluentListView
            </summary>
            <param name="olv">The source of the data object</param>
            <param name="modelObjects">The model objects to be put into the data object</param>
        </member>
        <member name="P:Fluent.OLVDataObject.IncludeHiddenColumns">
            <summary>
            Gets or sets whether hidden columns will also be included in the text
            and HTML representation. If this is false, only visible columns will
            be included.
            </summary>
        </member>
        <member name="P:Fluent.OLVDataObject.IncludeColumnHeaders">
            <summary>
            Gets or sets whether column headers will also be included in the text
            and HTML representation.
            </summary>
        </member>
        <member name="P:Fluent.OLVDataObject.ListView">
            <summary>
            Gets the FluentListView that is being used as the source of the data
            </summary>
        </member>
        <member name="P:Fluent.OLVDataObject.ModelObjects">
            <summary>
            Gets the model objects that are to be placed in the data object
            </summary>
        </member>
        <member name="M:Fluent.OLVDataObject.CreateTextFormats">
            <summary>
            Put a text and HTML representation of our model objects
            into the data object.
            </summary>
        </member>
        <member name="M:Fluent.OLVDataObject.CreateExporter">
            <summary>
            Create an exporter for the data contained in this object
            </summary>
            <returns></returns>
        </member>
        <member name="M:Fluent.OLVDataObject.CreateHtml">
            <summary>
            Make a HTML representation of our model objects
            </summary>
        </member>
        <member name="M:Fluent.OLVDataObject.ConvertToHtmlFragment(System.String)">
            <summary>
            Convert the fragment of HTML into the Clipboards HTML format.
            </summary>
            <remarks>The HTML format is found here http://msdn2.microsoft.com/en-us/library/aa767917.aspx
            </remarks>
            <param name="fragment">The HTML to put onto the clipboard. It must be valid HTML!</param>
            <returns>A string that can be put onto the clipboard and will be recognized as HTML</returns>
        </member>
        <member name="T:Fluent.Cluster">
            <summary>
            Concrete implementation of the ICluster interface.
            </summary>
        </member>
        <member name="M:Fluent.Cluster.#ctor(System.Object)">
            <summary>
            Create a cluster
            </summary>
            <param name="key">The key for the cluster</param>
        </member>
        <member name="M:Fluent.Cluster.ToString">
            <summary>
            Return a string representation of this cluster
            </summary>
            <returns></returns>
        </member>
        <member name="P:Fluent.Cluster.Count">
            <summary>
            Gets or sets how many items belong to this cluster
            </summary>
        </member>
        <member name="P:Fluent.Cluster.DisplayLabel">
            <summary>
            Gets or sets the label that will be shown to the user to represent
            this cluster
            </summary>
        </member>
        <member name="P:Fluent.Cluster.ClusterKey">
            <summary>
            Gets or sets the actual data object that all members of this cluster
            have commonly returned.
            </summary>
        </member>
        <member name="M:Fluent.Cluster.CompareTo(System.Object)">
            <summary>
            Return an indication of the ordering between this object and the given one
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="T:Fluent.ClusteringStrategy">
            <summary>
            This class provides a useful base implemention of a clustering
            strategy where the clusters are grouped around the value of a given column.
            </summary>
        </member>
        <member name="F:Fluent.ClusteringStrategy.NULL_LABEL">
            <summary>
            This field is the text that will be shown to the user when a cluster
            key is null. It is exposed so it can be localized.
            </summary>
        </member>
        <member name="F:Fluent.ClusteringStrategy.EMPTY_LABEL">
            <summary>
            This field is the text that will be shown to the user when a cluster
            key is empty (i.e. a string of zero length). It is exposed so it can be localized.
            </summary>
        </member>
        <member name="P:Fluent.ClusteringStrategy.DefaultDisplayLabelFormatSingular">
            <summary>
            Gets or sets the format that will be used by default for clusters that only
            contain 1 item. The format string must accept two placeholders:
            - {0} is the cluster key converted to a string
            - {1} is the number of items in the cluster (always 1 in this case)
            </summary>
        </member>
        <member name="P:Fluent.ClusteringStrategy.DefaultDisplayLabelFormatPlural">
            <summary>
            Gets or sets the format that will be used by default for clusters that 
            contain 0 or two or more items. The format string must accept two placeholders:
            - {0} is the cluster key converted to a string
            - {1} is the number of items in the cluster
            </summary>
        </member>
        <member name="M:Fluent.ClusteringStrategy.#ctor">
            <summary>
            Create a clustering strategy
            </summary>
        </member>
        <member name="P:Fluent.ClusteringStrategy.Column">
            <summary>
            Gets or sets the column upon which this strategy is operating
            </summary>
        </member>
        <member name="P:Fluent.ClusteringStrategy.DisplayLabelFormatSingular">
            <summary>
            Gets or sets the format that will be used when the cluster
            contains only 1 item. The format string must accept two placeholders:
            - {0} is the cluster key converted to a string
            - {1} is the number of items in the cluster (always 1 in this case)
            </summary>
            <remarks>If this is not set, the value from 
            ClusteringStrategy.DefaultDisplayLabelFormatSingular will be used</remarks>
        </member>
        <member name="P:Fluent.ClusteringStrategy.DisplayLabelFormatPlural">
            <summary>
            Gets or sets the format that will be used when the cluster 
            contains 0 or two or more items. The format string must accept two placeholders:
            - {0} is the cluster key converted to a string
            - {1} is the number of items in the cluster
            </summary>
            <remarks>If this is not set, the value from 
            ClusteringStrategy.DefaultDisplayLabelFormatPlural will be used</remarks>
        </member>
        <member name="M:Fluent.ClusteringStrategy.GetClusterKey(System.Object)">
            <summary>
            Get the cluster key by which the given model will be partitioned by this strategy
            </summary>
            <param name="model"></param>
            <returns></returns>
        </member>
        <member name="M:Fluent.ClusteringStrategy.CreateCluster(System.Object)">
            <summary>
            Create a cluster to hold the given cluster key
            </summary>
            <param name="clusterKey"></param>
            <returns></returns>
        </member>
        <member name="M:Fluent.ClusteringStrategy.GetClusterDisplayLabel(Fluent.ICluster)">
            <summary>
            Gets the display label that the given cluster should use
            </summary>
            <param name="cluster"></param>
            <returns></returns>
        </member>
        <member name="M:Fluent.ClusteringStrategy.CreateFilter(System.Collections.IList)">
            <summary>
            Create a filter that will include only model objects that
            match one or more of the given values.
            </summary>
            <param name="valuesChosenForFiltering"></param>
            <returns></returns>
        </member>
        <member name="M:Fluent.ClusteringStrategy.ApplyDisplayFormat(Fluent.ICluster,System.String)">
            <summary>
            Create a label that combines the string representation of the cluster
            key with a format string that holds an "X [N items in cluster]" type layout.
            </summary>
            <param name="cluster"></param>
            <param name="s"></param>
            <returns></returns>
        </member>
        <member name="T:Fluent.ClustersFromGroupsStrategy">
            <summary>
            This class calculates clusters from the groups that the column uses.
            </summary>
            <remarks>
            <para>
            This is the default strategy for all non-date, filterable columns.
            </para>
            <para>
            This class does not strictly mimic the groups created by the given column.
            In particular, if the programmer changes the default grouping technique
            by listening for grouping events, this class will not mimic that behaviour.
            </para>
            </remarks>
        </member>
        <member name="M:Fluent.ClustersFromGroupsStrategy.GetClusterKey(System.Object)">
            <summary>
            Get the cluster key by which the given model will be partitioned by this strategy
            </summary>
            <param name="model"></param>
            <returns></returns>
        </member>
        <member name="M:Fluent.ClustersFromGroupsStrategy.GetClusterDisplayLabel(Fluent.ICluster)">
            <summary>
            Gets the display label that the given cluster should use
            </summary>
            <param name="cluster"></param>
            <returns></returns>
        </member>
        <member name="T:Fluent.DateTimePortion">
            <summary>
            This enum is used to indicate various portions of a datetime
            </summary>
        </member>
        <member name="F:Fluent.DateTimePortion.Year">
            <summary>
            Year
            </summary>
        </member>
        <member name="F:Fluent.DateTimePortion.Month">
            <summary>
            Month
            </summary>
        </member>
        <member name="F:Fluent.DateTimePortion.Day">
            <summary>
            Day of the month
            </summary>
        </member>
        <member name="F:Fluent.DateTimePortion.Hour">
            <summary>
            Hour
            </summary>
        </member>
        <member name="F:Fluent.DateTimePortion.Minute">
            <summary>
            Minute
            </summary>
        </member>
        <member name="F:Fluent.DateTimePortion.Second">
            <summary>
            Second
            </summary>
        </member>
        <member name="T:Fluent.DateTimeClusteringStrategy">
            <summary>
            This class implements a strategy where the model objects are clustered
            according to some portion of the datetime value in the configured column.
            </summary>
            <remarks>To create a strategy that grouped people who were born in
            the same month, you would create a strategy that extracted just
            the month, and formatted it to show just the month's name. Like this:
            </remarks>
            <example>
            someColumn.ClusteringStrategy = new DateTimeClusteringStrategy(DateTimePortion.Month, "MMMM");
            </example>
        </member>
        <member name="M:Fluent.DateTimeClusteringStrategy.#ctor">
            <summary>
            Create a strategy that clusters by month/year
            </summary>
        </member>
        <member name="M:Fluent.DateTimeClusteringStrategy.#ctor(Fluent.DateTimePortion,System.String)">
            <summary>
            Create a strategy that clusters around the given parts
            </summary>
            <param name="portions"></param>
            <param name="format"></param>
        </member>
        <member name="P:Fluent.DateTimeClusteringStrategy.Format">
            <summary>
            Gets or sets the format string will will be used to create a user-presentable
            version of the cluster key.
            </summary>
            <remarks>The format should use the date/time format strings, as documented
            in the Windows SDK. Both standard formats and custom format will work.</remarks>
            <example>"D" - long date pattern</example>
            <example>"MMMM, yyyy" - "January, 1999"</example>
        </member>
        <member name="P:Fluent.DateTimeClusteringStrategy.Portions">
            <summary>
            Gets or sets the parts of the DateTime that will be extracted when
            determining the clustering key for an object.
            </summary>
        </member>
        <member name="M:Fluent.DateTimeClusteringStrategy.GetClusterKey(System.Object)">
            <summary>
            Get the cluster key by which the given model will be partitioned by this strategy
            </summary>
            <param name="model"></param>
            <returns></returns>
        </member>
        <member name="M:Fluent.DateTimeClusteringStrategy.GetClusterDisplayLabel(Fluent.ICluster)">
            <summary>
            Gets the display label that the given cluster should use
            </summary>
            <param name="cluster"></param>
            <returns></returns>
        </member>
        <member name="M:Fluent.DateTimeClusteringStrategy.DateToString(System.DateTime)">
            <summary>
            Convert the given date into a user presentable string
            </summary>
            <param name="dateTime"></param>
            <returns></returns>
        </member>
        <member name="T:Fluent.FilterMenuBuilder">
            <summary>
            Instances of this class know how to build a Filter menu.
            It is responsible for clustering the values in the target column,
            build a menu that shows those clusters, and then constructing
            a filter that will enact the users choices.
            </summary>
            <remarks>
            Almost all of the methods in this class are declared as "virtual protected"
            so that subclasses can provide alternative behaviours.
            </remarks>
        </member>
        <member name="F:Fluent.FilterMenuBuilder.APPLY_LABEL">
            <summary>
            Gets or sets the string that labels the Apply button.
            Exposed so it can be localized.
            </summary>
        </member>
        <member name="F:Fluent.FilterMenuBuilder.CLEAR_ALL_FILTERS_LABEL">
            <summary>
            Gets or sets the string that labels the Clear All menu item.
            Exposed so it can be localized.
            </summary>
        </member>
        <member name="F:Fluent.FilterMenuBuilder.FILTERING_LABEL">
            <summary>
            Gets or sets the string that labels the Filtering menu as a whole..
            Exposed so it can be localized.
            </summary>
        </member>
        <member name="F:Fluent.FilterMenuBuilder.SELECT_ALL_LABEL">
            <summary>
            Gets or sets the string that represents Select All values.
            If this is set to null or empty, no Select All option will be included.
            Exposed so it can be localized.
            </summary>
        </member>
        <member name="F:Fluent.FilterMenuBuilder.ClearFilteringImage">
            <summary>
            Gets or sets the image that will be placed next to the Clear Filtering menu item
            </summary>
        </member>
        <member name="F:Fluent.FilterMenuBuilder.FilteringImage">
            <summary>
            Gets or sets the image that will be placed next to all "Apply" menu items on the filtering menu
            </summary>
        </member>
        <member name="P:Fluent.FilterMenuBuilder.TreatNullAsDataValue">
            <summary>
            Gets or sets whether null should be considered as a valid data value.
            If this is true (the default), then a cluster will null as a key will be allow.
            If this is false, object that return a cluster key of null will ignored.
            </summary>
        </member>
        <member name="P:Fluent.FilterMenuBuilder.MaxObjectsToConsider">
            <summary>
            Gets or sets the maximum number of objects that the clustering strategy
            will consider. This should be large enough to collect all unique clusters,
            but small enough to finish in a reasonable time.
            </summary>
            <remarks>The default value is 10,000. This should be perfectly
            acceptable for almost all lists.</remarks>
        </member>
        <member name="M:Fluent.FilterMenuBuilder.MakeFilterMenu(System.Windows.Forms.ToolStripDropDown,Fluent.Lists.AdvancedListView,Fluent.OLVColumn)">
            <summary>
            Create a Filter menu on the given tool tip for the given column in the given FluentListView.
            </summary>
            <remarks>This is the main entry point into this class.</remarks>
            <param name="strip"></param>
            <param name="listView"></param>
            <param name="column"></param>
            <returns>The strip that should be shown to the user</returns>
        </member>
        <member name="M:Fluent.FilterMenuBuilder.Cluster(Fluent.IClusteringStrategy,Fluent.Lists.AdvancedListView,Fluent.OLVColumn)">
            <summary>
            Create a collection of clusters that should be presented to the user
            </summary>
            <param name="strategy"></param>
            <param name="listView"></param>
            <param name="column"></param>
            <returns></returns>
        </member>
        <member name="M:Fluent.FilterMenuBuilder.SortClusters(Fluent.IClusteringStrategy,System.Collections.Generic.List{Fluent.ICluster})">
            <summary>
            Order the given list of clusters in the manner in which they should be presented to the user.
            </summary>
            <param name="strategy"></param>
            <param name="clusters"></param>
        </member>
        <member name="M:Fluent.FilterMenuBuilder.CreateFilteringMenuItem(Fluent.OLVColumn,System.Collections.Generic.List{Fluent.ICluster})">
            <summary>
            Do the work of making a menu that shows the clusters to the users
            </summary>
            <param name="column"></param>
            <param name="clusters"></param>
            <returns></returns>
        </member>
        <member name="M:Fluent.FilterMenuBuilder.HandleItemCheckedWrapped(System.Object,System.Windows.Forms.ItemCheckEventArgs)">
            <summary>
            Wrap a protected section around the real HandleItemChecked method, so that if
            that method tries to change a "checkedness" of an item, we don't get a recursive 
            stack error. Effectively, this ensure that HandleItemChecked is only called
            in response to a user action.
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="M:Fluent.FilterMenuBuilder.HandleItemChecked(System.Object,System.Windows.Forms.ItemCheckEventArgs)">
            <summary>
            Handle a user-generated ItemCheck event
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="M:Fluent.FilterMenuBuilder.HandleSelectAllItem(System.Windows.Forms.ItemCheckEventArgs,Fluent.ToolStripCheckedListBox,System.Int32)">
            <summary>
            Handle any checking/unchecking of the Select All option, and keep
            its checkedness in sync with everything else that is checked.
            </summary>
            <param name="e"></param>
            <param name="checkedList"></param>
            <param name="selectAllIndex"></param>
        </member>
        <member name="M:Fluent.FilterMenuBuilder.ClearAllFilters(Fluent.OLVColumn)">
            <summary>
            Clear all the filters that are applied to the given column
            </summary>
            <param name="column">The column from which filters are to be removed</param>
        </member>
        <member name="M:Fluent.FilterMenuBuilder.EnactFilter(Fluent.ToolStripCheckedListBox,Fluent.OLVColumn)">
            <summary>
            Apply the selected values from the given list as a filter on the given column
            </summary>
            <param name="checkedList">A list in which the checked items should be used as filters</param>
            <param name="column">The column for which a filter should be generated</param>
        </member>
        <member name="T:Fluent.IModelFilter">
            <summary>
            Interface for model-by-model filtering
            </summary>
        </member>
        <member name="M:Fluent.IModelFilter.Filter(System.Object)">
            <summary>
            Should the given model be included when this filter is installed
            </summary>
            <param name="modelObject">The model object to consider</param>
            <returns>Returns true if the model will be included by the filter</returns>
        </member>
        <member name="T:Fluent.IListFilter">
            <summary>
            Interface for whole list filtering
            </summary>
        </member>
        <member name="M:Fluent.IListFilter.Filter(System.Collections.IEnumerable)">
            <summary>
            Return a subset of the given list of model objects as the new
            contents of the FluentListView
            </summary>
            <param name="modelObjects">The collection of model objects that the list will possibly display</param>
            <returns>The filtered collection that holds the model objects that will be displayed.</returns>
        </member>
        <member name="T:Fluent.AbstractModelFilter">
            <summary>
            Base class for model-by-model filters
            </summary>
        </member>
        <member name="M:Fluent.AbstractModelFilter.Filter(System.Object)">
            <summary>
            Should the given model be included when this filter is installed
            </summary>
            <param name="modelObject">The model object to consider</param>
            <returns>Returns true if the model will be included by the filter</returns>
        </member>
        <member name="T:Fluent.ModelFilter">
            <summary>
            This filter calls a given Predicate to decide if a model object should be included
            </summary>
        </member>
        <member name="M:Fluent.ModelFilter.#ctor(System.Predicate{System.Object})">
            <summary>
            Create a filter based on the given predicate
            </summary>
            <param name="predicate">The function that will filter objects</param>
        </member>
        <member name="P:Fluent.ModelFilter.Predicate">
            <summary>
            Gets or sets the predicate used to filter model objects
            </summary>
        </member>
        <member name="M:Fluent.ModelFilter.Filter(System.Object)">
            <summary>
            Should the given model object be included?
            </summary>
            <param name="modelObject"></param>
            <returns></returns>
        </member>
        <member name="T:Fluent.CompositeFilter">
            <summary>
            A CompositeFilter joins several other filters together.
            If there are no filters, all model objects are included
            </summary>
        </member>
        <member name="M:Fluent.CompositeFilter.#ctor">
            <summary>
            Create an empty filter
            </summary>
        </member>
        <member name="M:Fluent.CompositeFilter.#ctor(System.Collections.Generic.IEnumerable{Fluent.IModelFilter})">
            <summary>
            Create a composite filter from the given list of filters
            </summary>
            <param name="filters">A list of filters</param>
        </member>
        <member name="P:Fluent.CompositeFilter.Filters">
            <summary>
            Gets or sets the filters used by this composite
            </summary>
        </member>
        <member name="P:Fluent.CompositeFilter.TextFilters">
            <summary>
            Get the sub filters that are text match filters
            </summary>
        </member>
        <member name="M:Fluent.CompositeFilter.Filter(System.Object)">
            <summary>
            Decide whether or not the given model should be included by the filter
            </summary>
            <param name="modelObject"></param>
            <returns>True if the object is included by the filter</returns>
        </member>
        <member name="M:Fluent.CompositeFilter.FilterObject(System.Object)">
            <summary>
            Decide whether or not the given model should be included by the filter
            </summary>
            <remarks>Filters is guaranteed to be non-empty when this method is called</remarks>
            <param name="modelObject">The model object under consideration</param>
            <returns>True if the object is included by the filter</returns>
        </member>
        <member name="T:Fluent.CompositeAllFilter">
            <summary>
            A CompositeAllFilter joins several other filters together.
            A model object must satisfy all filters to be included.
            If there are no filters, all model objects are included
            </summary>
        </member>
        <member name="M:Fluent.CompositeAllFilter.#ctor(System.Collections.Generic.List{Fluent.IModelFilter})">
            <summary>
            Create a filter
            </summary>
            <param name="filters"></param>
        </member>
        <member name="M:Fluent.CompositeAllFilter.FilterObject(System.Object)">
            <summary>
            Decide whether or not the given model should be included by the filter
            </summary>
            <remarks>Filters is guaranteed to be non-empty when this method is called</remarks>
            <param name="modelObject">The model object under consideration</param>
            <returns>True if the object is included by the filter</returns>
        </member>
        <member name="T:Fluent.CompositeAnyFilter">
            <summary>
            A CompositeAllFilter joins several other filters together.
            A model object must only satisfy one of the filters to be included.
            If there are no filters, all model objects are included
            </summary>
        </member>
        <member name="M:Fluent.CompositeAnyFilter.#ctor(System.Collections.Generic.List{Fluent.IModelFilter})">
            <summary>
            Create a filter from the given filters
            </summary>
            <param name="filters"></param>
        </member>
        <member name="M:Fluent.CompositeAnyFilter.FilterObject(System.Object)">
            <summary>
            Decide whether or not the given model should be included by the filter
            </summary>
            <remarks>Filters is guaranteed to be non-empty when this method is called</remarks>
            <param name="modelObject">The model object under consideration</param>
            <returns>True if the object is included by the filter</returns>
        </member>
        <member name="T:Fluent.OneOfFilter">
            <summary>
            Instances of this class extract a value from the model object
            and compare that value to a list of fixed values. The model
            object is included if the extracted value is in the list
            </summary>
            <remarks>If there is no delegate installed or there are
            no values to match, no model objects will be matched</remarks>
        </member>
        <member name="M:Fluent.OneOfFilter.#ctor(Fluent.AspectGetterDelegate)">
            <summary>
            Create a filter that will use the given delegate to extract values
            </summary>
            <param name="valueGetter"></param>
        </member>
        <member name="M:Fluent.OneOfFilter.#ctor(Fluent.AspectGetterDelegate,System.Collections.ICollection)">
            <summary>
            Create a filter that will extract values using the given delegate
            and compare them to the values in the given list.
            </summary>
            <param name="valueGetter"></param>
            <param name="possibleValues"></param>
        </member>
        <member name="P:Fluent.OneOfFilter.ValueGetter">
            <summary>
            Gets or sets the delegate that will be used to extract values
            from model objects
            </summary>
        </member>
        <member name="P:Fluent.OneOfFilter.PossibleValues">
            <summary>
            Gets or sets the list of values that the value extracted from
            the model object must match in order to be included.
            </summary>
        </member>
        <member name="M:Fluent.OneOfFilter.Filter(System.Object)">
            <summary>
            Should the given model object be included?
            </summary>
            <param name="modelObject"></param>
            <returns></returns>
        </member>
        <member name="M:Fluent.OneOfFilter.DoesValueMatch(System.Object)">
            <summary>
            Decides if the given property is a match for the values in the PossibleValues collection
            </summary>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="T:Fluent.FlagBitSetFilter">
            <summary>
            Instances of this class match a property of a model objects against
            a list of bit flags. The property should be an xor-ed collection
            of bits flags.
            </summary>
            <remarks>Both the property compared and the list of possible values 
            must be convertible to ulongs.</remarks>
        </member>
        <member name="M:Fluent.FlagBitSetFilter.#ctor(Fluent.AspectGetterDelegate,System.Collections.ICollection)">
            <summary>
            Create an instance
            </summary>
            <param name="valueGetter"></param>
            <param name="possibleValues"></param>
        </member>
        <member name="P:Fluent.FlagBitSetFilter.PossibleValues">
            <summary>
            Gets or sets the collection of values that will be matched.
            These must be ulongs (or convertible to ulongs).
            </summary>
        </member>
        <member name="M:Fluent.FlagBitSetFilter.DoesValueMatch(System.Object)">
            <summary>
            Decides if the given property is a match for the values in the PossibleValues collection
            </summary>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="T:Fluent.AbstractListFilter">
            <summary>
            Base class for whole list filters
            </summary>
        </member>
        <member name="M:Fluent.AbstractListFilter.Filter(System.Collections.IEnumerable)">
            <summary>
            Return a subset of the given list of model objects as the new
            contents of the FluentListView
            </summary>
            <param name="modelObjects">The collection of model objects that the list will possibly display</param>
            <returns>The filtered collection that holds the model objects that will be displayed.</returns>
        </member>
        <member name="T:Fluent.ListFilter">
            <summary>
            Instance of this class implement delegate based whole list filtering
            </summary>
        </member>
        <member name="T:Fluent.ListFilter.ListFilterDelegate">
            <summary>
            A delegate that filters on a whole list
            </summary>
            <param name="rowObjects"></param>
            <returns></returns>
        </member>
        <member name="M:Fluent.ListFilter.#ctor(Fluent.ListFilter.ListFilterDelegate)">
            <summary>
            Create a ListFilter
            </summary>
            <param name="function"></param>
        </member>
        <member name="P:Fluent.ListFilter.Function">
            <summary>
            Gets or sets the delegate that will filter the list
            </summary>
        </member>
        <member name="M:Fluent.ListFilter.Filter(System.Collections.IEnumerable)">
            <summary>
            Do the actual work of filtering
            </summary>
            <param name="modelObjects"></param>
            <returns></returns>
        </member>
        <member name="T:Fluent.TailFilter">
            <summary>
            Filter the list so only the last N entries are displayed
            </summary>
        </member>
        <member name="M:Fluent.TailFilter.#ctor">
            <summary>
            Create a no-op tail filter
            </summary>
        </member>
        <member name="M:Fluent.TailFilter.#ctor(System.Int32)">
            <summary>
            Create a filter that includes on the last N model objects
            </summary>
            <param name="numberOfObjects"></param>
        </member>
        <member name="P:Fluent.TailFilter.Count">
            <summary>
            Gets or sets the number of model objects that will be 
            returned from the tail of the list
            </summary>
        </member>
        <member name="M:Fluent.TailFilter.Filter(System.Collections.IEnumerable)">
            <summary>
            Return the last N subset of the model objects
            </summary>
            <param name="modelObjects"></param>
            <returns></returns>
        </member>
        <member name="T:Fluent.FlagClusteringStrategy">
            <summary>
            Instances of this class cluster model objects on the basis of a
            property that holds an xor-ed collection of bit flags.
            </summary>
        </member>
        <member name="M:Fluent.FlagClusteringStrategy.#ctor(System.Type)">
            <summary>
            Create a clustering strategy that operates on the flags of the given enum
            </summary>
            <param name="enumType"></param>
        </member>
        <member name="M:Fluent.FlagClusteringStrategy.#ctor(System.Int64[],System.String[])">
            <summary>
            Create a clustering strategy around the given collections of flags and their display labels.
            There must be the same number of elements in both collections.
            </summary>
            <param name="values">The list of flags. </param>
            <param name="labels"></param>
        </member>
        <member name="P:Fluent.FlagClusteringStrategy.Values">
            <summary>
            Gets the value that will be xor-ed to test for the presence of a particular value.
            </summary>
        </member>
        <member name="P:Fluent.FlagClusteringStrategy.Labels">
            <summary>
            Gets the labels that will be used when the corresponding Value is XOR present in the data.
            </summary>
        </member>
        <member name="M:Fluent.FlagClusteringStrategy.GetClusterKey(System.Object)">
            <summary>
            Get the cluster key by which the given model will be partitioned by this strategy
            </summary>
            <param name="model"></param>
            <returns></returns>
        </member>
        <member name="M:Fluent.FlagClusteringStrategy.GetClusterDisplayLabel(Fluent.ICluster)">
            <summary>
            Gets the display label that the given cluster should use
            </summary>
            <param name="cluster"></param>
            <returns></returns>
        </member>
        <member name="M:Fluent.FlagClusteringStrategy.CreateFilter(System.Collections.IList)">
            <summary>
            Create a filter that will include only model objects that
            match one or more of the given values.
            </summary>
            <param name="valuesChosenForFiltering"></param>
            <returns></returns>
        </member>
        <member name="T:Fluent.ICluster">
            <summary>
            A cluster is a like collection of objects that can be usefully filtered
            as whole using the filtering UI provided by the FluentListView.
            </summary>
        </member>
        <member name="P:Fluent.ICluster.Count">
            <summary>
            Gets or sets how many items belong to this cluster
            </summary>
        </member>
        <member name="P:Fluent.ICluster.DisplayLabel">
            <summary>
            Gets or sets the label that will be shown to the user to represent
            this cluster
            </summary>
        </member>
        <member name="P:Fluent.ICluster.ClusterKey">
            <summary>
            Gets or sets the actual data object that all members of this cluster
            have commonly returned.
            </summary>
        </member>
        <member name="T:Fluent.IClusteringStrategy">
            <summary>
            Implementation of this interface control the selecting of cluster keys
            and how those clusters will be presented to the user
            </summary>
        </member>
        <member name="P:Fluent.IClusteringStrategy.Column">
            <summary>
            Gets or sets the column upon which this strategy will operate
            </summary>
        </member>
        <member name="M:Fluent.IClusteringStrategy.GetClusterKey(System.Object)">
            <summary>
            Get the cluster key by which the given model will be partitioned by this strategy
            </summary>
            <remarks>If the returned value is an IEnumerable, the given model is considered
            to belong to multiple clusters</remarks>
            <param name="model"></param>
            <returns></returns>
        </member>
        <member name="M:Fluent.IClusteringStrategy.CreateCluster(System.Object)">
            <summary>
            Create a cluster to hold the given cluster key
            </summary>
            <param name="clusterKey"></param>
            <returns></returns>
        </member>
        <member name="M:Fluent.IClusteringStrategy.GetClusterDisplayLabel(Fluent.ICluster)">
            <summary>
            Gets the display label that the given cluster should use
            </summary>
            <param name="cluster"></param>
            <returns></returns>
        </member>
        <member name="M:Fluent.IClusteringStrategy.CreateFilter(System.Collections.IList)">
            <summary>
            Create a filter that will include only model objects that
            match one or more of the given values.
            </summary>
            <param name="valuesChosenForFiltering"></param>
            <returns></returns>
        </member>
        <member name="T:Fluent.TextMatchFilter">
            <summary>
            Instances of this class include only those rows of the listview
            that match one or more given strings.
            </summary>
            <remarks>This class can match strings by prefix, regex, or simple containment.
            There are factory methods for each of these matching strategies.</remarks>
        </member>
        <member name="M:Fluent.TextMatchFilter.Regex(Fluent.Lists.AdvancedListView,System.String[])">
            <summary>
            Create a text filter that will include rows where any cell matches 
            any of the given regex expressions.
            </summary>
            <param name="olv"></param>
            <param name="texts"></param>
            <returns></returns>
            <remarks>Any string that is not a valid regex expression will be ignored.</remarks>
        </member>
        <member name="M:Fluent.TextMatchFilter.Prefix(Fluent.Lists.AdvancedListView,System.String[])">
            <summary>
            Create a text filter that includes rows where any cell begins with one of the given strings
            </summary>
            <param name="olv"></param>
            <param name="texts"></param>
            <returns></returns>
        </member>
        <member name="M:Fluent.TextMatchFilter.Contains(Fluent.Lists.AdvancedListView,System.String[])">
            <summary>
            Create a text filter that includes rows where any cell contains any of the given strings.
            </summary>
            <param name="olv"></param>
            <param name="texts"></param>
            <returns></returns>
        </member>
        <member name="M:Fluent.TextMatchFilter.#ctor(Fluent.Lists.AdvancedListView)">
            <summary>
            Create a TextFilter
            </summary>
            <param name="olv"></param>
        </member>
        <member name="M:Fluent.TextMatchFilter.#ctor(Fluent.Lists.AdvancedListView,System.String)">
            <summary>
            Create a TextFilter that finds the given string
            </summary>
            <param name="olv"></param>
            <param name="text"></param>
        </member>
        <member name="M:Fluent.TextMatchFilter.#ctor(Fluent.Lists.AdvancedListView,System.String,System.StringComparison)">
            <summary>
            Create a TextFilter that finds the given string using the given comparison
            </summary>
            <param name="olv"></param>
            <param name="text"></param>
            <param name="comparison"></param>
        </member>
        <member name="P:Fluent.TextMatchFilter.Columns">
            <summary>
            Gets or sets which columns will be used for the comparisons? If this is null, all columns will be used
            </summary>
        </member>
        <member name="P:Fluent.TextMatchFilter.AdditionalColumns">
            <summary>
            Gets or sets additional columns which will be used in the comparison. These will be used
            in addition to either the Columns property or to all columns taken from the control.
            </summary>
        </member>
        <member name="P:Fluent.TextMatchFilter.ContainsStrings">
            <summary>
            Gets or sets the collection of strings that will be used for 
            contains matching. Setting this replaces all previous texts
            of any kind.
            </summary>
        </member>
        <member name="P:Fluent.TextMatchFilter.HasComponents">
            <summary>
            Gets whether or not this filter has any search criteria
            </summary>
        </member>
        <member name="P:Fluent.TextMatchFilter.ListView">
            <summary>
            Gets or set the FluentListView upon which this filter will work
            </summary>
            <remarks>
            You cannot really rebase a filter after it is created, so do not change this value.
            It is included so that it can be set in an object initializer.
            </remarks>
        </member>
        <member name="P:Fluent.TextMatchFilter.PrefixStrings">
            <summary>
            Gets or sets the collection of strings that will be used for 
            prefix matching. Setting this replaces all previous texts
            of any kind.
            </summary>
        </member>
        <member name="P:Fluent.TextMatchFilter.RegexOptions">
            <summary>
            Gets or sets the options that will be used when compiling the regular expression.
            </summary>
            <remarks>
            This is only used when doing Regex matching (obviously).
            If this is not set specifically, the appropriate options are chosen to match the
            StringComparison setting (culture invariant, case sensitive).
            </remarks>
        </member>
        <member name="P:Fluent.TextMatchFilter.RegexStrings">
            <summary>
            Gets or sets the collection of strings that will be used for 
            regex pattern matching. Setting this replaces all previous texts
            of any kind.
            </summary>
        </member>
        <member name="P:Fluent.TextMatchFilter.StringComparison">
            <summary>
            Gets or  sets how the filter will match text
            </summary>
        </member>
        <member name="M:Fluent.TextMatchFilter.IterateColumns">
            <summary>
            Loop over the columns that are being considering by the filter
            </summary>
            <returns></returns>
        </member>
        <member name="M:Fluent.TextMatchFilter.Filter(System.Object)">
            <summary>
            Do the actual work of filtering
            </summary>
            <param name="modelObject"></param>
            <returns></returns>
        </member>
        <member name="M:Fluent.TextMatchFilter.FindAllMatchedRanges(System.String)">
            <summary>
            Find all the ways in which this filter matches the given string.
            </summary>
            <remarks>This is used by the renderer to decide which bits of
            the string should be highlighted</remarks>
            <param name="cellText"></param>
            <returns>A list of character ranges indicating the matched substrings</returns>
        </member>
        <member name="M:Fluent.TextMatchFilter.IsIncluded(Fluent.OLVColumn)">
            <summary>
            Is the given column one of the columns being used by this filter?
            </summary>
            <param name="column"></param>
            <returns></returns>
        </member>
        <member name="T:Fluent.TextMatchFilter.TextMatchingStrategy">
            <summary>
            Base class for the various types of string matching that TextMatchFilter provides
            </summary>
        </member>
        <member name="P:Fluent.TextMatchFilter.TextMatchingStrategy.StringComparison">
            <summary>
            Gets how the filter will match text
            </summary>
        </member>
        <member name="P:Fluent.TextMatchFilter.TextMatchingStrategy.TextFilter">
            <summary>
            Gets the text filter to which this component belongs
            </summary>
        </member>
        <member name="P:Fluent.TextMatchFilter.TextMatchingStrategy.Text">
            <summary>
            Gets or sets the text that will be matched
            </summary>
        </member>
        <member name="M:Fluent.TextMatchFilter.TextMatchingStrategy.FindAllMatchedRanges(System.String)">
            <summary>
            Find all the ways in which this filter matches the given string.
            </summary>
            <remarks>
            <para>
            This is used by the renderer to decide which bits of
            the string should be highlighted.
            </para>
            <para>this.Text will not be null or empty when this is called.</para>
            </remarks>
            <param name="cellText">The text of the cell we want to search</param>
            <returns>A list of character ranges indicating the matched substrings</returns>
        </member>
        <member name="M:Fluent.TextMatchFilter.TextMatchingStrategy.MatchesText(System.String)">
            <summary>
            Does the given text match the filter
            </summary>
            <remarks>
            <para>this.Text will not be null or empty when this is called.</para>
            </remarks>
            <param name="cellText">The text of the cell we want to search</param>
            <returns>Return true if the given cellText matches our strategy</returns>
        </member>
        <member name="T:Fluent.TextMatchFilter.TextContainsMatchingStrategy">
            <summary>
            This component provides text contains matching strategy.
            </summary>
        </member>
        <member name="M:Fluent.TextMatchFilter.TextContainsMatchingStrategy.#ctor(Fluent.TextMatchFilter,System.String)">
            <summary>
            Create a text contains strategy
            </summary>
            <param name="filter"></param>
            <param name="text"></param>
        </member>
        <member name="M:Fluent.TextMatchFilter.TextContainsMatchingStrategy.MatchesText(System.String)">
            <summary>
            Does the given text match the filter
            </summary>
            <remarks>
            <para>this.Text will not be null or empty when this is called.</para>
            </remarks>
            <param name="cellText">The text of the cell we want to search</param>
            <returns>Return true if the given cellText matches our strategy</returns>
        </member>
        <member name="M:Fluent.TextMatchFilter.TextContainsMatchingStrategy.FindAllMatchedRanges(System.String)">
            <summary>
            Find all the ways in which this filter matches the given string.
            </summary>
            <remarks>
            <para>
            This is used by the renderer to decide which bits of
            the string should be highlighted.
            </para>
            <para>this.Text will not be null or empty when this is called.</para>
            </remarks>
            <param name="cellText">The text of the cell we want to search</param>
            <returns>A list of character ranges indicating the matched substrings</returns>
        </member>
        <member name="T:Fluent.TextMatchFilter.TextBeginsMatchingStrategy">
            <summary>
            This component provides text begins with matching strategy.
            </summary>
        </member>
        <member name="M:Fluent.TextMatchFilter.TextBeginsMatchingStrategy.#ctor(Fluent.TextMatchFilter,System.String)">
            <summary>
            Create a text begins strategy
            </summary>
            <param name="filter"></param>
            <param name="text"></param>
        </member>
        <member name="M:Fluent.TextMatchFilter.TextBeginsMatchingStrategy.MatchesText(System.String)">
            <summary>
            Does the given text match the filter
            </summary>
            <remarks>
            <para>this.Text will not be null or empty when this is called.</para>
            </remarks>
            <param name="cellText">The text of the cell we want to search</param>
            <returns>Return true if the given cellText matches our strategy</returns>
        </member>
        <member name="M:Fluent.TextMatchFilter.TextBeginsMatchingStrategy.FindAllMatchedRanges(System.String)">
            <summary>
            Find all the ways in which this filter matches the given string.
            </summary>
            <remarks>
            <para>
            This is used by the renderer to decide which bits of
            the string should be highlighted.
            </para>
            <para>this.Text will not be null or empty when this is called.</para>
            </remarks>
            <param name="cellText">The text of the cell we want to search</param>
            <returns>A list of character ranges indicating the matched substrings</returns>
        </member>
        <member name="T:Fluent.TextMatchFilter.TextRegexMatchingStrategy">
            <summary>
            This component provides regex matching strategy.
            </summary>
        </member>
        <member name="M:Fluent.TextMatchFilter.TextRegexMatchingStrategy.#ctor(Fluent.TextMatchFilter,System.String)">
            <summary>
            Creates a regex strategy
            </summary>
            <param name="filter"></param>
            <param name="text"></param>
        </member>
        <member name="P:Fluent.TextMatchFilter.TextRegexMatchingStrategy.RegexOptions">
            <summary>
            Gets or sets the options that will be used when compiling the regular expression.
            </summary>
        </member>
        <member name="P:Fluent.TextMatchFilter.TextRegexMatchingStrategy.Regex">
            <summary>
            Gets or sets a compilex regular expression, based on our current Text and RegexOptions.
            </summary>
            <remarks>
            If Text fails to compile as a regular expression, this will return a Regex object
            that will match all strings.
            </remarks>
        </member>
        <member name="P:Fluent.TextMatchFilter.TextRegexMatchingStrategy.IsRegexInvalid">
            <summary>
            Gets whether or not our current regular expression is a valid regex
            </summary>
        </member>
        <member name="M:Fluent.TextMatchFilter.TextRegexMatchingStrategy.MatchesText(System.String)">
            <summary>
            Does the given text match the filter
            </summary>
            <remarks>
            <para>this.Text will not be null or empty when this is called.</para>
            </remarks>
            <param name="cellText">The text of the cell we want to search</param>
            <returns>Return true if the given cellText matches our strategy</returns>
        </member>
        <member name="M:Fluent.TextMatchFilter.TextRegexMatchingStrategy.FindAllMatchedRanges(System.String)">
            <summary>
            Find all the ways in which this filter matches the given string.
            </summary>
            <remarks>
            <para>
            This is used by the renderer to decide which bits of
            the string should be highlighted.
            </para>
            <para>this.Text will not be null or empty when this is called.</para>
            </remarks>
            <param name="cellText">The text of the cell we want to search</param>
            <returns>A list of character ranges indicating the matched substrings</returns>
        </member>
        <member name="T:Fluent.FluentListView">
            <summary>
            FluentListView is a C# wrapper around a .NET ListView, supporting model-bound lists,
            in-place item editing, drag and drop, icons, themes, trees &amp; data grids, and much more.
            
            If required, an AdvancedListView is created internally, otherwise a lightweight FastListView is created.
            </summary>
        </member>
        <member name="P:Fluent.FluentListView.Items">
            <summary>
            The items that are bound to this list. You only need to set this once.
            When adding and removing items, please call AddItem and RemoveItem instead of modifying this list directly.
            </summary>
        </member>
        <member name="P:Fluent.FluentListView.Properties">
            <summary>
            You need to set these to configure which properties of your objects display as the Name, Icon and Description.
            You can optionally add a list of Columns, to have those properties show as additional columns in the list.
            </summary>
        </member>
        <member name="F:Fluent.FluentListView.OnItemSelected">
            <summary>
            This callback will be fired when the selection changes.
            </summary>
        </member>
        <member name="F:Fluent.FluentListView.OnItemClick">
            <summary>
            This callback will be fired an item is clicked with the mouse.
            </summary>
        </member>
        <member name="F:Fluent.FluentListView.OnItemDoubleClick">
            <summary>
            This callback will be fired an item is double-clicked with the mouse.
            </summary>
        </member>
        <member name="P:Fluent.FluentListView.EnableDragDropItems">
            <summary>
            Whether the list will use a SimpleDragSource to initiate drags.
            </summary>
        </member>
        <member name="P:Fluent.FluentListView.EnableDrop">
            <summary>
            Whether the list will use a SimpleDropSink to accept dropping items from other sources.
            </summary>
        </member>
        <member name="P:Fluent.FluentListView.EnableDropFiles">
            <summary>
            Whether the list will accept dropping of files from Explorer.
            </summary>
        </member>
        <member name="P:Fluent.FluentListView.Theme">
            <summary>
            Which visual theme to use to render items.
            </summary>
        </member>
        <member name="P:Fluent.FluentListView.ItemFont">
            <summary>
            The font used to display list items. Affects row height.
            </summary>
        </member>
        <member name="P:Fluent.FluentListView.ColumnWidth">
            <summary>
            The width of additional columns.
            </summary>
        </member>
        <member name="F:Fluent.FluentListView.OnCanDrop">
            <summary>
            You need to set this if you are using EnableDragDropItems or EnableDrop, but not if you are using EnableDropFiles.
            </summary>
        </member>
        <member name="F:Fluent.FluentListView.OnDropped">
            <summary>
            You need to set this if you are using EnableDragDropItems or EnableDrop, but not if you are using EnableDropFiles.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "F:Fluent.FluentListView.OnDroppedFiles" -->
        <member name="F:Fluent.FluentListView.EnableDropOnLocations">
            <summary>
            You need to set this if you are using drag or drag-drop.
            </summary>
        </member>
        <member name="P:Fluent.FluentListView.ShowIcons">
            <summary>
            WIP. Will show an icon near the name.
            </summary>
        </member>
        <member name="P:Fluent.FluentListView.ShowDescription">
            <summary>
            WIP. Will show a description line below the name.
            </summary>
        </member>
        <member name="P:Fluent.FluentListView.ShowColumns">
            <summary>
            Used to control if additional columns are displayed based on Properties.Columns.
            </summary>
        </member>
        <member name="P:Fluent.FluentListView.ShowGroups">
            <summary>
            WIP. Will group up the items on a given property.
            </summary>
        </member>
        <member name="P:Fluent.FluentListView.EnableGifs">
            <summary>
            WIP. Only used to select between AdvancedListView and FastListView.
            </summary>
        </member>
        <member name="P:Fluent.FluentListView.EnableTileView">
            <summary>
            WIP. Only used to select between AdvancedListView and FastListView.
            </summary>
        </member>
        <member name="P:Fluent.FluentListView.EnableRenaming">
            <summary>
            WIP. Only used to select between AdvancedListView and FastListView.
            </summary>
        </member>
        <member name="P:Fluent.FluentListView.EnableCellEditing">
            <summary>
            WIP. Only used to select between AdvancedListView and FastListView.
            </summary>
        </member>
        <member name="P:Fluent.FluentListView.InnerList">
            <summary>
            Gets the underlying AdvancedListView or FastListView UI control.
            </summary>
        </member>
        <member name="P:Fluent.FluentListView.SelectedItem">
            <summary>
            Gets or sets the selected item.
            </summary>
        </member>
        <member name="P:Fluent.FluentListView.SelectedItems">
            <summary>
            Gets or sets the selected items.
            </summary>
        </member>
        <member name="M:Fluent.FluentListView.Redraw">
            <summary>
            Displays the items as a list. Call this when the items have been added/removed to force-redraw.
            </summary>
        </member>
        <member name="M:Fluent.FluentListView.RedrawValues">
            <summary>
            Call this when the item column values have changed, and you want to simply update the view.
            </summary>
        </member>
        <member name="M:Fluent.FluentListView.AddItem(System.Object)">
            <summary>
            Quickly adds an item to the list.
            </summary>
        </member>
        <member name="M:Fluent.FluentListView.RemoveItem(System.Object)">
            <summary>
            Quickly removes an item from the list.
            </summary>
        </member>
        <member name="M:Fluent.FluentListView.RemoveItems(System.Collections.IList)">
            <summary>
            Quickly removes multiple items from the list.
            </summary>
        </member>
        <member name="M:Fluent.FluentListView.GetDroppedFiles(Fluent.OlvDropEventArgs)">
            <summary>
            Returns an array of file paths, when given an argument object recieved by the OnCanDrop and OnDropped events.
            </summary>
            <param name="args"></param>
            <returns></returns>
        </member>
        <member name="F:Fluent.OLVTheme.XP">
            <summary>
            This will style your list like the old Windows XP theme.
            </summary>
        </member>
        <member name="F:Fluent.OLVTheme.Vista">
            <summary>
            This will give a selection and hot item mechanism that is similar to that used by Vista. It is not the same, I know. Do not complain.
            </summary>
        </member>
        <member name="F:Fluent.OLVTheme.VistaExplorer">
            <summary>
            If you absolutely have to look like Vista, this is your property. But it only works on Windows Vista and later, and does not work well with AlternateRowBackColors or HotItemStyles.
            </summary>
        </member>
        <member name="T:Fluent.Design.FluentListViewDesigner">
            <summary>
            Designer for <see cref="T:Fluent.Lists.AdvancedListView"/> and its subclasses.
            </summary>
            <remarks>
            <para>
            This designer removes properties and events that are available on ListView but that are not
            useful on FluentListView.
            </para>
            <para>
            We can't inherit from System.Windows.Forms.Design.ListViewDesigner, since it is marked internal.
            So, this class uses reflection to create a ListViewDesigner and then forwards messages to that designer.
            </para>
            </remarks>
        </member>
        <member name="M:Fluent.Design.FluentListViewDesigner.Initialize(System.ComponentModel.IComponent)">
            <summary>
            Initializes the designer with the specified component.
            </summary>
            <param name="component">The <see cref="T:System.ComponentModel.IComponent"/> to associate the designer with. This component must always be an instance of, or derive from, <see cref="T:System.Windows.Forms.Control"/>. </param>
        </member>
        <member name="M:Fluent.Design.FluentListViewDesigner.InitializeNewComponent(System.Collections.IDictionary)">
            <summary>
            Initializes a newly created component.
            </summary>
            <param name="defaultValues">A name/value dictionary of default values to apply to properties. May be null if no default values are specified.</param>
        </member>
        <member name="M:Fluent.Design.FluentListViewDesigner.Dispose(System.Boolean)">
            <summary>
            Releases the unmanaged resources used by the <see cref="T:System.Windows.Forms.Design.ControlDesigner"/> and optionally releases the managed resources.
            </summary>
            <param name="disposing">true to release both managed and unmanaged resources; false to release only unmanaged resources. </param>
        </member>
        <member name="M:Fluent.Design.FluentListViewDesigner.RemoveDuplicateDockingActionList">
            <summary>
            Removes the duplicate DockingActionList added by this designer to the <see cref="T:System.ComponentModel.Design.DesignerActionService"/>.
            </summary>
            <remarks>
            <see cref="M:System.Windows.Forms.Design.ControlDesigner.Initialize(System.ComponentModel.IComponent)"/> adds an internal DockingActionList : 'Dock/Undock in Parent Container'.
            But the default designer has already added that action list. So we need to remove one.
            </remarks>
        </member>
        <member name="M:Fluent.Design.FluentListViewDesigner.PreFilterProperties(System.Collections.IDictionary)">
            <summary>
            Adjusts the set of properties the component exposes through a <see cref="T:System.ComponentModel.TypeDescriptor"/>.
            </summary>
            <param name="properties">An <see cref="T:System.Collections.IDictionary"/> containing the properties for the class of the component. </param>
        </member>
        <member name="M:Fluent.Design.FluentListViewDesigner.PreFilterEvents(System.Collections.IDictionary)">
            <summary>
            Allows a designer to add to the set of events that it exposes through a <see cref="T:System.ComponentModel.TypeDescriptor"/>.
            </summary>
            <param name="events">The events for the class of the component. </param>
        </member>
        <member name="M:Fluent.Design.FluentListViewDesigner.PostFilterAttributes(System.Collections.IDictionary)">
            <summary>
            Allows a designer to change or remove items from the set of attributes that it exposes through a <see cref="T:System.ComponentModel.TypeDescriptor"/>.
            </summary>
            <param name="attributes">The attributes for the class of the component. </param>
        </member>
        <member name="M:Fluent.Design.FluentListViewDesigner.PostFilterEvents(System.Collections.IDictionary)">
            <summary>
            Allows a designer to change or remove items from the set of events that it exposes through a <see cref="T:System.ComponentModel.TypeDescriptor"/>.
            </summary>
            <param name="events">The events for the class of the component. </param>
        </member>
        <member name="P:Fluent.Design.FluentListViewDesigner.ActionLists">
            <summary>
            Gets the design-time action lists supported by the component associated with the designer.
            </summary>
            <returns>
            The design-time action lists supported by the component associated with the designer.
            </returns>
        </member>
        <member name="P:Fluent.Design.FluentListViewDesigner.AssociatedComponents">
            <summary>
            Gets the collection of components associated with the component managed by the designer.
            </summary>
            <returns>
            The components that are associated with the component managed by the designer.
            </returns>
        </member>
        <member name="M:Fluent.Design.FluentListViewDesigner.GetHitTest(System.Drawing.Point)">
            <summary>
            Indicates whether a mouse click at the specified point should be handled by the control.
            </summary>
            <returns>
            true if a click at the specified point is to be handled by the control; otherwise, false.
            </returns>
            <param name="point">A <see cref="T:System.Drawing.Point"/> indicating the position at which the mouse was clicked, in screen coordinates. </param>
        </member>
        <member name="M:Fluent.Design.FluentListViewDesigner.WndProc(System.Windows.Forms.Message@)">
            <summary>
            Processes Windows messages and optionally routes them to the control.
            </summary>
            <param name="m">The <see cref="T:System.Windows.Forms.Message"/> to process. </param>
        </member>
        <member name="T:Fluent.Design.FluentListViewDesigner.ListViewActionListAdapter">
            <summary>
            This class modifies a ListViewActionList, by removing the "Edit Items" and "Edit Groups" actions.
            </summary>
            <remarks>
            <para>
            That class is internal, so we cannot simply subclass it, which would be simplier.
            </para>
            <para>
            Action lists use reflection to determine if that action can be executed, so we not
            only have to modify the returned collection of actions, but we have to implement
            the properties and commands that the returned actions use. </para>
            </remarks>
        </member>
        <member name="T:Fluent.Design.OLVColumnCollectionEditor">
            <summary>
            This class works in conjunction with the OLVColumns property to allow OLVColumns
            to be added to the FluentListView.
            </summary>
        </member>
        <member name="M:Fluent.Design.OLVColumnCollectionEditor.#ctor(System.Type)">
            <summary>
            Create a OLVColumnCollectionEditor
            </summary>
            <param name="t"></param>
        </member>
        <member name="M:Fluent.Design.OLVColumnCollectionEditor.CreateCollectionItemType">
            <summary>
            What type of object does this editor create?
            </summary>
            <returns></returns>
        </member>
        <member name="M:Fluent.Design.OLVColumnCollectionEditor.EditValue(System.ComponentModel.ITypeDescriptorContext,System.IServiceProvider,System.Object)">
            <summary>
            Edit a given value
            </summary>
            <param name="context"></param>
            <param name="provider"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:Fluent.Design.OLVColumnCollectionEditor.GetDisplayText(System.Object)">
            <summary>
            What text should be shown in the list for the given object?
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="T:Fluent.Design.OverlayConverter">
            <summary>
            Control how the overlay is presented in the IDE
            </summary>
        </member>
        <member name="T:Fluent.OLVColumnAttribute">
            <summary>
            This attribute is used to mark a property of a model
            class that should be noticed by Generator class.
            </summary>
            <remarks>
            All the attributes of this class match their equivilent properties on OLVColumn.
            </remarks>
        </member>
        <member name="M:Fluent.OLVColumnAttribute.#ctor">
            <summary>
            Create a new OLVColumnAttribute
            </summary>
        </member>
        <member name="M:Fluent.OLVColumnAttribute.#ctor(System.String)">
            <summary>
            Create a new OLVColumnAttribute with the given title
            </summary>
            <param name="title">The title of the column</param>
        </member>
        <member name="P:Fluent.OLVColumnAttribute.AspectToStringFormat">
            <summary>
            
            </summary>
        </member>
        <member name="P:Fluent.OLVColumnAttribute.CheckBoxes">
            <summary>
            
            </summary>
        </member>
        <member name="P:Fluent.OLVColumnAttribute.DisplayIndex">
            <summary>
            
            </summary>
        </member>
        <member name="P:Fluent.OLVColumnAttribute.FillsFreeSpace">
            <summary>
            
            </summary>
        </member>
        <member name="P:Fluent.OLVColumnAttribute.FreeSpaceProportion">
            <summary>
            
            </summary>
        </member>
        <member name="P:Fluent.OLVColumnAttribute.GroupCutoffs">
            <summary>
            An array of IComparables that mark the cutoff points for values when
            grouping on this column. 
            </summary>
        </member>
        <member name="P:Fluent.OLVColumnAttribute.GroupDescriptions">
            <summary>
            
            </summary>
        </member>
        <member name="P:Fluent.OLVColumnAttribute.GroupWithItemCountFormat">
            <summary>
            
            </summary>
        </member>
        <member name="P:Fluent.OLVColumnAttribute.GroupWithItemCountSingularFormat">
            <summary>
            
            </summary>
        </member>
        <member name="P:Fluent.OLVColumnAttribute.Hyperlink">
            <summary>
            
            </summary>
        </member>
        <member name="P:Fluent.OLVColumnAttribute.ImageAspectName">
            <summary>
            
            </summary>
        </member>
        <member name="P:Fluent.OLVColumnAttribute.IsEditable">
            <summary>
            
            </summary>
        </member>
        <member name="P:Fluent.OLVColumnAttribute.IsVisible">
            <summary>
            
            </summary>
        </member>
        <member name="P:Fluent.OLVColumnAttribute.IsTileViewColumn">
            <summary>
            
            </summary>
        </member>
        <member name="P:Fluent.OLVColumnAttribute.MaximumWidth">
            <summary>
            
            </summary>
        </member>
        <member name="P:Fluent.OLVColumnAttribute.MinimumWidth">
            <summary>
            
            </summary>
        </member>
        <member name="P:Fluent.OLVColumnAttribute.Name">
            <summary>
            
            </summary>
        </member>
        <member name="P:Fluent.OLVColumnAttribute.TextAlign">
            <summary>
            
            </summary>
        </member>
        <member name="P:Fluent.OLVColumnAttribute.Tag">
            <summary>
            
            </summary>
        </member>
        <member name="P:Fluent.OLVColumnAttribute.Title">
            <summary>
            
            </summary>
        </member>
        <member name="P:Fluent.OLVColumnAttribute.ToolTipText">
            <summary>
            
            </summary>
        </member>
        <member name="P:Fluent.OLVColumnAttribute.TriStateCheckBoxes">
            <summary>
            
            </summary>
        </member>
        <member name="P:Fluent.OLVColumnAttribute.UseInitialLetterForGroup">
            <summary>
            
            </summary>
        </member>
        <member name="P:Fluent.OLVColumnAttribute.Width">
            <summary>
            
            </summary>
        </member>
        <member name="T:Fluent.OLVChildrenAttribute">
            <summary>
            Properties marked with [OLVChildren] will be used as the children source in a TreeListView.
            </summary>
        </member>
        <member name="T:Fluent.OLVIgnoreAttribute">
            <summary>
            Properties marked with [OLVIgnore] will not have columns generated for them.
            </summary>
        </member>
        <member name="T:Fluent.ColumnComparer">
            <summary>
            ColumnComparer is the workhorse for all comparison between two values of a particular column.
            If the column has a specific comparer, use that to compare the values. Otherwise, do
            a case insensitive string compare of the string representations of the values.
            </summary>
            <remarks><para>This class inherits from both IComparer and its generic counterpart
            so that it can be used on untyped and typed collections.</para>
            <para>This is used by normal (non-virtual) FluentListViews. Virtual lists use
            ModelObjectComparer</para>
            </remarks>
        </member>
        <member name="P:Fluent.ColumnComparer.StringComparer">
            <summary>
            Gets or sets the method that will be used to compare two strings.
            The default is to compare on the current culture, case-insensitive
            </summary>
        </member>
        <member name="M:Fluent.ColumnComparer.#ctor(Fluent.OLVColumn,System.Windows.Forms.SortOrder)">
            <summary>
            Create a ColumnComparer that will order the rows in a list view according
            to the values in a given column
            </summary>
            <param name="col">The column whose values will be compared</param>
            <param name="order">The ordering for column values</param>
        </member>
        <member name="M:Fluent.ColumnComparer.#ctor(Fluent.OLVColumn,System.Windows.Forms.SortOrder,Fluent.OLVColumn,System.Windows.Forms.SortOrder)">
            <summary>
            Create a ColumnComparer that will order the rows in a list view according
            to the values in a given column, and by a secondary column if the primary
            column is equal.
            </summary>
            <param name="col">The column whose values will be compared</param>
            <param name="order">The ordering for column values</param>
            <param name="col2">The column whose values will be compared for secondary sorting</param>
            <param name="order2">The ordering for secondary column values</param>
        </member>
        <member name="M:Fluent.ColumnComparer.Compare(System.Object,System.Object)">
            <summary>
            Compare two rows
            </summary>
            <param name="x">row1</param>
            <param name="y">row2</param>
            <returns>An ordering indication: -1, 0, 1</returns>
        </member>
        <member name="M:Fluent.ColumnComparer.Compare(Fluent.OLVListItem,Fluent.OLVListItem)">
            <summary>
            Compare two rows
            </summary>
            <param name="x">row1</param>
            <param name="y">row2</param>
            <returns>An ordering indication: -1, 0, 1</returns>
        </member>
        <member name="M:Fluent.ColumnComparer.CompareValues(System.Object,System.Object)">
            <summary>
            Compare the actual values to be used for sorting
            </summary>
            <param name="x">The aspect extracted from the first row</param>
            <param name="y">The aspect extracted from the second row</param>
            <returns>An ordering indication: -1, 0, 1</returns>
        </member>
        <member name="T:Fluent.OLVGroupComparer">
            <summary>
            This comparer sort list view groups. OLVGroups have a "SortValue" property,
            which is used if present. Otherwise, the titles of the groups will be compared.
            </summary>
        </member>
        <member name="M:Fluent.OLVGroupComparer.#ctor(System.Windows.Forms.SortOrder)">
            <summary>
            Create a group comparer
            </summary>
            <param name="order">The ordering for column values</param>
        </member>
        <member name="M:Fluent.OLVGroupComparer.Compare(Fluent.OLVGroup,Fluent.OLVGroup)">
            <summary>
            Compare the two groups. OLVGroups have a "SortValue" property,
            which is used if present. Otherwise, the titles of the groups will be compared.
            </summary>
            <param name="x">group1</param>
            <param name="y">group2</param>
            <returns>An ordering indication: -1, 0, 1</returns>
        </member>
        <member name="T:Fluent.ModelObjectComparer">
            <summary>
            This comparer can be used to sort a collection of model objects by a given column
            </summary>
            <remarks>
            <para>This is used by virtual FluentListViews. Non-virtual lists use
            ColumnComparer</para>
            </remarks>
        </member>
        <member name="P:Fluent.ModelObjectComparer.StringComparer">
            <summary>
            Gets or sets the method that will be used to compare two strings.
            The default is to compare on the current culture, case-insensitive
            </summary>
        </member>
        <member name="M:Fluent.ModelObjectComparer.#ctor(Fluent.OLVColumn,System.Windows.Forms.SortOrder)">
            <summary>
            Create a model object comparer
            </summary>
            <param name="col"></param>
            <param name="order"></param>
        </member>
        <member name="M:Fluent.ModelObjectComparer.#ctor(Fluent.OLVColumn,System.Windows.Forms.SortOrder,Fluent.OLVColumn,System.Windows.Forms.SortOrder)">
            <summary>
            Create a model object comparer with a secondary sorting column
            </summary>
            <param name="col"></param>
            <param name="order"></param>
            <param name="col2"></param>
            <param name="order2"></param>
        </member>
        <member name="M:Fluent.ModelObjectComparer.Compare(System.Object,System.Object)">
            <summary>
            Compare the two model objects
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <returns></returns>
        </member>
        <member name="M:Fluent.ModelObjectComparer.CompareValues(System.Object,System.Object)">
            <summary>
            Compare the actual values
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <returns></returns>
        </member>
        <member name="T:Fluent.DataSourceAdapter">
            <summary>
            A helper class that translates DataSource events for an FluentListView
            </summary>
        </member>
        <member name="M:Fluent.DataSourceAdapter.#ctor(Fluent.Lists.AdvancedListView)">
            <summary>
            Make a DataSourceAdapter
            </summary>
        </member>
        <member name="M:Fluent.DataSourceAdapter.Finalize">
            <summary>
            Finalize this object
            </summary>
        </member>
        <member name="M:Fluent.DataSourceAdapter.Dispose">
            <summary>
            Release all the resources used by this instance
            </summary>
        </member>
        <member name="M:Fluent.DataSourceAdapter.Dispose(System.Boolean)">
            <summary>
            Release all the resources used by this instance
            </summary>
        </member>
        <member name="P:Fluent.DataSourceAdapter.AutoGenerateColumns">
            <summary>
            Gets or sets whether or not columns will be automatically generated to show the
            columns when the DataSource is set. 
            </summary>
            <remarks>This must be set before the DataSource is set. It has no effect afterwards.</remarks>
        </member>
        <member name="P:Fluent.DataSourceAdapter.DataSource">
            <summary>
            Get or set the DataSource that will be displayed in this list view.
            </summary>
        </member>
        <member name="P:Fluent.DataSourceAdapter.DataMember">
            <summary>
            Gets or sets the name of the list or table in the data source for which the DataListView is displaying data.
            </summary>
            <remarks>If the data source is not a DataSet or DataViewManager, this property has no effect</remarks>
        </member>
        <member name="P:Fluent.DataSourceAdapter.ListView">
            <summary>
            Gets the FluentListView upon which this adaptor will operate
            </summary>
        </member>
        <member name="P:Fluent.DataSourceAdapter.CurrencyManager">
            <summary>
            Gets or sets the currency manager which is handling our binding context
            </summary>
        </member>
        <member name="M:Fluent.DataSourceAdapter.BindListView(Fluent.Lists.AdvancedListView)">
            <summary>
            
            </summary>
            <param name="olv"></param>
        </member>
        <member name="M:Fluent.DataSourceAdapter.UnbindListView(Fluent.Lists.AdvancedListView)">
            <summary>
            
            </summary>
            <param name="olv"></param>
        </member>
        <member name="M:Fluent.DataSourceAdapter.BindDataSource">
            <summary>
            
            </summary>
        </member>
        <member name="M:Fluent.DataSourceAdapter.UnbindDataSource">
            <summary>
            
            </summary>
        </member>
        <member name="M:Fluent.DataSourceAdapter.RebindDataSource">
            <summary>
            Our data source has changed. Figure out how to handle the new source
            </summary>
        </member>
        <member name="M:Fluent.DataSourceAdapter.RebindDataSource(System.Boolean)">
            <summary>
            Our data source has changed. Figure out how to handle the new source
            </summary>
        </member>
        <member name="M:Fluent.DataSourceAdapter.InitializeDataSource">
            <summary>
            The data source for this control has changed. Reconfigure the control for the new source
            </summary>
        </member>
        <member name="M:Fluent.DataSourceAdapter.SetListContents">
            <summary>
            Take the contents of the currently bound list and put them into the control
            </summary>
        </member>
        <member name="M:Fluent.DataSourceAdapter.CreateColumnsFromSource">
            <summary>
            Create columns for the listview based on what properties are available in the data source
            </summary>
            <remarks>
            <para>This method will create columns if there is not already a column displaying that property.</para>
            </remarks>
        </member>
        <member name="M:Fluent.DataSourceAdapter.ShouldCreateColumn(System.ComponentModel.PropertyDescriptor)">
            <summary>
            Decide if a new column should be added to the control to display
            the given property
            </summary>
            <param name="property"></param>
            <returns></returns>
        </member>
        <member name="M:Fluent.DataSourceAdapter.ConfigureColumn(Fluent.OLVColumn,System.ComponentModel.PropertyDescriptor)">
            <summary>
            Configure the given column to show the given property.
            The title and aspect name of the column are already filled in.
            </summary>
            <param name="column"></param>
            <param name="property"></param>
        </member>
        <member name="M:Fluent.DataSourceAdapter.CreateMissingAspectGettersAndPutters">
            <summary>
            Generate aspect getters and putters for any columns that are missing them (and for which we have
            enough information to actually generate a getter)
            </summary>
        </member>
        <member name="M:Fluent.DataSourceAdapter.CurrencyManagerListChanged(System.Object,System.ComponentModel.ListChangedEventArgs)">
            <summary>
            CurrencyManager ListChanged event handler.
            Deals with fine-grained changes to list items.
            </summary>
            <remarks>
            It's actually difficult to deal with these changes in a fine-grained manner.
            If our listview is grouped, then any change may make a new group appear or
            an old group disappear. It is rarely enough to simply update the affected row.
            </remarks>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="M:Fluent.DataSourceAdapter.HandleListChangedMetadataChanged(System.ComponentModel.ListChangedEventArgs)">
            <summary>
            Handle PropertyDescriptor* events
            </summary>
            <param name="e"></param>
        </member>
        <member name="M:Fluent.DataSourceAdapter.HandleListChangedItemMoved(System.ComponentModel.ListChangedEventArgs)">
            <summary>
            Handle ItemMoved event
            </summary>
            <param name="e"></param>
        </member>
        <member name="M:Fluent.DataSourceAdapter.HandleListChangedItemDeleted(System.ComponentModel.ListChangedEventArgs)">
            <summary>
            Handle the ItemDeleted event
            </summary>
            <param name="e"></param>
        </member>
        <member name="M:Fluent.DataSourceAdapter.HandleListChangedItemAdded(System.ComponentModel.ListChangedEventArgs)">
            <summary>
            Handle an ItemAdded event.
            </summary>
            <param name="e"></param>
        </member>
        <member name="M:Fluent.DataSourceAdapter.HandleListChangedReset(System.ComponentModel.ListChangedEventArgs)">
            <summary>
            Handle the Reset event
            </summary>
            <param name="e"></param>
        </member>
        <member name="M:Fluent.DataSourceAdapter.HandleListChangedItemChanged(System.ComponentModel.ListChangedEventArgs)">
            <summary>
            Handle ItemChanged event. This is triggered when a single item
            has changed, so just refresh that one item.
            </summary>
            <param name="e"></param>
            <remarks>Even in this simple case, we should probably rebuild the list.
            For example, the change could put the item into its own new group.</remarks>
        </member>
        <member name="M:Fluent.DataSourceAdapter.HandleCurrencyManagerMetaDataChanged(System.Object,System.EventArgs)">
            <summary>
            The CurrencyManager calls this if the data source looks
            different. We just reload everything.
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
            <remarks>
            CHECK: Do we need this if we are handle ListChanged metadata events?
            </remarks>
        </member>
        <member name="M:Fluent.DataSourceAdapter.HandleCurrencyManagerPositionChanged(System.Object,System.EventArgs)">
            <summary>
            Called by the CurrencyManager when the currently selected item
            changes. We update the ListView selection so that we stay in sync
            with any other controls bound to the same source.
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="M:Fluent.DataSourceAdapter.ChangePosition(System.Int32)">
            <summary>
            Change the control's position (which is it's currently selected row)
            to the nth row in the dataset
            </summary>
            <param name="index">The index of the row to be selected</param>
        </member>
        <member name="M:Fluent.DataSourceAdapter.HandleListViewSelectionChanged(System.Object,System.EventArgs)">
            <summary>
            Handle the selection changing in our ListView.
            We need to tell our currency manager about the new position.
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="M:Fluent.DataSourceAdapter.HandleListViewFreezing(System.Object,Fluent.FreezeEventArgs)">
            <summary>
            Handle the frozenness of our ListView changing. 
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="M:Fluent.DataSourceAdapter.HandleListViewBindingContextChanged(System.Object,System.EventArgs)">
            <summary>
            Handle a change to the BindingContext of our ListView.
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="T:Fluent.AspectGetterDelegate">
            <summary>
            These delegates are used to extract an aspect from a row object
            </summary>
        </member>
        <member name="T:Fluent.AspectPutterDelegate">
            <summary>
            These delegates are used to put a changed value back into a model object
            </summary>
        </member>
        <member name="T:Fluent.AspectToStringConverterDelegate">
            <summary>
            These delegates can be used to convert an aspect value to a display string,
            instead of using the default ToString()
            </summary>
        </member>
        <member name="T:Fluent.CellToolTipGetterDelegate">
            <summary>
            These delegates are used to get the tooltip for a cell
            </summary>
        </member>
        <member name="T:Fluent.CheckStateGetterDelegate">
            <summary>
            These delegates are used to the state of the checkbox for a row object.
            </summary>
            <remarks><para>
            For reasons known only to someone in Microsoft, we can only set
            a boolean on the ListViewItem to indicate it's "checked-ness", but when
            we receive update events, we have to use a tristate CheckState. So we can
            be told about an indeterminate state, but we can't set it ourselves.
            </para>
            <para>As of version 2.0, we can now return indeterminate state.</para>
            </remarks>
        </member>
        <member name="T:Fluent.BooleanCheckStateGetterDelegate">
            <summary>
            These delegates are used to get the state of the checkbox for a row object.
            </summary>
            <param name="rowObject"></param>
            <returns></returns>
        </member>
        <member name="T:Fluent.CheckStatePutterDelegate">
            <summary>
            These delegates are used to put a changed check state back into a model object
            </summary>
        </member>
        <member name="T:Fluent.BooleanCheckStatePutterDelegate">
            <summary>
            These delegates are used to put a changed check state back into a model object
            </summary>
            <param name="rowObject"></param>
            <param name="newValue"></param>
            <returns></returns>
        </member>
        <member name="T:Fluent.CellRendererGetterDelegate">
            <summary>
            These delegates are used to get the renderer for a particular cell
            </summary>
        </member>
        <member name="T:Fluent.ColumnRightClickEventHandler">
            <summary>
            The callbacks for RightColumnClick events
            </summary>
        </member>
        <member name="T:Fluent.HeaderDrawingDelegate">
            <summary>
            This delegate will be used to own draw header column.
            </summary>
        </member>
        <member name="T:Fluent.GroupFormatterDelegate">
            <summary>
            This delegate is called when a group has been created but not yet made
            into a real ListViewGroup. The user can take this opportunity to fill
            in lots of other details about the group.
            </summary>
        </member>
        <member name="T:Fluent.GroupKeyGetterDelegate">
            <summary>
            These delegates are used to retrieve the object that is the key of the group to which the given row belongs.
            </summary>
        </member>
        <member name="T:Fluent.GroupKeyToTitleConverterDelegate">
            <summary>
            These delegates are used to convert a group key into a title for the group
            </summary>
        </member>
        <member name="T:Fluent.HeaderToolTipGetterDelegate">
            <summary>
            These delegates are used to get the tooltip for a column header
            </summary>
        </member>
        <member name="T:Fluent.ImageGetterDelegate">
            <summary>
            These delegates are used to fetch the image selector that should be used
            to choose an image for this column.
            </summary>
        </member>
        <member name="T:Fluent.RenderDelegate">
            <summary>
            These delegates are used to draw a cell
            </summary>
        </member>
        <member name="T:Fluent.RowGetterDelegate">
            <summary>
            These delegates are used to fetch a row object for virtual lists
            </summary>
        </member>
        <member name="T:Fluent.RowFormatterDelegate">
            <summary>
            These delegates are used to format a listviewitem before it is added to the control.
            </summary>
        </member>
        <member name="T:Fluent.SearchValueGetterDelegate">
            <summary>
            These delegates can be used to return the array of texts that should be searched for text filtering
            </summary>
        </member>
        <member name="T:Fluent.SortDelegate">
            <summary>
            These delegates are used to sort the listview in some custom fashion
            </summary>
        </member>
        <member name="T:Fluent.StringCompareDelegate">
            <summary>
            These delegates are used to order two strings.
            x cannot be null. y can be null.
            </summary>
        </member>
        <member name="T:Fluent.Lists.AdvancedListView">
            <summary>
            An FluentListView is a much easier to use, and much more powerful, version of the ListView.
            </summary>
            <remarks>
            <para>
            An FluentListView automatically populates a ListView control with information taken 
            from a given collection of objects. It can do this because each column is configured
            to know which bit of the model object (the "aspect") it should be displaying. Columns similarly
            understand how to sort the list based on their aspect, and how to construct groups
            using their aspect.
            </para>
            <para>
            Aspects are extracted by giving the name of a method to be called or a
            property to be fetched. These names can be simple names or they can be dotted
            to chain property access e.g. "Owner.Address.Postcode".
            Aspects can also be extracted by installing a delegate.
            </para>
            <para>
            An FluentListView can show a "this list is empty" message when there is nothing to show in the list, 
            so that the user knows the control is supposed to be empty.
            </para>
            <para>
            Right clicking on a column header should present a menu which can contain:
            commands (sort, group, ungroup); filtering; and column selection. Whether these
            parts of the menu appear is controlled by ShowCommandMenuOnRightClick, 
            ShowFilterMenuOnRightClick and SelectColumnsOnRightClick respectively.
            </para>
            <para>
            The groups created by an FluentListView can be configured to include other formatting
            information, including a group icon, subtitle and task button. Using some undocumented
            interfaces, these groups can even on virtual lists.
            </para>
            <para>
            FluentListView supports dragging rows to other places, including other application. 
            Special support is provide for drops from other FluentListViews in the same application. 
            In many cases, an FluentListView becomes a full drag source by setting <see cref="P:Fluent.Lists.AdvancedListView.IsSimpleDragSource"/> to 
            true. Similarly, to accept drops, it is usually enough to set <see cref="P:Fluent.Lists.AdvancedListView.IsSimpleDropSink"/> to true, 
            and then handle the <see cref="E:Fluent.Lists.AdvancedListView.CanDrop"/>  and <see cref="E:Fluent.Lists.AdvancedListView.Dropped"/>  events (or the <see cref="E:Fluent.Lists.AdvancedListView.ModelCanDrop"/>  and 
            <see cref="E:Fluent.Lists.AdvancedListView.ModelDropped"/> events, if you only want to handle drops from other FluentListViews in your application).
            </para>
            <para>
            For these classes to build correctly, the project must have references to these assemblies:
            </para>
            <list type="bullet">
            <item><description>System</description></item>
            <item><description>System.Data</description></item>
            <item><description>System.Design</description></item>
            <item><description>System.Drawing</description></item>
            <item><description>System.Windows.Forms (obviously)</description></item>
            </list>
            </remarks>
        </member>
        <member name="T:Fluent.Lists.AdvancedListView.CellEditActivateMode">
            <summary>
            How does a user indicate that they want to edit cells?
            </summary>
        </member>
        <member name="F:Fluent.Lists.AdvancedListView.CellEditActivateMode.None">
            <summary>
            This list cannot be edited. F2 does nothing.
            </summary>
        </member>
        <member name="F:Fluent.Lists.AdvancedListView.CellEditActivateMode.SingleClick">
            <summary>
            A single click on  a <strong>subitem</strong> will edit the value. Single clicking the primary column,
            selects the row just like normal. The user must press F2 to edit the primary column.
            </summary>
        </member>
        <member name="F:Fluent.Lists.AdvancedListView.CellEditActivateMode.DoubleClick">
            <summary>
            Double clicking a subitem or the primary column will edit that cell.
            F2 will edit the primary column.
            </summary>
        </member>
        <member name="F:Fluent.Lists.AdvancedListView.CellEditActivateMode.F2Only">
            <summary>
            Pressing F2 is the only way to edit the cells. Once the primary column is being edited,
            the other cells in the row can be edited by pressing Tab.
            </summary>
        </member>
        <member name="F:Fluent.Lists.AdvancedListView.CellEditActivateMode.SingleClickAlways">
            <summary>
            A single click on  a <strong>any</strong> cell will edit the value, even the primary column.
            </summary>
        </member>
        <member name="E:Fluent.Lists.AdvancedListView.AfterSearching">
            <summary>
            Triggered after a FluentListView has been searched by the user typing into the list
            </summary>
        </member>
        <member name="E:Fluent.Lists.AdvancedListView.AfterSorting">
            <summary>
            Triggered after a FluentListView has been sorted
            </summary>
        </member>
        <member name="E:Fluent.Lists.AdvancedListView.BeforeSearching">
            <summary>
            Triggered before a FluentListView is searched by the user typing into the list
            </summary>
            <remarks>
            Set Cancelled to true to prevent the searching from taking place.
            Changing StringToFind or StartSearchFrom will change the subsequent search.
            </remarks>
        </member>
        <member name="E:Fluent.Lists.AdvancedListView.BeforeSorting">
            <summary>
            Triggered before a FluentListView is sorted
            </summary>
            <remarks>
            Set Cancelled to true to prevent the sort from taking place.
            Changing ColumnToSort or SortOrder will change the subsequent sort.
            </remarks>
        </member>
        <member name="E:Fluent.Lists.AdvancedListView.AfterCreatingGroups">
            <summary>
            Triggered after a FluentListView has created groups
            </summary>
        </member>
        <member name="E:Fluent.Lists.AdvancedListView.BeforeCreatingGroups">
            <summary>
            Triggered before a FluentListView begins to create groups
            </summary>
            <remarks>
            Set Groups to prevent the default group creation process
            </remarks>
        </member>
        <member name="E:Fluent.Lists.AdvancedListView.AboutToCreateGroups">
            <summary>
            Triggered just before a FluentListView creates groups
            </summary>
            <remarks>
            You can make changes to the groups, which have been created, before those
            groups are created within the listview.
            </remarks>
        </member>
        <member name="E:Fluent.Lists.AdvancedListView.ButtonClick">
            <summary>
            Triggered when a button in a cell is left clicked.
            </summary>
        </member>
        <member name="E:Fluent.Lists.AdvancedListView.CanDrop">
            <summary>
            This event is triggered when the user moves a drag over an FluentListView that
            has a SimpleDropSink installed as the drop handler.
            </summary>
            <remarks>
            Handlers for this event should set the Effect argument and optionally the
            InfoMsg property. They can also change any of the DropTarget* setttings to change
            the target of the drop.
            </remarks>
        </member>
        <member name="E:Fluent.Lists.AdvancedListView.CellEditFinished">
            <summary>
            Triggered when a cell has finished being edited.
            </summary>
        </member>
        <member name="E:Fluent.Lists.AdvancedListView.CellEditFinishing">
            <summary>
            Triggered when a cell is about to finish being edited.
            </summary>
            <remarks>If Cancel is already true, the user is cancelling the edit operation.
            Set Cancel to true to prevent the value from the cell being written into the model.
            You cannot prevent the editing from finishing within this event -- you need
            the CellEditValidating event for that.</remarks>
        </member>
        <member name="E:Fluent.Lists.AdvancedListView.CellEditStarting">
            <summary>
            Triggered when a cell is about to be edited.
            </summary>
            <remarks>Set Cancel to true to prevent the cell being edited.
            You can change the the Control to be something completely different.</remarks>
        </member>
        <member name="E:Fluent.Lists.AdvancedListView.CellEditValidating">
            <summary>
            Triggered when a cell editor needs to be validated
            </summary>
            <remarks>
            If this event is cancelled, focus will remain on the cell editor.
            </remarks>
        </member>
        <member name="E:Fluent.Lists.AdvancedListView.CellClick">
            <summary>
            Triggered when a cell is left clicked.
            </summary>
        </member>
        <member name="E:Fluent.Lists.AdvancedListView.CellOver">
            <summary>
            Triggered when the mouse is above a cell.
            </summary>
        </member>
        <member name="E:Fluent.Lists.AdvancedListView.CellRightClick">
            <summary>
            Triggered when a cell is right clicked.
            </summary>
        </member>
        <member name="E:Fluent.Lists.AdvancedListView.CellToolTipShowing">
            <summary>
            This event is triggered when a cell needs a tool tip.
            </summary>
        </member>
        <member name="E:Fluent.Lists.AdvancedListView.SubItemChecking">
            <summary>
            This event is triggered when a checkbox is checked/unchecked on a subitem
            </summary>
        </member>
        <member name="E:Fluent.Lists.AdvancedListView.ColumnRightClick">
            <summary>
            Triggered when a column header is right clicked.
            </summary>
        </member>
        <member name="E:Fluent.Lists.AdvancedListView.Dropped">
            <summary>
            This event is triggered when the user releases a drag over an FluentListView that
            has a SimpleDropSink installed as the drop handler.
            </summary>
        </member>
        <member name="E:Fluent.Lists.AdvancedListView.Filter">
            <summary>
            This event is triggered when the control needs to filter its collection of objects.
            </summary>
        </member>
        <member name="E:Fluent.Lists.AdvancedListView.FormatCell">
            <summary>
            This event is triggered when a cell needs to be formatted.
            </summary>
        </member>
        <member name="E:Fluent.Lists.AdvancedListView.Freezing">
            <summary>
            This event is triggered when the frozeness of the control changes.
            </summary>
        </member>
        <member name="E:Fluent.Lists.AdvancedListView.FormatRow">
            <summary>
            This event is triggered when a row needs to be formatted.
            </summary>
        </member>
        <member name="E:Fluent.Lists.AdvancedListView.GroupExpandingCollapsing">
            <summary>
            This event is triggered when a group is about to collapse or expand.
            This can be cancelled to prevent the expansion.
            </summary>
        </member>
        <member name="E:Fluent.Lists.AdvancedListView.GroupStateChanged">
            <summary>
            This event is triggered when a group changes state.
            </summary>
        </member>
        <member name="E:Fluent.Lists.AdvancedListView.HeaderCheckBoxChanging">
            <summary>
            This event is triggered when a header checkbox is changing value
            </summary>
        </member>
        <member name="E:Fluent.Lists.AdvancedListView.HeaderToolTipShowing">
            <summary>
            This event is triggered when a header needs a tool tip.
            </summary>
        </member>
        <member name="E:Fluent.Lists.AdvancedListView.HotItemChanged">
            <summary>
            Triggered when the "hot" item changes
            </summary>
        </member>
        <member name="E:Fluent.Lists.AdvancedListView.HyperlinkClicked">
            <summary>
            Triggered when a hyperlink cell is clicked.
            </summary>
        </member>
        <member name="E:Fluent.Lists.AdvancedListView.GroupTaskClicked">
            <summary>
            Triggered when the task text of a group is clicked.
            </summary>
        </member>
        <member name="E:Fluent.Lists.AdvancedListView.IsHyperlink">
            <summary>
            Is the value in the given cell a hyperlink.
            </summary>
        </member>
        <member name="E:Fluent.Lists.AdvancedListView.ItemsAdding">
            <summary>
            Some new objects are about to be added to an FluentListView.
            </summary>
        </member>
        <member name="E:Fluent.Lists.AdvancedListView.ItemsChanged">
            <summary>
            The contents of the FluentListView has changed.
            </summary>
        </member>
        <member name="E:Fluent.Lists.AdvancedListView.ItemsChanging">
            <summary>
            The contents of the FluentListView is about to change via a SetObjects call
            </summary>
            <remarks>
            <para>Set Cancelled to true to prevent the contents of the list changing. This does not work with virtual lists.</para>
            </remarks>
        </member>
        <member name="E:Fluent.Lists.AdvancedListView.ItemsRemoving">
            <summary>
            Some objects are about to be removed from an FluentListView.
            </summary>
        </member>
        <member name="E:Fluent.Lists.AdvancedListView.ModelCanDrop">
            <summary>
            This event is triggered when the user moves a drag over an FluentListView that
            has a SimpleDropSink installed as the drop handler, and when the source control
            for the drag was an FluentListView.
            </summary>
            <remarks>
            Handlers for this event should set the Effect argument and optionally the
            InfoMsg property. They can also change any of the DropTarget* setttings to change
            the target of the drop.
            </remarks>
        </member>
        <member name="E:Fluent.Lists.AdvancedListView.ModelDropped">
            <summary>
            This event is triggered when the user releases a drag over an FluentListView that
            has a SimpleDropSink installed as the drop handler and when the source control
            for the drag was an FluentListView.
            </summary>
        </member>
        <member name="E:Fluent.Lists.AdvancedListView.SelectionChanged">
            <summary>
            This event is triggered once per user action that changes the selection state
            of one or more rows.
            </summary>
        </member>
        <member name="E:Fluent.Lists.AdvancedListView.Scroll">
            <summary>
            This event is triggered when the contents of the FluentListView has scrolled.
            </summary>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.OnAboutToCreateGroups(Fluent.CreateGroupsEventArgs)">
            <summary>
            
            </summary>
            <param name="e"></param>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.OnBeforeCreatingGroups(Fluent.CreateGroupsEventArgs)">
            <summary>
            
            </summary>
            <param name="e"></param>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.OnAfterCreatingGroups(Fluent.CreateGroupsEventArgs)">
            <summary>
            
            </summary>
            <param name="e"></param>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.OnAfterSearching(Fluent.AfterSearchingEventArgs)">
            <summary>
            
            </summary>
            <param name="e"></param>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.OnAfterSorting(Fluent.AfterSortingEventArgs)">
            <summary>
            
            </summary>
            <param name="e"></param>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.OnBeforeSearching(Fluent.BeforeSearchingEventArgs)">
            <summary>
            
            </summary>
            <param name="e"></param>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.OnBeforeSorting(Fluent.BeforeSortingEventArgs)">
            <summary>
            
            </summary>
            <param name="e"></param>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.OnButtonClick(Fluent.CellClickEventArgs)">
            <summary>
            
            </summary>
            <param name="args"></param>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.OnCanDrop(Fluent.OlvDropEventArgs)">
            <summary>
            
            </summary>
            <param name="args"></param>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.OnCellClick(Fluent.CellClickEventArgs)">
            <summary>
            
            </summary>
            <param name="args"></param>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.OnCellOver(Fluent.CellOverEventArgs)">
            <summary>
            
            </summary>
            <param name="args"></param>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.OnCellRightClick(Fluent.CellRightClickEventArgs)">
            <summary>
            
            </summary>
            <param name="args"></param>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.OnCellToolTip(Fluent.ToolTipShowingEventArgs)">
            <summary>
            
            </summary>
            <param name="args"></param>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.OnSubItemChecking(Fluent.SubItemCheckingEventArgs)">
            <summary>
            
            </summary>
            <param name="args"></param>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.OnColumnRightClick(System.Windows.Forms.ColumnClickEventArgs)">
            <summary>
            
            </summary>
            <param name="e"></param>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.OnDropped(Fluent.OlvDropEventArgs)">
            <summary>
            
            </summary>
            <param name="args"></param>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.OnFilter(Fluent.FilterEventArgs)">
            <summary>
            
            </summary>
            <param name="e"></param>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.OnFormatCell(Fluent.FormatCellEventArgs)">
            <summary>
            
            </summary>
            <param name="args"></param>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.OnFormatRow(Fluent.FormatRowEventArgs)">
            <summary>
            
            </summary>
            <param name="args"></param>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.OnFreezing(Fluent.FreezeEventArgs)">
            <summary>
            
            </summary>
            <param name="args"></param>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.OnGroupExpandingCollapsing(Fluent.GroupExpandingCollapsingEventArgs)">
            <summary>
            
            </summary>
            <param name="args"></param>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.OnGroupStateChanged(Fluent.GroupStateChangedEventArgs)">
            <summary>
            
            </summary>
            <param name="args"></param>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.OnHeaderCheckBoxChanging(Fluent.HeaderCheckBoxChangingEventArgs)">
            <summary>
            
            </summary>
            <param name="args"></param>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.OnHeaderToolTip(Fluent.ToolTipShowingEventArgs)">
            <summary>
            
            </summary>
            <param name="args"></param>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.OnHotItemChanged(Fluent.HotItemChangedEventArgs)">
            <summary>
            
            </summary>
            <param name="e"></param>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.OnHyperlinkClicked(Fluent.HyperlinkClickedEventArgs)">
            <summary>
            
            </summary>
            <param name="e"></param>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.OnGroupTaskClicked(Fluent.GroupTaskClickedEventArgs)">
            <summary>
            
            </summary>
            <param name="e"></param>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.OnIsHyperlink(Fluent.IsHyperlinkEventArgs)">
            <summary>
            
            </summary>
            <param name="e"></param>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.OnItemsAdding(Fluent.ItemsAddingEventArgs)">
            <summary>
            
            </summary>
            <param name="e"></param>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.OnItemsChanged(Fluent.ItemsChangedEventArgs)">
            <summary>
            
            </summary>
            <param name="e"></param>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.OnItemsChanging(Fluent.ItemsChangingEventArgs)">
            <summary>
            
            </summary>
            <param name="e"></param>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.OnItemsRemoving(Fluent.ItemsRemovingEventArgs)">
            <summary>
            
            </summary>
            <param name="e"></param>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.OnModelCanDrop(Fluent.ModelDropEventArgs)">
            <summary>
            
            </summary>
            <param name="args"></param>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.OnModelDropped(Fluent.ModelDropEventArgs)">
            <summary>
            
            </summary>
            <param name="args"></param>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.OnSelectionChanged(System.EventArgs)">
            <summary>
            
            </summary>
            <param name="e"></param>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.OnScroll(System.Windows.Forms.ScrollEventArgs)">
            <summary>
            
            </summary>
            <param name="e"></param>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.OnCellEditStarting(Fluent.CellEditEventArgs)">
            <summary>
            Tell the world when a cell is about to be edited.
            </summary>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.OnCellEditorValidating(Fluent.CellEditEventArgs)">
            <summary>
            Tell the world when a cell is about to finish being edited.
            </summary>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.OnCellEditFinishing(Fluent.CellEditEventArgs)">
            <summary>
            Tell the world when a cell is about to finish being edited.
            </summary>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.OnCellEditFinished(Fluent.CellEditEventArgs)">
            <summary>
            Tell the world when a cell has finished being edited.
            </summary>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.#ctor">
            <summary>
            Create an FluentListView
            </summary>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.Dispose(System.Boolean)">
            <summary>
            Dispose of any resources this instance has been using
            </summary>
            <param name="disposing"></param>
        </member>
        <member name="P:Fluent.Lists.AdvancedListView.IsLeftMouseDown">
            <summary>
            Gets whether or not the left mouse button is down at this very instant
            </summary>
        </member>
        <member name="P:Fluent.Lists.AdvancedListView.IsVistaOrLater">
            <summary>
            Gets whether the program running on Vista or later?
            </summary>
        </member>
        <member name="P:Fluent.Lists.AdvancedListView.IsWin7OrLater">
            <summary>
            Gets whether the program running on Win7 or later?
            </summary>
        </member>
        <member name="P:Fluent.Lists.AdvancedListView.SmoothingMode">
            <summary>
            Gets or sets how what smoothing mode will be applied to graphic operations.
            </summary>
        </member>
        <member name="P:Fluent.Lists.AdvancedListView.TextRenderingHint">
            <summary>
            Gets or sets how should text be renderered.
            </summary>
        </member>
        <member name="P:Fluent.Lists.AdvancedListView.GroupTitleDefault">
            <summary>
            Gets or sets the string that will be used to title groups when the group key is null.
            Exposed so it can be localized.
            </summary>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.EnumerableToArray(System.Collections.IEnumerable,System.Boolean)">
            <summary>
            Convert the given enumerable into an ArrayList as efficiently as possible
            </summary>
            <param name="collection">The source collection</param>
            <param name="alwaysCreate">If true, this method will always create a new
            collection.</param>
            <returns>An ArrayList with the same contents as the given collection.</returns>
            <remarks>
            <para>When we move to .NET 3.5, we can use LINQ and not need this method.</para>
            </remarks>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.EnumerableCount(System.Collections.IEnumerable)">
            <summary>
            Return the count of items in the given enumerable
            </summary>
            <param name="collection"></param>
            <returns></returns>
            <remarks>When we move to .NET 3.5, we can use LINQ and not need this method.</remarks>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.IsEnumerableEmpty(System.Collections.IEnumerable)">
            <summary>
            Return whether or not the given enumerable is empty. A string is regarded as 
            an empty collection.
            </summary>
            <param name="collection"></param>
            <returns>True if the given collection is null or empty</returns>
            <remarks>
            <para>When we move to .NET 3.5, we can use LINQ and not need this method.</para>
            </remarks>
        </member>
        <member name="P:Fluent.Lists.AdvancedListView.IgnoreMissingAspects">
            <summary>
            Gets or sets whether all FluentListViews will silently ignore missing aspect errors.
            </summary>
            <remarks>
            <para>
            By default, if an FluentListView is asked to display an aspect
            (i.e. a field/property/method)
            that does not exist from a model, it displays an error message in that cell, since that 
            condition is normally a programming error. There are some use cases where
            this is not an error -- in those cases, set this to true and FluentListView will
            simply display an empty cell.
            </para>
            <para>Be warned: if you set this to true, it can be very difficult to track down
            typing mistakes or name changes in AspectNames.</para>
            </remarks>
        </member>
        <member name="P:Fluent.Lists.AdvancedListView.ShowCellPaddingBounds">
            <summary>
            Gets or sets whether the control will draw a rectangle in each cell showing the cell padding.
            </summary>
            <remarks>
            <para>
            This can help with debugging display problems from cell padding.
            </para>
            <para>As with all cell padding, this setting only takes effect when the control is owner drawn.</para>
            </remarks>
        </member>
        <member name="P:Fluent.Lists.AdvancedListView.DefaultDisabledItemStyle">
            <summary>
            Gets the style that will be used by default to format disabled rows
            </summary>
        </member>
        <member name="P:Fluent.Lists.AdvancedListView.DefaultHotItemStyle">
            <summary>
            Gets the style that will be used by default to format hot rows
            </summary>
        </member>
        <member name="P:Fluent.Lists.AdvancedListView.AdditionalFilter">
            <summary>
            Gets or sets an model filter that is combined with any column filtering that the end-user specifies.
            </summary>
            <remarks>This is different from the ModelFilter property, since setting that will replace
            any column filtering, whereas setting this will combine this filter with the column filtering</remarks>
        </member>
        <member name="P:Fluent.Lists.AdvancedListView.AllColumns">
            <summary>
            Get or set all the columns that this control knows about.
            Only those columns where IsVisible is true will be seen by the user.
            </summary>
            <remarks>
            <para>
            If you want to add new columns programmatically, add them to
            AllColumns and then call RebuildColumns(). Normally, you do not have to
            deal with this property directly. Just use the IDE.
            </para>
            <para>If you do add or remove columns from the AllColumns collection,
            you have to call RebuildColumns() to make those changes take effect.</para>
            </remarks>
        </member>
        <member name="P:Fluent.Lists.AdvancedListView.AlternateRowBackColor">
            <summary>
            Gets or sets the background color of every second row 
            </summary>
        </member>
        <member name="P:Fluent.Lists.AdvancedListView.AlternateRowBackColorOrDefault">
            <summary>
            Gets the alternate row background color that has been set, or the default color
            </summary>
        </member>
        <member name="P:Fluent.Lists.AdvancedListView.AlwaysGroupByColumn">
            <summary>
            This property forces the FluentListView to always group items by the given column.
            </summary>
        </member>
        <member name="P:Fluent.Lists.AdvancedListView.AlwaysGroupBySortOrder">
            <summary>
            If AlwaysGroupByColumn is not null, this property will be used to decide how
            those groups are sorted. If this property has the value SortOrder.None, then
            the sort order will toggle according to the users last header click.
            </summary>
        </member>
        <member name="P:Fluent.Lists.AdvancedListView.BaseSmallImageList">
            <summary>
            Give access to the image list that is actually being used by the control
            </summary>
            <remarks>
            Normally, it is preferable to use SmallImageList. Only use this property
            if you know exactly what you are doing.
            </remarks>
        </member>
        <member name="P:Fluent.Lists.AdvancedListView.CellEditActivation">
            <summary>
            How does the user indicate that they want to edit a cell?
            None means that the listview cannot be edited.
            </summary>
            <remarks>Columns can also be marked as editable.</remarks>
        </member>
        <member name="P:Fluent.Lists.AdvancedListView.CellEditUseWholeCell">
            <summary>
            When a cell is edited, should the whole cell be used (minus any space used by checkbox or image)?
            Defaults to true.
            </summary>
            <remarks>
            <para>This is always treated as true when the control is NOT owner drawn.</para>
            <para>
            When this is false and the control is owner drawn, 
            FluentListView will try to calculate the width of the cell's
            actual contents, and then size the editing control to be just the right width. If this is true,
            the whole width of the cell will be used, regardless of the cell's contents.
            </para>
            <para>Each column can have a different value for property. This value from the control is only
            used when a column is not specified one way or another.</para>
            <para>Regardless of this setting, developers can specify the exact size of the editing control
            by listening for the CellEditStarting event.</para>
            </remarks>
        </member>
        <member name="P:Fluent.Lists.AdvancedListView.CellEditKeyEngine">
            <summary>
            Gets or sets the engine that will handle key presses during a cell edit operation.
            Settings this to null will reset it to default value.
            </summary>
        </member>
        <member name="P:Fluent.Lists.AdvancedListView.CellEditor">
            <summary>
            Gets the control that is currently being used for editing a cell.
            </summary>
            <remarks>This will obviously be null if no cell is being edited.</remarks>
        </member>
        <member name="P:Fluent.Lists.AdvancedListView.CellEditTabChangesRows">
            <summary>
            Gets or sets the behaviour of the Tab key when editing a cell on the left or right
            edge of the control. If this is false (the default), pressing Tab will wrap to the other side
            of the same row. If this is true, pressing Tab when editing the right most cell will advance 
            to the next row 
            and Shift-Tab when editing the left-most cell will change to the previous row.
            </summary>
        </member>
        <member name="P:Fluent.Lists.AdvancedListView.CellEditEnterChangesRows">
            <summary>
            Gets or sets the behaviour of the Enter keys while editing a cell.
            If this is false (the default), pressing Enter will simply finish the editing operation.
            If this is true, Enter will finish the edit operation and start a new edit operation
            on the cell below the current cell, wrapping to the top of the next row when at the bottom cell.
            </summary>
        </member>
        <member name="P:Fluent.Lists.AdvancedListView.CellToolTip">
            <summary>
            Gets the tool tip control that shows tips for the cells
            </summary>
        </member>
        <member name="P:Fluent.Lists.AdvancedListView.CellPadding">
            <summary>
            Gets or sets how many pixels will be left blank around each cell of this item.
            Cell contents are aligned after padding has been taken into account.
            </summary>
            <remarks>
            <para>Each value of the given rectangle will be treated as an inset from
            the corresponding side. The width of the rectangle is the padding for the
            right cell edge. The height of the rectangle is the padding for the bottom
            cell edge.
            </para>
            <para>
            So, this.olv1.CellPadding = new Rectangle(1, 2, 3, 4); will leave one pixel
            of space to the left of the cell, 2 pixels at the top, 3 pixels of space
            on the right edge, and 4 pixels of space at the bottom of each cell.
            </para>
            <para>
            This setting only takes effect when the control is owner drawn.
            </para>
            <para>This setting only affects the contents of the cell. The background is
            not affected.</para>
            <para>If you set this to a foolish value, your control will appear to be empty.</para>
            </remarks>
        </member>
        <member name="P:Fluent.Lists.AdvancedListView.CellVerticalAlignment">
            <summary>
            Gets or sets how cells will be vertically aligned by default.
            </summary>
            <remarks>This setting only takes effect when the control is owner drawn. It will only be noticable
            when RowHeight has been set such that there is some vertical space in each row.</remarks>
        </member>
        <member name="P:Fluent.Lists.AdvancedListView.CheckBoxes">
            <summary>
            Should this list show checkboxes?
            </summary>
        </member>
        <member name="P:Fluent.Lists.AdvancedListView.CheckedObject">
            <summary>
            Return the model object of the row that is checked or null if no row is checked
            or more than one row is checked
            </summary>
        </member>
        <member name="P:Fluent.Lists.AdvancedListView.CheckedObjects">
            <summary>
            Get or set the collection of model objects that are checked.
            When setting this property, any row whose model object isn't
            in the given collection will be unchecked. Setting to null is
            equivilent to unchecking all.
            </summary>
            <remarks>
            <para>
            This property returns a simple collection. Changes made to the returned
            collection do NOT affect the list. This is different to the behaviour of
            CheckedIndicies collection.
            </para>
            <para>
            .NET's CheckedItems property is not helpful. It is just a short-hand for
            iterating through the list looking for items that are checked.
            </para>
            <para>
            The performance of the get method is O(n), where n is the number of items
            in the control. The performance of the set method is
            O(n + m) where m is the number of objects being checked. Be careful on long lists.
            </para>
            </remarks>
        </member>
        <member name="P:Fluent.Lists.AdvancedListView.CheckedObjectsEnumerable">
            <summary>
            Gets or sets the checked objects from an enumerable.
            </summary>
            <remarks>
            Useful for checking all objects in the list.
            </remarks>
            <example>
            this.olv1.CheckedObjectsEnumerable = this.olv1.Objects;
            </example>
        </member>
        <member name="P:Fluent.Lists.AdvancedListView.Columns">
            <summary>
            Gets Columns for this list. We hide the original so we can associate
            a specialised editor with it.
            </summary>
        </member>
        <member name="P:Fluent.Lists.AdvancedListView.ColumnsForTileView">
            <summary>
            Get/set the list of columns that should be used when the list switches to tile view.
            </summary>
        </member>
        <member name="P:Fluent.Lists.AdvancedListView.ColumnsInDisplayOrder">
            <summary>
            Return the visible columns in the order they are displayed to the user
            </summary>
        </member>
        <member name="P:Fluent.Lists.AdvancedListView.ContentRectangle">
            <summary>
            Get the area of the control that shows the list, minus any header control
            </summary>
        </member>
        <member name="P:Fluent.Lists.AdvancedListView.CopySelectionOnControlC">
            <summary>
            Gets or sets if the selected rows should be copied to the clipboard when the user presses Ctrl-C
            </summary>
        </member>
        <member name="P:Fluent.Lists.AdvancedListView.CopySelectionOnControlCUsesDragSource">
            <summary>
            Gets or sets whether the Control-C copy to clipboard functionality should use
            the installed DragSource to create the data object that is placed onto the clipboard.
            </summary>
            <remarks>This is normally what is desired, unless a custom DragSource is installed 
            that does some very specialized drag-drop behaviour.</remarks>
        </member>
        <member name="P:Fluent.Lists.AdvancedListView.Decorations">
            <summary>
            Gets the list of decorations that will be drawn the ListView
            </summary>
            <remarks>
            <para>
            Do not modify the contents of this list directly. Use the AddDecoration() and RemoveDecoration() methods.
            </para>
            <para>
            A decoration scrolls with the list contents. An overlay is fixed in place.
            </para>
            </remarks>
        </member>
        <member name="P:Fluent.Lists.AdvancedListView.DefaultRenderer">
            <summary>
            When owner drawing, this renderer will draw columns that do not have specific renderer
            given to them
            </summary>
            <remarks>If you try to set this to null, it will revert to a HighlightTextRenderer</remarks>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.GetCellRenderer(System.Object,Fluent.OLVColumn)">
            <summary>
            Get the renderer to be used to draw the given cell.
            </summary>
            <param name="model">The row model for the row</param>
            <param name="column">The column to be drawn</param>
            <returns>The renderer used for drawing a cell. Must not return null.</returns>
        </member>
        <member name="P:Fluent.Lists.AdvancedListView.DisabledItemStyle">
            <summary>
            Gets or sets the style that will be applied to disabled items.
            </summary>
            <remarks>If this is not set explicitly, <see cref="P:Fluent.Lists.AdvancedListView.DefaultDisabledItemStyle"/>  will be used.</remarks>
        </member>
        <member name="P:Fluent.Lists.AdvancedListView.DisabledObjects">
            <summary>
            Gets or sets the list of model objects that are disabled.
            Disabled objects cannot be selected or activated.
            </summary>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.IsDisabled(System.Object)">
            <summary>
            Is this given model object disabled?
            </summary>
            <param name="model"></param>
            <returns></returns>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.DisableObject(System.Object)">
            <summary>
            Disable the given model object.
            Disabled objects cannot be selected or activated.
            </summary>
            <param name="model">Must not be null</param>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.DisableObjects(System.Collections.IEnumerable)">
            <summary>
            Disable all the given model objects
            </summary>
            <param name="models"></param>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.EnableObject(System.Object)">
            <summary>
            Enable the given model object, so it can be selected and activated again.
            </summary>
            <param name="model">Must not be null</param>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.EnableObjects(System.Collections.IEnumerable)">
            <summary>
            Enable all the given model objects
            </summary>
            <param name="models"></param>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.ClearDisabledObjects">
            <summary>
            Forget all disabled objects. This does not trigger a redraw or rebuild
            </summary>
        </member>
        <member name="P:Fluent.Lists.AdvancedListView.DragSource">
            <summary>
            Gets or sets the object that controls how drags start from this control
            </summary>
        </member>
        <member name="P:Fluent.Lists.AdvancedListView.DropSink">
            <summary>
            Gets or sets the object that controls how drops are accepted and processed
            by this ListView.
            </summary>
            <remarks>
            <para>
            If the given sink is an instance of SimpleDropSink, then events from the drop sink
            will be automatically forwarded to the FluentListView (which means that handlers
            for those event can be configured within the IDE).
            </para>
            <para>If this is set to null, the control will not accept drops.</para>
            </remarks>
        </member>
        <member name="F:Fluent.Lists.AdvancedListView.EditorRegistry">
            <summary>
            This registry decides what control should be used to edit what cells, based
            on the type of the value in the cell.
            </summary>
            <see cref="F:Fluent.Lists.AdvancedListView.EditorRegistry"/>
            <remarks>All instances of FluentListView share the same editor registry.</remarks>
        </member>
        <member name="P:Fluent.Lists.AdvancedListView.EmptyListMsg">
            <summary>
            Gets or sets the text that should be shown when there are no items in this list view.
            </summary>
            <remarks>If the EmptyListMsgOverlay has been changed to something other than a TextOverlay,
            this property does nothing</remarks>
        </member>
        <member name="P:Fluent.Lists.AdvancedListView.EmptyListMsgFont">
            <summary>
            Gets or sets the font in which the List Empty message should be drawn
            </summary>
            <remarks>If the EmptyListMsgOverlay has been changed to something other than a TextOverlay,
            this property does nothing</remarks>
        </member>
        <member name="P:Fluent.Lists.AdvancedListView.EmptyListMsgFontOrDefault">
            <summary>
            Return the font for the 'list empty' message or a reasonable default
            </summary>
        </member>
        <member name="P:Fluent.Lists.AdvancedListView.EmptyListMsgOverlay">
            <summary>
            Gets or sets the overlay responsible for drawing the List Empty msg.
            </summary>
        </member>
        <member name="P:Fluent.Lists.AdvancedListView.FilteredObjects">
            <summary>
            Gets the collection of objects that survive any filtering that may be in place.
            </summary>
            <remarks>
            <para>
            This collection is the result of filtering the current list of objects. 
            It is not a snapshot of the filtered list that was last used to build the control. 
            </para>
            <para>
            Normal warnings apply when using this with virtual lists. It will work, but it
            may take a while.
            </para>
            </remarks>
        </member>
        <member name="P:Fluent.Lists.AdvancedListView.FilterMenuBuildStrategy">
            <summary>
            Gets or sets the strategy object that will be used to build the Filter menu
            </summary>
            <remarks>If this is null, no filter menu will be built.</remarks>
        </member>
        <member name="P:Fluent.Lists.AdvancedListView.FocusedObject">
            <summary>
            Gets or sets the row that has keyboard focus
            </summary>
            <remarks>
            <para>
            Setting an object to be focused does *not* select it. If you want to select and focus a row,
            use <see cref="P:Fluent.Lists.AdvancedListView.SelectedObject"/>.
            </para>
            <para>
            This property is not generally used and is only useful in specialized situations.
            </para>
            </remarks>
        </member>
        <member name="P:Fluent.Lists.AdvancedListView.Groups">
            <summary>
            Hide the Groups collection so it's not visible in the Properties grid.
            </summary>
        </member>
        <member name="P:Fluent.Lists.AdvancedListView.GroupImageList">
            <summary>
            Gets or sets the image list from which group header will take their images
            </summary>
            <remarks>If this is not set, then group headers will not show any images.</remarks>
        </member>
        <member name="P:Fluent.Lists.AdvancedListView.GroupWithItemCountFormat">
            <summary>
            Gets how the group label should be formatted when a group is empty or
            contains more than one item
            </summary>
            <remarks>
            The given format string must have two placeholders:
            <list type="bullet">
            <item><description>{0} - the original group title</description></item>
            <item><description>{1} - the number of items in the group</description></item>
            </list>
            </remarks>
            <example>"{0} [{1} items]"</example>
        </member>
        <member name="P:Fluent.Lists.AdvancedListView.GroupWithItemCountFormatOrDefault">
            <summary>
            Return this.GroupWithItemCountFormat or a reasonable default
            </summary>
        </member>
        <member name="P:Fluent.Lists.AdvancedListView.GroupWithItemCountSingularFormat">
            <summary>
            Gets how the group label should be formatted when a group contains only a single item
            </summary>
            <remarks>
            The given format string must have two placeholders:
            <list type="bullet">
            <item><description>{0} - the original group title</description></item>
            <item><description>{1} - the number of items in the group (always 1)</description></item>
            </list>
            </remarks>
            <example>"{0} [{1} item]"</example>
        </member>
        <member name="P:Fluent.Lists.AdvancedListView.GroupWithItemCountSingularFormatOrDefault">
            <summary>
            Gets GroupWithItemCountSingularFormat or a reasonable default
            </summary>
        </member>
        <member name="P:Fluent.Lists.AdvancedListView.HasCollapsibleGroups">
            <summary>
            Gets or sets whether or not the groups in this FluentListView should be collapsible.
            </summary>
            <remarks>
            This feature only works under Vista and later.
            </remarks>
        </member>
        <member name="P:Fluent.Lists.AdvancedListView.HasEmptyListMsg">
            <summary>
            Does this listview have a message that should be drawn when the list is empty?
            </summary>
        </member>
        <member name="P:Fluent.Lists.AdvancedListView.HasOverlays">
            <summary>
            Get whether there are any overlays to be drawn
            </summary>
        </member>
        <member name="P:Fluent.Lists.AdvancedListView.HeaderControl">
            <summary>
            Gets the header control for the ListView
            </summary>
        </member>
        <member name="P:Fluent.Lists.AdvancedListView.HeaderFont">
            <summary>
            Gets or sets the font in which the text of the column headers will be drawn
            </summary>
            <remarks>Individual columns can override this through their HeaderFormatStyle property.</remarks>
        </member>
        <member name="P:Fluent.Lists.AdvancedListView.HeaderFormatStyle">
            <summary>
            Gets or sets the style that will be used to draw the columm headers of the listview
            </summary>
            <remarks>
            <para>
            This is only used when HeaderUsesThemes is false.
            </para>
            <para>
            Individual columns can override this through their HeaderFormatStyle property.
            </para>
            </remarks>
        </member>
        <member name="P:Fluent.Lists.AdvancedListView.HeaderMaximumHeight">
            <summary>
            Gets or sets the maximum height of the header. -1 means no maximum.
            </summary>
        </member>
        <member name="P:Fluent.Lists.AdvancedListView.HeaderMinimumHeight">
            <summary>
            Gets or sets the minimum height of the header. -1 means no minimum.
            </summary>
        </member>
        <member name="P:Fluent.Lists.AdvancedListView.HeaderUsesThemes">
            <summary>
            Gets or sets whether the header will be drawn strictly according to the OS's theme. 
            </summary>
            <remarks>
            <para>
            If this is set to true, the header will be rendered completely by the system, without
            any of FluentListViews fancy processing -- no images in header, no filter indicators,
            no word wrapping, no header styling, no checkboxes.
            </para>
            <para>If this is set to false, FluentListView will render the header as it thinks best.
            If no special features are required, then FluentListView will delegate rendering to the OS.
            Otherwise, FluentListView will draw the header according to the configuration settings.
            </para>
            <para>
            The effect of not being themed will be different from OS to OS. At
            very least, the sort indicator will not be standard. 
            </para>
            </remarks>
        </member>
        <member name="P:Fluent.Lists.AdvancedListView.HeaderWordWrap">
            <summary>
            Gets or sets the whether the text in the header will be word wrapped.
            </summary>
            <remarks>
            <para>Line breaks will be applied between words. Words that are too long
            will still be ellipsed.</para>
            <para>
            As with all settings that make the header look different, HeaderUsesThemes must be set to false, otherwise
            the OS will be responsible for drawing the header, and it does not allow word wrapped text.
            </para>
            </remarks>
        </member>
        <member name="P:Fluent.Lists.AdvancedListView.HeaderToolTip">
            <summary>
            Gets the tool tip that shows tips for the column headers
            </summary>
        </member>
        <member name="P:Fluent.Lists.AdvancedListView.HotRowIndex">
            <summary>
            Gets the index of the row that the mouse is currently over
            </summary>
        </member>
        <member name="P:Fluent.Lists.AdvancedListView.HotColumnIndex">
            <summary>
            Gets the index of the subitem that the mouse is currently over
            </summary>
        </member>
        <member name="P:Fluent.Lists.AdvancedListView.HotCellHitLocation">
            <summary>
            Gets the part of the item/subitem that the mouse is currently over
            </summary>
        </member>
        <member name="P:Fluent.Lists.AdvancedListView.HotCellHitLocationEx">
            <summary>
            Gets an extended indication of the part of item/subitem/group that the mouse is currently over
            </summary>
        </member>
        <member name="P:Fluent.Lists.AdvancedListView.HotGroup">
            <summary>
            Gets the group that the mouse is over
            </summary>
        </member>
        <member name="P:Fluent.Lists.AdvancedListView.HotItemIndex">
            <summary>
            The index of the item that is 'hot', i.e. under the cursor. -1 means no item.
            </summary>
        </member>
        <member name="P:Fluent.Lists.AdvancedListView.HotItemStyle">
            <summary>
            What sort of formatting should be applied to the row under the cursor?
            </summary>
            <remarks>
            <para>
            This only takes effect when UseHotItem is true.
            </para>
            <para>If the style has an overlay, it must be set
            *before* assigning it to this property. Adding it afterwards will be ignored. </para>
            </remarks>
        </member>
        <member name="P:Fluent.Lists.AdvancedListView.HotItemStyleOrDefault">
            <summary>
            Gets the installed hot item style or a reasonable default.
            </summary>
        </member>
        <member name="P:Fluent.Lists.AdvancedListView.HyperlinkStyle">
            <summary>
            What sort of formatting should be applied to hyperlinks?
            </summary>
        </member>
        <member name="P:Fluent.Lists.AdvancedListView.SelectedBackColor">
            <summary>
            What color should be used for the background of selected rows?
            </summary>
        </member>
        <member name="P:Fluent.Lists.AdvancedListView.SelectedBackColorOrDefault">
            <summary>
            Return the color should be used for the background of selected rows or a reasonable default
            </summary>
        </member>
        <member name="P:Fluent.Lists.AdvancedListView.SelectedForeColor">
            <summary>
            What color should be used for the foreground of selected rows?
            </summary>
        </member>
        <member name="P:Fluent.Lists.AdvancedListView.SelectedForeColorOrDefault">
            <summary>
            Return the color should be used for the foreground of selected rows or a reasonable default
            </summary>
        </member>
        <member name="P:Fluent.Lists.AdvancedListView.IncludeHiddenColumnsInDataTransfer">
            <summary>
            Gets or sets whether or not hidden columns should be included in the text representation
            of rows that are copied or dragged to another application. If this is false (the default),
            only visible columns will be included.
            </summary>
        </member>
        <member name="P:Fluent.Lists.AdvancedListView.IncludeColumnHeadersInCopy">
            <summary>
            Gets or sets whether or not hidden columns should be included in the text representation
            of rows that are copied or dragged to another application. If this is false (the default),
            only visible columns will be included.
            </summary>
        </member>
        <member name="P:Fluent.Lists.AdvancedListView.IsCellEditing">
            <summary>
            Return true if a cell edit operation is currently happening
            </summary>
        </member>
        <member name="P:Fluent.Lists.AdvancedListView.IsDesignMode">
            <summary>
            Return true if the FluentListView is being used within the development environment.
            </summary>
        </member>
        <member name="P:Fluent.Lists.AdvancedListView.IsFiltering">
            <summary>
            Gets whether or not the current list is filtering its contents
            </summary>
        </member>
        <member name="P:Fluent.Lists.AdvancedListView.IsSearchOnSortColumn">
            <summary>
            When the user types into a list, should the values in the current sort column be searched to find a match?
            If this is false, the primary column will always be used regardless of the sort column.
            </summary>
            <remarks>When this is true, the behavior is like that of ITunes.</remarks>
        </member>
        <member name="P:Fluent.Lists.AdvancedListView.IsSimpleDropSink">
            <summary>
            Gets or sets if this control will use a SimpleDropSink to receive drops
            </summary>
            <remarks>
            <para>
            Setting this replaces any previous DropSink.
            </para>
            <para>
            After setting this to true, the SimpleDropSink will still need to be configured
            to say when it can accept drops and what should happen when something is dropped.
            The need to do these things makes this property mostly useless :(
            </para>
            </remarks>
        </member>
        <member name="P:Fluent.Lists.AdvancedListView.IsSimpleDragSource">
            <summary>
            Gets or sets if this control will use a SimpleDragSource to initiate drags
            </summary>
            <remarks>Setting this replaces any previous DragSource</remarks>
        </member>
        <member name="P:Fluent.Lists.AdvancedListView.Items">
            <summary>
            Hide the Items collection so it's not visible in the Properties grid.
            </summary>
        </member>
        <member name="P:Fluent.Lists.AdvancedListView.ItemRenderer">
            <summary>
            This renderer draws the items when in the list is in non-details view.
            In details view, the renderers for the individuals columns are responsible.
            </summary>
        </member>
        <member name="P:Fluent.Lists.AdvancedListView.LastSortColumn">
            <summary>
            Which column did we last sort by
            </summary>
            <remarks>This is an alias for PrimarySortColumn</remarks>
        </member>
        <member name="P:Fluent.Lists.AdvancedListView.LastSortOrder">
            <summary>
            Which direction did we last sort
            </summary>
            <remarks>This is an alias for PrimarySortOrder</remarks>
        </member>
        <member name="P:Fluent.Lists.AdvancedListView.ListFilter">
            <summary>
            Gets or  sets the filter that is applied to our whole list of objects.
            </summary>
            <remarks>
            The list is updated immediately to reflect this filter. 
            </remarks>
        </member>
        <member name="P:Fluent.Lists.AdvancedListView.ModelFilter">
            <summary>
            Gets or  sets the filter that is applied to each model objects in the list
            </summary>
            <remarks>
            <para>You may want to consider using <see cref="P:Fluent.Lists.AdvancedListView.AdditionalFilter"/> instead of this property,
            since AdditionalFilter combines with column filtering at runtime. Setting this property simply
            replaces any column filter the user may have given.</para>
            <para>
            The list is updated immediately to reflect this filter. 
            </para>
            </remarks>
        </member>
        <member name="P:Fluent.Lists.AdvancedListView.MouseMoveHitTest">
            <summary>
            Gets the hit test info last time the mouse was moved.
            </summary>
            <remarks>Useful for hot item processing.</remarks>
        </member>
        <member name="P:Fluent.Lists.AdvancedListView.OLVGroups">
            <summary>
            Gets or sets the list of groups shown by the listview.
            </summary>
            <remarks>
            This property does not work like the .NET Groups property. It should
            be treated as a read-only property.
            Changes made to the list are NOT reflected in the ListView itself -- it is pointless to add
            or remove groups to/from this list. Such modifications will do nothing.
            To do such things, you must listen for
            BeforeCreatingGroups or AboutToCreateGroups events, and change the list of
            groups in those events.
            </remarks>
        </member>
        <member name="P:Fluent.Lists.AdvancedListView.CollapsedGroups">
            <summary>
            Gets or sets the collection of OLVGroups that are collapsed.
            </summary>
        </member>
        <member name="P:Fluent.Lists.AdvancedListView.OwnerDrawnHeader">
            <summary>
            Gets or sets whether the user wants to owner draw the header control
            themselves. If this is false (the default), FluentListView will use
            custom drawing to render the header, if needed.
            </summary>
            <remarks>
            If you listen for the DrawColumnHeader event, you need to set this to true,
            otherwise your event handler will not be called.
            </remarks>
        </member>
        <member name="P:Fluent.Lists.AdvancedListView.Objects">
            <summary>
            Get/set the collection of objects that this list will show
            </summary>
            <remarks>
            <para>
            The contents of the control will be updated immediately after setting this property.
            </para>
            <para>This method preserves selection, if possible. Use <see cref="M:Fluent.Lists.AdvancedListView.SetObjects(System.Collections.IEnumerable,System.Boolean)"/> if
            you do not want to preserve the selection. Preserving selection is the slowest part of this
            code and performance is O(n) where n is the number of selected rows.</para>
            <para>This method is not thread safe.</para>
            <para>The property DOES work on virtual lists: setting is problem-free, but if you try to get it
            and the list has 10 million objects, it may take some time to return.</para>
            <para>This collection is unfiltered. Use <see cref="P:Fluent.Lists.AdvancedListView.FilteredObjects"/> to access just those objects
            that survive any installed filters.</para>
            </remarks>
        </member>
        <member name="P:Fluent.Lists.AdvancedListView.ObjectsForClustering">
            <summary>
            Gets the collection of objects that will be considered when creating clusters
            (which are used to generate Excel-like column filters)
            </summary>
        </member>
        <member name="P:Fluent.Lists.AdvancedListView.OverlayImage">
            <summary>
            Gets or sets the image that will be drawn over the top of the ListView
            </summary>
        </member>
        <member name="P:Fluent.Lists.AdvancedListView.OverlayText">
            <summary>
            Gets or sets the text that will be drawn over the top of the ListView
            </summary>
        </member>
        <member name="P:Fluent.Lists.AdvancedListView.OverlayTransparency">
            <summary>
            Gets or sets the transparency of all the overlays.
            0 is completely transparent, 255 is completely opaque.
            </summary>
            <remarks>
            This is obsolete. Use Transparency on each overlay.
            </remarks>
        </member>
        <member name="P:Fluent.Lists.AdvancedListView.Overlays">
            <summary>
            Gets the list of overlays that will be drawn on top of the ListView
            </summary>
            <remarks>
            You can add new overlays and remove overlays that you have added, but
            don't mess with the overlays that you didn't create.
            </remarks>
        </member>
        <member name="P:Fluent.Lists.AdvancedListView.OwnerDraw">
            <summary>
            Gets or sets whether the FluentListView will be owner drawn. Defaults to true.
            </summary>
            <remarks>
            <para>
            When this is true, all of FluentListView's neat features are available.
            </para>
            <para>We have to reimplement this property, even though we just call the base
            property, in order to change the [DefaultValue] to true.
            </para>
            </remarks>
        </member>
        <member name="P:Fluent.Lists.AdvancedListView.PersistentCheckBoxes">
            <summary>
            Gets or sets whether or not primary checkboxes will persistent their values across list rebuild
            and filtering operations.
            </summary>
            <remarks>
            <para>
            This property is only useful when you don't explicitly set CheckStateGetter/Putter.
            If you use CheckStateGetter/Putter, the checkedness of a row will already be persisted
            by those methods. 
            </para>
            <para>This defaults to true. If this is false, checkboxes will lose their values when the
            list if rebuild or filtered.
             If you set it to false on virtual lists,
            you have to install CheckStateGetter/Putters.</para>
            </remarks>
        </member>
        <member name="P:Fluent.Lists.AdvancedListView.CheckStateMap">
            <summary>
            Gets or sets a dictionary that remembers the check state of model objects
            </summary>
            <remarks>This is used when PersistentCheckBoxes is true and for virtual lists.</remarks>
        </member>
        <member name="P:Fluent.Lists.AdvancedListView.PrimarySortColumn">
            <summary>
            Which column did we last sort by
            </summary>
        </member>
        <member name="P:Fluent.Lists.AdvancedListView.PrimarySortOrder">
            <summary>
            Which direction did we last sort
            </summary>
        </member>
        <member name="P:Fluent.Lists.AdvancedListView.RenderNonEditableCheckboxesAsDisabled">
            <summary>
            Gets or sets if non-editable checkboxes are drawn as disabled. Default is false.
            </summary>
            <remarks>
            <para>This only has effect in owner drawn mode.</para>
            </remarks>
        </member>
        <member name="P:Fluent.Lists.AdvancedListView.RowHeight">
            <summary>
            Specify the height of each row in the control in pixels.
            </summary>
            <remarks><para>The row height in a listview is normally determined by the font size and the small image list size.
            This setting allows that calculation to be overridden (within reason: you still cannot set the line height to be
            less than the line height of the font used in the control). </para>
            <para>Setting it to -1 means use the normal calculation method.</para>
            <para><bold>This feature is experiemental!</bold> Strange things may happen to your program,
            your spouse or your pet if you use it.</para>
            </remarks>
        </member>
        <member name="P:Fluent.Lists.AdvancedListView.RowHeightEffective">
            <summary>
            How many pixels high is each row?
            </summary>
        </member>
        <member name="P:Fluent.Lists.AdvancedListView.RowsPerPage">
            <summary>
            How many rows appear on each page of this control
            </summary>
        </member>
        <member name="P:Fluent.Lists.AdvancedListView.SecondarySortColumn">
            <summary>
            Get/set the column that will be used to resolve comparisons that are equal when sorting.
            </summary>
            <remarks>There is no user interface for this setting. It must be set programmatically.</remarks>
        </member>
        <member name="P:Fluent.Lists.AdvancedListView.SecondarySortOrder">
            <summary>
            When the SecondarySortColumn is used, in what order will it compare results?
            </summary>
        </member>
        <member name="P:Fluent.Lists.AdvancedListView.SelectAllOnControlA">
            <summary>
            Gets or sets if all rows should be selected when the user presses Ctrl-A
            </summary>
        </member>
        <member name="P:Fluent.Lists.AdvancedListView.SelectColumnsOnRightClick">
            <summary>
            When the user right clicks on the column headers, should a menu be presented which will allow
            them to choose which columns will be shown in the view?
            </summary>
            <remarks>This is just a compatibility wrapper for the SelectColumnsOnRightClickBehaviour
            property.</remarks>
        </member>
        <member name="P:Fluent.Lists.AdvancedListView.SelectColumnsOnRightClickBehaviour">
            <summary>
            Gets or sets how the user will be able to select columns when the header is right clicked
            </summary>
        </member>
        <member name="P:Fluent.Lists.AdvancedListView.SelectColumnsMenuStaysOpen">
            <summary>
            When the column select menu is open, should it stay open after an item is selected?
            Staying open allows the user to turn more than one column on or off at a time.
            </summary>
            <remarks>This only works when SelectColumnsOnRightClickBehaviour is set to InlineMenu.
            It has no effect when the behaviour is set to SubMenu.</remarks>
        </member>
        <member name="P:Fluent.Lists.AdvancedListView.SelectedColumn">
            <summary>
            Gets or sets the column that is drawn with a slight tint.
            </summary>
            <remarks>
            <para>
            If TintSortColumn is true, the sort column will automatically
            be made the selected column.
            </para>
            <para>
            The colour of the tint is controlled by SelectedColumnTint.
            </para>
            </remarks>
        </member>
        <member name="P:Fluent.Lists.AdvancedListView.SelectedRowDecoration">
            <summary>
            Gets or sets the decoration that will be drawn on all selected rows
            </summary>
        </member>
        <member name="P:Fluent.Lists.AdvancedListView.SelectedColumnTint">
            <summary>
            What color should be used to tint the selected column?
            </summary>
            <remarks>
            The tint color must be alpha-blendable, so if the given color is solid
            (i.e. alpha = 255), it will be changed to have a reasonable alpha value.
            </remarks>
        </member>
        <member name="P:Fluent.Lists.AdvancedListView.SelectedIndex">
            <summary>
            Gets or sets the index of the row that is currently selected. 
            When getting the index, if no row is selected,or more than one is selected, return -1.
            </summary>
        </member>
        <member name="P:Fluent.Lists.AdvancedListView.SelectedItem">
            <summary>
            Gets or sets the ListViewItem that is currently selected . If no row is selected, or more than one is selected, return null.
            </summary>
        </member>
        <member name="P:Fluent.Lists.AdvancedListView.SelectedObject">
            <summary>
            Gets the model object from the currently selected row, if there is only one row selected. 
            If no row is selected, or more than one is selected, returns null.
            When setting, this will select the row that is displaying the given model object and focus on it. 
            All other rows are deselected.
            </summary>
        </member>
        <member name="P:Fluent.Lists.AdvancedListView.SelectedObjects">
            <summary>
            Get the model objects from the currently selected rows. If no row is selected, the returned List will be empty.
            When setting this value, select the rows that is displaying the given model objects. All other rows are deselected.
            </summary>
        </member>
        <member name="P:Fluent.Lists.AdvancedListView.ShowCommandMenuOnRightClick">
            <summary>
            When the user right clicks on the column headers, should a menu be presented which will allow
            them to choose common tasks to perform on the listview?
            </summary>
        </member>
        <member name="P:Fluent.Lists.AdvancedListView.ShowFilterMenuOnRightClick">
            <summary>
            Gets or sets whether this FluentListView will show Excel like filtering
            menus when the header control is right clicked
            </summary>
        </member>
        <member name="P:Fluent.Lists.AdvancedListView.ShowGroups">
            <summary>
            Should this list show its items in groups?
            </summary>
        </member>
        <member name="P:Fluent.Lists.AdvancedListView.ShowSortIndicators">
            <summary>
            Should the list view show a bitmap in the column header to show the sort direction?
            </summary>
            <remarks>
            The only reason for not wanting to have sort indicators is that, on pre-XP versions of
            Windows, having sort indicators required the ListView to have a small image list, and
            as soon as you give a ListView a SmallImageList, the text of column 0 is bumped 16
            pixels to the right, even if you never used an image.
            </remarks>
        </member>
        <member name="P:Fluent.Lists.AdvancedListView.ShowImagesOnSubItems">
            <summary>
            Should the list view show images on subitems?
            </summary>
            <remarks>
            <para>Virtual lists have to be owner drawn in order to show images on subitems</para>
            </remarks>
        </member>
        <member name="P:Fluent.Lists.AdvancedListView.ShowItemCountOnGroups">
            <summary>
            This property controls whether group labels will be suffixed with a count of items.
            </summary>
            <remarks>
            The format of the suffix is controlled by GroupWithItemCountFormat/GroupWithItemCountSingularFormat properties
            </remarks>
        </member>
        <member name="P:Fluent.Lists.AdvancedListView.ShowHeaderInAllViews">
            <summary>
            Gets or sets whether the control will show column headers in all
            views (true), or only in Details view (false)
            </summary>
            <remarks>
            <para>
            This property is not working correctly. JPP 2010/04/06.
            It works fine if it is set before the control is created.
            But if it turned off once the control is created, the control
            loses its checkboxes (weird!)
            </para>
            <para>
            To changed this setting after the control is created, things
            are complicated. If it is off and we want it on, we have
            to change the View and the header will appear. If it is currently
            on and we want to turn it off, we have to both change the view
            AND recreate the handle. Recreating the handle is a problem 
            since it makes our checkbox style disappear. 
            </para>
            <para>
            This property doesn't work on XP.</para>
            </remarks>
        </member>
        <member name="P:Fluent.Lists.AdvancedListView.SmallImageList">
            <summary>
            Override the SmallImageList property so we can correctly shadow its operations.
            </summary>
            <remarks><para>If you use the RowHeight property to specify the row height, the SmallImageList
            must be fully initialised before setting/changing the RowHeight. If you add new images to the image
            list after setting the RowHeight, you must assign the imagelist to the control again. Something as simple
            as this will work:
            <code>listView1.SmallImageList = listView1.SmallImageList;</code></para>
            </remarks>
        </member>
        <member name="P:Fluent.Lists.AdvancedListView.SmallImageSize">
            <summary>
            Return the size of the images in the small image list or a reasonable default
            </summary>
        </member>
        <member name="P:Fluent.Lists.AdvancedListView.SortGroupItemsByPrimaryColumn">
            <summary>
            When the listview is grouped, should the items be sorted by the primary column?
            If this is false, the items will be sorted by the same column as they are grouped.
            </summary>
        </member>
        <member name="P:Fluent.Lists.AdvancedListView.SpaceBetweenGroups">
            <summary>
            When the listview is grouped, how many pixels should exist between the end of one group and the
            beginning of the next?
            </summary>
        </member>
        <member name="P:Fluent.Lists.AdvancedListView.TintSortColumn">
            <summary>
            Should the sort column show a slight tinge?
            </summary>
        </member>
        <member name="P:Fluent.Lists.AdvancedListView.TriStateCheckBoxes">
            <summary>
            Should each row have a tri-state checkbox?
            </summary>
            <remarks>
            If this is true, the user can choose the third state (normally Indeterminate). Otherwise, user clicks
            alternate between checked and unchecked. CheckStateGetter can still return Indeterminate when this
            setting is false.
            </remarks>
        </member>
        <member name="P:Fluent.Lists.AdvancedListView.TopItemIndex">
            <summary>
            Get or set the index of the top item of this listview
            </summary>
            <remarks>
            <para>
            This property only works when the listview is in Details view and not showing groups.
            </para>
            <para>
            The reason that it does not work when showing groups is that, when groups are enabled,
            the Windows msg LVM_GETTOPINDEX always returns 0, regardless of the
            scroll position.
            </para>
            </remarks>
        </member>
        <member name="P:Fluent.Lists.AdvancedListView.TriggerCellOverEventsWhenOverHeader">
            <summary>
            Gets or sets whether moving the mouse over the header will trigger CellOver events.
            Defaults to true.
            </summary>
            <remarks>
            Moving the mouse over the header did not previously trigger CellOver events, since the
            header is considered a separate control. 
            If this change in behaviour causes your application problems, set this to false.
            If you are interested in knowing when the mouse moves over the header, set this property to true (the default).
            </remarks>
        </member>
        <member name="P:Fluent.Lists.AdvancedListView.UpdateSpaceFillingColumnsWhenDraggingColumnDivider">
            <summary>
            When resizing a column by dragging its divider, should any space filling columns be
            resized at each mouse move? If this is false, the filling columns will be
            updated when the mouse is released.
            </summary>
            <remarks>
            <para>
            If you have a space filling column
            is in the left of the column that is being resized, this will look odd: 
            the right edge of the column will be dragged, but
            its <b>left</b> edge will move since the space filling column is shrinking.
            </para>
            <para>This is logical behaviour -- it just looks wrong.   
            </para>
            <para>
            Given the above behavior is probably best to turn this property off if your space filling
            columns aren't the right-most columns.</para>
            </remarks>
        </member>
        <member name="P:Fluent.Lists.AdvancedListView.UnfocusedSelectedBackColor">
            <summary>
            What color should be used for the background of selected rows when the control doesn't have the focus?
            </summary>
        </member>
        <member name="P:Fluent.Lists.AdvancedListView.UnfocusedSelectedBackColorOrDefault">
            <summary>
            Return the color should be used for the background of selected rows when the control doesn't have the focus or a reasonable default
            </summary>
        </member>
        <member name="P:Fluent.Lists.AdvancedListView.UnfocusedSelectedForeColor">
            <summary>
            What color should be used for the foreground of selected rows when the control doesn't have the focus?
            </summary>
        </member>
        <member name="P:Fluent.Lists.AdvancedListView.UnfocusedSelectedForeColorOrDefault">
            <summary>
            Return the color should be used for the foreground of selected rows when the control doesn't have the focus or a reasonable default
            </summary>
        </member>
        <member name="P:Fluent.Lists.AdvancedListView.UseAlternatingBackColors">
            <summary>
            Gets or sets whether the list give a different background color to every second row? Defaults to false.
            </summary>
            <remarks><para>The color of the alternate rows is given by AlternateRowBackColor.</para>
            <para>There is a "feature" in .NET for listviews in non-full-row-select mode, where
            selected rows are not drawn with their correct background color.</para></remarks>
        </member>
        <member name="P:Fluent.Lists.AdvancedListView.UseCellFormatEvents">
            <summary>
            Should FormatCell events be called for each cell in the control?
            </summary>
            <remarks>
            <para>In many situations, no cell level formatting is performed. FluentListView
            can run somewhat faster if it does not trigger a format cell event for every cell
            unless it is required. So, by default, it does not raise an event for each cell.
            </para>
            <para>FluentListView *does* raise a FormatRow event every time a row is rebuilt.
            Individual rows can decide whether to raise FormatCell
            events for every cell in row.
            </para>
            <para>
            Regardless of this setting, FormatCell events are only raised when the FluentListView
            is in Details view.</para>
            </remarks>
        </member>
        <member name="P:Fluent.Lists.AdvancedListView.UseCustomSelectionColors">
            <summary>
            Should the selected row be drawn with non-standard foreground and background colors?
            </summary>
            <remarks>v2.9 This property is no longer required</remarks>
        </member>
        <member name="P:Fluent.Lists.AdvancedListView.UseExplorerTheme">
            <summary>
            Gets or sets whether this FluentListView will use the same hot item and selection 
            mechanism that Vista Explorer does.
            </summary>
            <remarks>
            <para>
            This property has many imperfections:
            <list type="bullet">
            <item><description>This only works on Vista and later</description></item>
            <item><description>It does not work well with AlternateRowBackColors.</description></item>
            <item><description>It does not play well with HotItemStyles.</description></item>
            <item><description>It looks a little bit silly is FullRowSelect is false.</description></item>
            <item><description>It doesn't work at all when the list is owner drawn (since the renderers
            do all the drawing). As such, it won't work with TreeListView's since they *have to be*
            owner drawn. You can still set it, but it's just not going to be happy.</description></item>
            </list>
            But if you absolutely have to look like Vista/Win7, this is your property. 
            Do not complain if settings this messes up other things.
            </para>
            <para>
            When this property is set to true, the FluentListView will be not owner drawn. This will
            disable many of the pretty drawing-based features of FluentListView.
            </para>
            </remarks>
        </member>
        <member name="P:Fluent.Lists.AdvancedListView.UseFiltering">
            <summary>
            Gets or sets whether the list should enable filtering
            </summary>
        </member>
        <member name="P:Fluent.Lists.AdvancedListView.UseFilterIndicator">
            <summary>
            Gets or sets whether the list should put an indicator into a column's header to show that
            it is filtering on that column
            </summary>
            <remarks>If you set this to true, HeaderUsesThemes is automatically set to false, since
            we can only draw a filter indicator when not using a themed header.</remarks>
        </member>
        <member name="P:Fluent.Lists.AdvancedListView.UseHotControls">
            <summary>
            Should controls (checkboxes or buttons) that are under the mouse be drawn "hot"?
            </summary>
            <remarks>
            <para>If this is false, control will not be drawn differently when the mouse is over them.</para>
            <para>
            If this is false AND UseHotItem is false AND UseHyperlinks is false, then the FluentListView
            can skip some processing on mouse move. This make mouse move processing use almost no CPU.
            </para>
            </remarks>
        </member>
        <member name="P:Fluent.Lists.AdvancedListView.UseHotItem">
            <summary>
            Should the item under the cursor be formatted in a special way?
            </summary>
        </member>
        <member name="P:Fluent.Lists.AdvancedListView.UseHyperlinks">
            <summary>
            Gets or sets whether this listview should show hyperlinks in the cells.
            </summary>
        </member>
        <member name="P:Fluent.Lists.AdvancedListView.UseOverlays">
            <summary>
            Should this control show overlays
            </summary>
            <remarks>Overlays are enabled by default and would only need to be disabled
            if they were causing problems in your development environment.</remarks>
        </member>
        <member name="P:Fluent.Lists.AdvancedListView.UseSubItemCheckBoxes">
            <summary>
            Should this control be configured to show check boxes on subitems?
            </summary>
            <remarks>If this is set to True, the control will be given a SmallImageList if it
            doesn't already have one. Also, if it is a virtual list, it will be set to owner
            drawn, since virtual lists can't draw check boxes without being owner drawn.</remarks>
        </member>
        <member name="P:Fluent.Lists.AdvancedListView.UseTranslucentSelection">
            <summary>
            Gets or sets if the FluentListView will use a translucent selection mechanism like Vista.
            </summary>
            <remarks>
            <para>
            Unlike UseExplorerTheme, this Vista-like scheme works on XP and for both
            owner and non-owner drawn lists.
            </para>
            <para>
            This will replace any SelectedRowDecoration that has been installed.
            </para>
            <para>
            If you don't like the colours used for the selection, ignore this property and 
            just create your own RowBorderDecoration and assigned it to SelectedRowDecoration,
            just like this property setter does.
            </para>
            </remarks>
        </member>
        <member name="P:Fluent.Lists.AdvancedListView.UseTranslucentHotItem">
            <summary>
            Gets or sets if the FluentListView will use a translucent hot row highlighting mechanism like Vista.
            </summary>
            <remarks>
            <para>
            Setting this will replace any HotItemStyle that has been installed.
            </para>
            <para>
            If you don't like the colours used for the hot item, ignore this property and 
            just create your own HotItemStyle, fill in the values you want, and assigned it to HotItemStyle property,
            just like this property setter does.
            </para>
            </remarks>
        </member>
        <member name="P:Fluent.Lists.AdvancedListView.View">
            <summary>
            Get/set the style of view that this listview is using
            </summary>
            <remarks>Switching to tile or details view installs the columns appropriate to that view.
            Confusingly, in tile view, every column is shown as a row of information.</remarks>
        </member>
        <member name="P:Fluent.Lists.AdvancedListView.BooleanCheckStateGetter">
            <summary>
            This delegate fetches the checkedness of an object as a boolean only.
            </summary>
            <remarks>Use this if you never want to worry about the
            Indeterminate state (which is fairly common).
            <para>
            This is a convenience wrapper around the CheckStateGetter property.
            </para>
            </remarks>
        </member>
        <member name="P:Fluent.Lists.AdvancedListView.BooleanCheckStatePutter">
            <summary>
            This delegate sets the checkedness of an object as a boolean only. It must return
            true or false indicating if the object was checked or not.
            </summary>
            <remarks>Use this if you never want to worry about the
            Indeterminate state (which is fairly common).
            <para>
            This is a convenience wrapper around the CheckStatePutter property.
            </para>
            </remarks>
        </member>
        <member name="P:Fluent.Lists.AdvancedListView.CanShowGroups">
            <summary>
            Gets whether or not this listview is capabale of showing groups
            </summary>
        </member>
        <member name="P:Fluent.Lists.AdvancedListView.CanUseApplicationIdle">
            <summary>
            Gets or sets whether FluentListView can rely on Application.Idle events
            being raised.
            </summary>
            <remarks>In some host environments (e.g. when running as an extension within
            VisualStudio and possibly Office), Application.Idle events are never raised.
            Set this to false when Idle events will not be raised, and FluentListView will
            raise those events itself.
            </remarks>
        </member>
        <member name="P:Fluent.Lists.AdvancedListView.CellRendererGetter">
            <summary>
            This delegate fetches the renderer for a particular cell. 
            </summary>
            <remarks>
            <para>
            If this returns null (or is not installed), the renderer for the column will be used.
            If the column renderer is null, then <seealso cref="P:Fluent.Lists.AdvancedListView.DefaultRenderer"/> will be used.
            </para>
            <para>
            This is called every time any cell is drawn. It must be efficient! 
            </para>
            </remarks>
        </member>
        <member name="P:Fluent.Lists.AdvancedListView.CellToolTipGetter">
            <summary>
            This delegate is called when the list wants to show a tooltip for a particular cell.
            The delegate should return the text to display, or null to use the default behavior
            (which is to show the full text of truncated cell values).
            </summary>
            <remarks>
            Displaying the full text of truncated cell values only work for FullRowSelect listviews.
            This is MS's behavior, not mine. Don't complain to me :)
            </remarks>
        </member>
        <member name="P:Fluent.Lists.AdvancedListView.CheckedAspectName">
            <summary>
            The name of the property (or field) that holds whether or not a model is checked.
            </summary>
            <remarks>
            <para>The property be modifiable. It must have a return type of bool (or of bool? if
            TriStateCheckBoxes is true).</para>
            <para>Setting this property replaces any CheckStateGetter or CheckStatePutter that have been installed.
            Conversely, later setting the CheckStateGetter or CheckStatePutter properties will take precedence
            over the behavior of this property.</para>
            </remarks>
        </member>
        <member name="P:Fluent.Lists.AdvancedListView.CheckStateGetter">
            <summary>
            This delegate will be called whenever the FluentListView needs to know the check state
            of the row associated with a given model object.
            </summary>
            <remarks>
            <para>.NET has no support for indeterminate values, but as of v2.0, this class allows
            indeterminate values.</para>
            </remarks>
        </member>
        <member name="P:Fluent.Lists.AdvancedListView.CheckStatePutter">
            <summary>
            This delegate will be called whenever the user tries to change the check state of a row.
            The delegate should return the state that was actually set, which may be different
            to the state given.
            </summary>
        </member>
        <member name="P:Fluent.Lists.AdvancedListView.CustomSorter">
            <summary>
            This delegate can be used to sort the table in a custom fasion.
            </summary>
            <remarks>
            <para>
            The delegate must install a ListViewItemSorter on the FluentListView.
            Installing the ItemSorter does the actual work of sorting the ListViewItems.
            See ColumnComparer in the code for an example of what an ItemSorter has to do.
            </para>
            <para>
            Do not install a CustomSorter on a VirtualFluentListView. Override the SortObjects()
            method of the IVirtualListDataSource instead.
            </para>
            </remarks>
        </member>
        <member name="P:Fluent.Lists.AdvancedListView.HeaderToolTipGetter">
            <summary>
            This delegate is called when the list wants to show a tooltip for a particular header.
            The delegate should return the text to display, or null to use the default behavior
            (which is to not show any tooltip).
            </summary>
            <remarks>
            Installing a HeaderToolTipGetter takes precedence over any text in OLVColumn.ToolTipText.
            </remarks>
        </member>
        <member name="P:Fluent.Lists.AdvancedListView.RowFormatter">
            <summary>
            This delegate can be used to format a OLVListItem before it is added to the control.
            </summary>
            <remarks>
            <para>The model object for the row can be found through the RowObject property of the OLVListItem object.</para>
            <para>All subitems normally have the same style as list item, so setting the forecolor on one
            subitem changes the forecolor of all subitems.
            To allow subitems to have different attributes, do this:
            <code>myListViewItem.UseItemStyleForSubItems = false;</code>.
            </para>
            <para>If UseAlternatingBackColors is true, the backcolor of the listitem will be calculated
            by the control and cannot be controlled by the RowFormatter delegate.
            In general, trying to use a RowFormatter
            when UseAlternatingBackColors is true does not work well.</para>
            <para>As it says in the summary, this is called <b>before</b> the item is added to the control.
            Many properties of the OLVListItem itself are not available at that point, including:
            Index, Selected, Focused, Bounds, Checked, DisplayIndex.</para>
            </remarks>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.AddObject(System.Object)">
            <summary>
            Add the given model object to this control.
            </summary>
            <param name="modelObject">The model object to be displayed</param>
            <remarks>See AddObjects() for more details</remarks>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.AddObjects(System.Collections.ICollection)">
            <summary>
            Add the given collection of model objects to this control.
            </summary>
            <param name="modelObjects">A collection of model objects</param>
            <remarks>
            <para>The added objects will appear in their correct sort position, if sorting
            is active (i.e. if PrimarySortColumn is not null). Otherwise, they will appear at the end of the list.</para>
            <para>No check is performed to see if any of the objects are already in the ListView.</para>
            <para>Null objects are silently ignored.</para>
            </remarks>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.AutoResizeColumns">
            <summary>
            Resize the columns to the maximum of the header width and the data.
            </summary>		
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.AutoSizeColumns">
            <summary>
            Set up any automatically initialized column widths (columns that 
            have a width of 0 or -1 will be resized to the width of their 
            contents or header respectively).
            </summary>
            <remarks>
            Obviously, this will only work once. Once it runs, the columns widths will
            be changed to something else (other than 0 or -1), so it wont do anything the 
            second time through. Use <see cref="M:Fluent.Lists.AdvancedListView.AutoResizeColumns"/> to force all columns
            to change their size.
            </remarks>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.BuildGroups">
            <summary>
            Organise the view items into groups, based on the last sort column or the first column
            if there is no last sort column
            </summary>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.BuildGroups(Fluent.OLVColumn,System.Windows.Forms.SortOrder)">
            <summary>
            Organise the view items into groups, based on the given column
            </summary>
            <remarks>
            <para>
            If the AlwaysGroupByColumn property is not null,
            the list view items will be organisd by that column,
            and the 'column' parameter will be ignored.
            </para>
            <para>This method triggers sorting events: BeforeSorting and AfterSorting.</para>
            </remarks>
            <param name="column">The column whose values should be used for sorting.</param>
            <param name="order"></param>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.BuildGroups(Fluent.OLVColumn,System.Windows.Forms.SortOrder,Fluent.OLVColumn,System.Windows.Forms.SortOrder,Fluent.OLVColumn,System.Windows.Forms.SortOrder)">
            <summary>
            Organise the view items into groups, based on the given columns
            </summary>
            <param name="groupByColumn">What column will be used for grouping</param>
            <param name="groupByOrder">What ordering will be used for groups</param>
            <param name="column">The column whose values should be used for sorting. Cannot be null</param>
            <param name="order">The order in which the values from column will be sorted</param>
            <param name="secondaryColumn">When the values from 'column' are equal, use the values provided by this column</param>
            <param name="secondaryOrder">How will the secondary values be sorted</param>
            <remarks>This method does not trigger sorting events. Use BuildGroups() to do that</remarks>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.CollectGroupingParameters(Fluent.OLVColumn,System.Windows.Forms.SortOrder,Fluent.OLVColumn,System.Windows.Forms.SortOrder,Fluent.OLVColumn,System.Windows.Forms.SortOrder)">
            <summary>
            Collect and return all the variables that influence the creation of groups
            </summary>
            <returns></returns>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.MakeGroups(Fluent.GroupingParameters)">
            <summary>
            Make a list of groups that should be shown according to the given parameters
            </summary>
            <param name="parms"></param>
            <returns>The list of groups to be created</returns>
            <remarks>This should not change the state of the control. It is possible that the
            groups created will not be used. They may simply be discarded.</remarks>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.BuildList">
            <summary>
            Build/rebuild all the list view items in the list, preserving as much state as is possible
            </summary>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.BuildList(System.Boolean)">
            <summary>
            Build/rebuild all the list view items in the list
            </summary>
            <param name="shouldPreserveState">If this is true, the control will try to preserve the selection,
            focused item, and the scroll position (see Remarks)
            </param>
            <remarks>
            <para>
            Use this method in situations were the contents of the list is basically the same
            as previously.
            </para>
            </remarks>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.ClearCachedInfo">
            <summary>
            Clear any cached info this list may have been using
            </summary>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.ApplyExtendedStyles">
            <summary>
            Apply all required extended styles to our control.
            </summary>
            <remarks>
            <para>
            Whenever .NET code sets an extended style, it erases all other extended styles
            that it doesn't use. So, we have to explicit reapply the styles that we have
            added.
            </para>
            <para>
            Normally, we would override CreateParms property and update
            the ExStyle member, but ListView seems to ignore all ExStyles that
            it doesn't already know about. Worse, when we set the LVS_EX_HEADERINALLVIEWS 
            value, bad things happen (the control crashes!).
            </para>
            </remarks>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.CalculateReasonableTileSize">
            <summary>
            Give the listview a reasonable size of its tiles, based on the number of lines of
            information that each tile is going to display.
            </summary>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.ChangeToFilteredColumns(System.Windows.Forms.View)">
            <summary>
            Rebuild this list for the given view
            </summary>
            <param name="view"></param>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.ClearObjects">
            <summary>
            Remove all items from this list
            </summary>
            <remark>This method can safely be called from background threads.</remark>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.ClearUrlVisited">
            <summary>
            Reset the memory of which URLs have been visited
            </summary>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.CopySelectionToClipboard">
            <summary>
            Copy a text and html representation of the selected rows onto the clipboard.
            </summary>
            <remarks>Be careful when using this with virtual lists. If the user has selected
            10,000,000 rows, this method will faithfully try to copy all of them to the clipboard.
            From the user's point of view, your program will appear to have hung.</remarks>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.CopyObjectsToClipboard(System.Collections.IList)">
            <summary>
            Copy a text and html representation of the given objects onto the clipboard.
            </summary>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.ObjectsToHtml(System.Collections.IList)">
            <summary>
            Return a html representation of the given objects
            </summary>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.DeselectAll">
            <summary>
            Deselect all rows in the listview
            </summary>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.GetNextItem(Fluent.OLVListItem)">
            <summary>
            Return the ListViewItem that appears immediately after the given item.
            If the given item is null, the first item in the list will be returned.
            Return null if the given item is the last item.
            </summary>
            <param name="itemToFind">The item that is before the item that is returned, or null</param>
            <returns>A ListViewItem</returns>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.GetLastItemInDisplayOrder">
            <summary>
            Return the last item in the order they are shown to the user.
            If the control is not grouped, the display order is the same as the
            sorted list order. But if the list is grouped, the display order is different.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.GetNthItemInDisplayOrder(System.Int32)">
            <summary>
            Return the n'th item (0-based) in the order they are shown to the user.
            If the control is not grouped, the display order is the same as the
            sorted list order. But if the list is grouped, the display order is different.
            </summary>
            <param name="n"></param>
            <returns></returns>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.GetDisplayOrderOfItemIndex(System.Int32)">
            <summary>
            Return the display index of the given listviewitem index.
            If the control is not grouped, the display order is the same as the
            sorted list order. But if the list is grouped, the display order is different.
            </summary>
            <param name="itemIndex"></param>
            <returns></returns>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.GetPreviousItem(Fluent.OLVListItem)">
            <summary>
            Return the ListViewItem that appears immediately before the given item.
            If the given item is null, the last item in the list will be returned.
            Return null if the given item is the first item.
            </summary>
            <param name="itemToFind">The item that is before the item that is returned</param>
            <returns>A ListViewItem</returns>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.InsertObjects(System.Int32,System.Collections.ICollection)">
             <summary>
             Insert the given collection of objects before the given position
             </summary>
             <param name="index">Where to insert the objects</param>
             <param name="modelObjects">The objects to be inserted</param>
             <remarks>
             <para>
             This operation only makes sense of non-sorted, non-grouped
             lists, since any subsequent sort/group operation will rearrange
             the list.
             </para>
             <para>This method only works on FluentListViews and FastFluentListViews.</para>
            </remarks>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.IsSelected(System.Object)">
            <summary>
            Return true if the row representing the given model is selected
            </summary>
            <param name="model">The model object to look for</param>
            <returns>Is the row selected</returns>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.IsUrlVisited(System.String)">
            <summary>
            Has the given URL been visited?
            </summary>
            <param name="url">The string to be consider</param>
            <returns>Has it been visited</returns>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.LowLevelScroll(System.Int32,System.Int32)">
            <summary>
            Scroll the ListView by the given deltas.
            </summary>
            <param name="dx">Horizontal delta</param>
            <param name="dy">Vertical delta</param>
        </member>
        <member name="P:Fluent.Lists.AdvancedListView.LowLevelScrollPosition">
            <summary>
            Return a point that represents the current horizontal and vertical scroll positions 
            </summary>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.MarkUrlVisited(System.String)">
            <summary>
            Remember that the given URL has been visited
            </summary>
            <param name="url">The url to be remembered</param>
            <remarks>This does not cause the control be redrawn</remarks>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.MoveObjects(System.Int32,System.Collections.ICollection)">
            <summary>
            Move the given collection of objects to the given index.
            </summary>
            <remarks>This operation only makes sense on non-grouped FluentListViews.</remarks>
            <param name="index"></param>
            <param name="modelObjects"></param>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.HitTest(System.Int32,System.Int32)">
            <summary>
            Calculate what item is under the given point?
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <returns></returns>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.LowLevelHitTest(System.Int32,System.Int32)">
            <summary>
            Perform a hit test using the Windows control's SUBITEMHITTEST message.
            This provides information about group hits that the standard ListView.HitTest() does not.
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <returns></returns>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.OlvHitTest(System.Int32,System.Int32)">
            <summary>
            What is under the given point? This takes the various parts of a cell into accout, including
            any custom parts that a custom renderer might use
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <returns>An information block about what is under the point</returns>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.CalculateStandardHitTest(Fluent.OlvListViewHitTestInfo,System.Int32,System.Int32)">
            <summary>
            Perform a hit test when the control is not owner drawn
            </summary>
            <param name="hti"></param>
            <param name="x"></param>
            <param name="y"></param>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.CalculateOwnerDrawnHitTest(Fluent.OlvListViewHitTestInfo,System.Int32,System.Int32)">
            <summary>
            Perform a hit test when the control is owner drawn. This hands off responsibility
            to the renderer.
            </summary>
            <param name="hti"></param>
            <param name="x"></param>
            <param name="y"></param>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.PauseAnimations(System.Boolean)">
            <summary>
            Pause (or unpause) all animations in the list
            </summary>
            <param name="isPause">true to pause, false to unpause</param>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.RebuildColumns">
            <summary>
            Rebuild the columns based upon its current view and column visibility settings
            </summary>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.RemoveObject(System.Object)">
            <summary>
            Remove the given model object from the ListView
            </summary>
            <param name="modelObject">The model to be removed</param>
            <remarks>See RemoveObjects() for more details
            <para>This method is thread-safe.</para>
            </remarks>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.RemoveObjects(System.Collections.ICollection)">
            <summary>
            Remove all of the given objects from the control.
            </summary>
            <param name="modelObjects">Collection of objects to be removed</param>
            <remarks>
            <para>Nulls and model objects that are not in the ListView are silently ignored.</para>
            <para>This method is thread-safe.</para>
            </remarks>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.SelectAll">
            <summary>
            Select all rows in the listview
            </summary>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.SetNativeBackgroundWatermark(System.Drawing.Image)">
            <summary>
            Set the given image to be fixed in the bottom right of the list view.
            This image will not scroll when the list view scrolls.
            </summary>
            <remarks>
            <para>
            This method uses ListView's native ability to display a background image.
            It has a few limitations: 
            </para>
            <list type="bullet">
            <item><description>It doesn't work well with owner drawn mode. In owner drawn mode, each cell draws itself,
            including its background, which covers the background image.</description></item>
            <item><description>It doesn't look very good when grid lines are enabled, since the grid lines are drawn over the image.</description></item>
            <item><description>It does not work at all on XP.</description></item>
            <item><description>Obviously, it doesn't look good when alternate row background colors are enabled.</description></item>
            </list>
            <para>
            If you can live with these limitations, native watermarks are quite neat. They are true backgrounds, not
            translucent overlays like the OverlayImage uses. They also have the decided advantage over overlays in that
            they work correctly even in MDI applications.
            </para>
            <para>Setting this clears any background image.</para>
            </remarks>
            <param name="image">The image to be drawn. If null, any existing image will be removed.</param>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.SetNativeBackgroundImage(System.Drawing.Image,System.Int32,System.Int32)">
            <summary>
            Set the given image to be background of the ListView so that it appears at the given
            percentage offsets within the list.
            </summary>
            <remarks>
            <para>This has the same limitations as described in <see cref="M:Fluent.Lists.AdvancedListView.SetNativeBackgroundWatermark(System.Drawing.Image)"/>. Make sure those limitations
            are understood before using the method.</para>
            <para>This is very similar to setting the <see cref="P:System.Windows.Forms.Control.BackgroundImage"/> property of the standard .NET ListView, except that the standard
            BackgroundImage does not handle images with transparent areas properly -- it renders transparent areas as black. This 
            method does not have that problem.</para>
            <para>Setting this clears any background watermark.</para>
            </remarks>
            <param name="image">The image to be drawn. If null, any existing image will be removed.</param>
            <param name="xOffset">The horizontal percentage where the image will be placed. 0 is absolute left, 100 is absolute right.</param>
            <param name="yOffset">The vertical percentage where the image will be placed.</param>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.SetNativeBackgroundTiledImage(System.Drawing.Image)">
            <summary>
            Set the given image to be the tiled background of the ListView.
            </summary>
            <remarks>
            <para>This has the same limitations as described in <see cref="M:Fluent.Lists.AdvancedListView.SetNativeBackgroundWatermark(System.Drawing.Image)"/> and <see cref="M:Fluent.Lists.AdvancedListView.SetNativeBackgroundImage(System.Drawing.Image,System.Int32,System.Int32)"/>.
            Make sure those limitations
            are understood before using the method.</para>
            </remarks>
            <param name="image">The image to be drawn. If null, any existing image will be removed.</param>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.SetObjects(System.Collections.IEnumerable)">
            <summary>
            Set the collection of objects that will be shown in this list view.
            </summary>
            <remark>This method can safely be called from background threads.</remark>
            <remarks>The list is updated immediately</remarks>
            <param name="collection">The objects to be displayed</param>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.SetObjects(System.Collections.IEnumerable,System.Boolean)">
            <summary>
            Set the collection of objects that will be shown in this list view.
            </summary>
            <remark>This method can safely be called from background threads.</remark>
            <remarks>The list is updated immediately</remarks>
            <param name="collection">The objects to be displayed</param>
            <param name="preserveState">Should the state of the list be preserved as far as is possible.</param>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.UpdateObject(System.Object)">
            <summary>
            Update the given model object into the ListView. The model will be added if it doesn't already exist.
            </summary>
            <param name="modelObject">The model to be updated</param>
            <remarks>
            <para>
            See <see cref="M:Fluent.Lists.AdvancedListView.RemoveObjects(System.Collections.ICollection)"/> for more details
            </para>
            <para>This method is thread-safe.</para>
            <para>This method will cause the list to be resorted.</para>
            <para>This method only works on FluentListViews and FastFluentListViews.</para>
            </remarks>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.UpdateObjects(System.Collections.ICollection)">
            <summary>
            Update the pre-existing models that are equal to the given objects. If any of the model doesn't
            already exist in the control, they will be added.
            </summary>
            <param name="modelObjects">Collection of objects to be updated/added</param>
            <remarks>
            <para>This method will cause the list to be resorted.</para>
            <para>Nulls are silently ignored.</para>
            <para>This method is thread-safe.</para>
            <para>This method only works on FluentListViews and FastFluentListViews.</para>
            </remarks>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.UpdateNotificationSubscriptions(System.Collections.IEnumerable)">
            <summary>
            Change any subscriptions to INotifyPropertyChanged events on our current
            model objects so that we no longer listen for events on the old models
            and do listen for events on the given collection.
            </summary>
            <remarks>This does nothing if UseNotifyPropertyChanged is false.</remarks>
            <param name="collection"></param>
        </member>
        <member name="P:Fluent.Lists.AdvancedListView.UseNotifyPropertyChanged">
            <summary>
            Gets or sets whether or not FluentListView should subscribe to INotifyPropertyChanged
            events on the model objects that it is given.
            </summary>
            <remarks>
            <para>
            This should be set before calling SetObjects(). If you set this to false,
            FluentListView will unsubscribe to all current model objects.
            </para>
            <para>If you set this to true on a virtual list, the FluentListView will 
            walk all the objects in the list trying to subscribe to change notifications.
            If you have 10,000,000 items in your virtual list, this may take some time.</para>
            </remarks>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.SubscribeNotifications(System.Collections.IEnumerable)">
            <summary>
            Subscribe to INotifyPropertyChanges on the given collection of objects.
            </summary>
            <param name="models"></param>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.UnsubscribeNotifications(System.Collections.IEnumerable)">
            <summary>
            Unsubscribe from INotifyPropertyChanges on the given collection of objects.
            If the given collection is null, unsubscribe from all current subscriptions
            </summary>
            <param name="models"></param>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.SaveState">
            <summary>
            Return a byte array that represents the current state of the FluentListView, such
            that the state can be restored by RestoreState()
            </summary>
            <remarks>
            <para>The state of an FluentListView includes the attributes that the user can modify:
            <list type="bullet">
            <item><description>current view (i.e. Details, Tile, Large Icon...)</description></item>
            <item><description>sort column and direction</description></item>
            <item><description>column order</description></item>
            <item><description>column widths</description></item>
            <item><description>column visibility</description></item>
            </list>
            </para>
            <para>
            It does not include selection or the scroll position.
            </para>
            </remarks>
            <returns>A byte array representing the state of the FluentListView</returns>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.RestoreState(System.Byte[])">
            <summary>
            Restore the state of the control from the given string, which must have been
            produced by SaveState()
            </summary>
            <param name="state">A byte array returned from SaveState()</param>
            <returns>Returns true if the state was restored</returns>
        </member>
        <member name="T:Fluent.Lists.AdvancedListView.FluentListViewState">
            <summary>
            Instances of this class are used to store the state of an FluentListView.
            </summary>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.HandleApplicationIdle(System.Object,System.EventArgs)">
            <summary>
            The application is idle. Trigger a SelectionChanged event.
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.HandleApplicationIdleResizeColumns(System.Object,System.EventArgs)">
            <summary>
            The application is idle. Handle the column resizing event.
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.HandleBeginScroll(System.Windows.Forms.Message@)">
            <summary>
            Handle the BeginScroll listview notification
            </summary>
            <param name="m"></param>
            <returns>True if the event was completely handled</returns>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.HandleEndScroll(System.Windows.Forms.Message@)">
            <summary>
            Handle the EndScroll listview notification
            </summary>
            <param name="m"></param>
            <returns>True if the event was completely handled</returns>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.HandleLinkClick(System.Windows.Forms.Message@)">
            <summary>
            Handle the LinkClick listview notification
            </summary>
            <param name="m"></param>
            <returns>True if the event was completely handled</returns>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.HandleCellToolTipShowing(System.Object,Fluent.ToolTipShowingEventArgs)">
            <summary>
            The cell tooltip control wants information about the tool tip that it should show.
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.HeaderToolTipShowingCallback(System.Object,Fluent.ToolTipShowingEventArgs)">
            <summary>
            Allow the HeaderControl to call back into HandleHeaderToolTipShowing without making that method public
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.HandleHeaderToolTipShowing(System.Object,Fluent.ToolTipShowingEventArgs)">
            <summary>
            The header tooltip control wants information about the tool tip that it should show.
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.HandleColumnClick(System.Object,System.Windows.Forms.ColumnClickEventArgs)">
            <summary>
            Event handler for the column click event
            </summary>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.WndProc(System.Windows.Forms.Message@)">
            <summary>
            Override the basic message pump for this control
            </summary>
            <param name="m"></param>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.HandleChar(System.Windows.Forms.Message@)">
            <summary>
            Handle the search for item m if possible.
            </summary>
            <param name="m">The m to be processed</param>
            <returns>bool to indicate if the msg has been handled</returns>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.HandleContextMenu(System.Windows.Forms.Message@)">
            <summary>
            The user wants to see the context menu.
            </summary>
            <param name="m">The windows m</param>
            <returns>A bool indicating if this m has been handled</returns>
            <remarks>
            We want to ignore context menu requests that are triggered by right clicks on the header
            </remarks>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.HandleCustomDraw(System.Windows.Forms.Message@)">
            <summary>
            Handle the Custom draw series of notifications
            </summary>
            <param name="m">The message</param>
            <returns>True if the message has been handled</returns>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.HandleDestroy(System.Windows.Forms.Message@)">
            <summary>
            Handle the underlying control being destroyed
            </summary>
            <param name="m"></param>
            <returns></returns>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.HandleFindItem(System.Windows.Forms.Message@)">
            <summary>
            Handle the search for item m if possible.
            </summary>
            <param name="m">The m to be processed</param>
            <returns>bool to indicate if the msg has been handled</returns>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.FindMatchingRow(System.String,System.Int32,System.Windows.Forms.SearchDirectionHint)">
            <summary>
            Find the first row after the given start in which the text value in the
            comparison column begins with the given text. The comparison column is column 0,
            unless IsSearchOnSortColumn is true, in which case the current sort column is used.
            </summary>
            <param name="text">The text to be prefix matched</param>
            <param name="start">The index of the first row to consider</param>
            <param name="direction">Which direction should be searched?</param>
            <returns>The index of the first row that matched, or -1</returns>
            <remarks>The text comparison is a case-insensitive, prefix match. The search will
            search the every row until a match is found, wrapping at the end if needed.</remarks>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.FindMatchInRange(System.String,System.Int32,System.Int32,Fluent.OLVColumn)">
            <summary>
            Find the first row in the given range of rows that prefix matches the string value of the given column.
            </summary>
            <param name="text"></param>
            <param name="first"></param>
            <param name="last"></param>
            <param name="column"></param>
            <returns>The index of the matched row, or -1</returns>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.HandleGroupInfo(System.Windows.Forms.Message@)">
            <summary>
            Handle the Group Info series of notifications
            </summary>
            <param name="m">The message</param>
            <returns>True if the message has been handled</returns>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.HandleKeyDown(System.Windows.Forms.Message@)">
            <summary>
            Handle a key down message
            </summary>
            <param name="m"></param>
            <returns>True if the msg has been handled</returns>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.ToggleSelectedRowCheckBoxes">
            <summary>
            Toggle the checkedness of the selected rows
            </summary>
            <remarks>
            <para>
            Actually, this doesn't actually toggle all rows. It toggles the first row, and
            all other rows get the check state of that first row. This is actually a much
            more useful behaviour.
            </para>
            <para>
            If no rows are selected, this method does nothing.
            </para>
            </remarks>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.HandleLButtonDown(System.Windows.Forms.Message@)">
            <summary>
            Catch the Left Button down event.
            </summary>
            <param name="m">The m to be processed</param>
            <returns>bool to indicate if the msg has been handled</returns>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.ProcessLButtonDown(Fluent.OlvListViewHitTestInfo)">
            <summary>
            Handle a left mouse down at the given hit test location
            </summary>
            <remarks>Subclasses can override this to do something unique</remarks>
            <param name="hti"></param>
            <returns>True if the message has been handled</returns>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.HandleLButtonUp(System.Windows.Forms.Message@)">
            <summary>
            Catch the Left Button up event.
            </summary>
            <param name="m">The m to be processed</param>
            <returns>bool to indicate if the msg has been handled</returns>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.TriggerGroupExpandCollapse(Fluent.OLVGroup)">
            <summary>
            Trigger a GroupExpandCollapse event and return true if the action was cancelled
            </summary>
            <param name="group"></param>
            <returns></returns>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.HandleRButtonDown(System.Windows.Forms.Message@)">
            <summary>
            Catch the Right Button down event.
            </summary>
            <param name="m">The m to be processed</param>
            <returns>bool to indicate if the msg has been handled</returns>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.ProcessRButtonDown(Fluent.OlvListViewHitTestInfo)">
            <summary>
            Handle a left mouse down at the given hit test location
            </summary>
            <remarks>Subclasses can override this to do something unique</remarks>
            <param name="hti"></param>
            <returns>True if the message has been handled</returns>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.HandleLButtonDoubleClick(System.Windows.Forms.Message@)">
            <summary>
            Catch the Left Button double click event.
            </summary>
            <param name="m">The m to be processed</param>
            <returns>bool to indicate if the msg has been handled</returns>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.ProcessLButtonDoubleClick(Fluent.OlvListViewHitTestInfo)">
            <summary>
            Handle a mouse double click at the given hit test location
            </summary>
            <remarks>Subclasses can override this to do something unique</remarks>
            <param name="hti"></param>
            <returns>True if the message has been handled</returns>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.HandleRButtonDoubleClick(System.Windows.Forms.Message@)">
            <summary>
            Catch the right Button double click event.
            </summary>
            <param name="m">The m to be processed</param>
            <returns>bool to indicate if the msg has been handled</returns>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.ProcessRButtonDoubleClick(Fluent.OlvListViewHitTestInfo)">
            <summary>
            Handle a right mouse double click at the given hit test location
            </summary>
            <remarks>Subclasses can override this to do something unique</remarks>
            <param name="hti"></param>
            <returns>True if the message has been handled</returns>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.HandleMouseMove(System.Windows.Forms.Message@)">
            <summary>
            Catch the MouseMove event.
            </summary>
            <param name="m">The m to be processed</param>
            <returns>bool to indicate if the msg has been handled</returns>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.HandleReflectNotify(System.Windows.Forms.Message@)">
            <summary>
            Handle notifications that have been reflected back from the parent window
            </summary>
            <param name="m">The m to be processed</param>
            <returns>bool to indicate if the msg has been handled</returns>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.HandleNotify(System.Windows.Forms.Message@)">
            <summary>
            In the notification messages, we handle attempts to change the width of our columns
            </summary>
            <param name="m">The m to be processed</param>
            <returns>bool to indicate if the msg has been handled</returns>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.CreateCellToolTip">
            <summary>
            Create a ToolTipControl to manage the tooltip control used by the listview control
            </summary>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.UpdateCellToolTipHandle">
            <summary>
            Update the handle used by our cell tooltip to be the tooltip used by
            the underlying Windows listview control.
            </summary>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.HandlePaint(System.Windows.Forms.Message@)">
            <summary>
            Handle the WM_PAINT event
            </summary>
            <param name="m"></param>
            <returns>Return true if the msg has been handled and nothing further should be done</returns>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.HandlePrePaint">
            <summary>
            Perform any steps needed before painting the control
            </summary>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.HandlePostPaint">
            <summary>
            Perform any steps needed after painting the control
            </summary>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.HandleWindowPosChanging(System.Windows.Forms.Message@)">
            <summary>
            Handle the window position changing.
            </summary>
            <param name="m">The m to be processed</param>
            <returns>bool to indicate if the msg has been handled</returns>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.HandleHeaderRightClick(System.Int32)">
            <summary>
            The user has right clicked on the column headers. Do whatever is required
            </summary>
            <returns>Return true if this event has been handle</returns>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.ShowHeaderRightClickMenu(System.Int32,System.Drawing.Point)">
            <summary>
            Show a menu that is appropriate when the given column header is clicked.
            </summary>
            <param name="columnIndex">The index of the header that was clicked. This
            can be -1, indicating that the header was clicked outside of a column</param>
            <param name="pt">Where should the menu be shown</param>
            <returns>True if a menu was displayed</returns>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.MakeHeaderRightClickMenu(System.Int32)">
            <summary>
            Create the menu that should be displayed when the user right clicks
            on the given column header.
            </summary>
            <param name="columnIndex">Index of the column that was right clicked.
            This can be negative, which indicates a click outside of any header.</param>
            <returns>The toolstrip that should be displayed</returns>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.HandleHeaderRightClick">
            <summary>
            The user has right clicked on the column headers. Do whatever is required
            </summary>
            <returns>Return true if this event has been handle</returns>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.ShowColumnSelectMenu(System.Drawing.Point)">
            <summary>
            Show a popup menu at the given point which will allow the user to choose which columns
            are visible on this listview
            </summary>
            <param name="pt">Where should the menu be placed</param>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.ShowColumnCommandMenu(System.Int32,System.Drawing.Point)">
            <summary>
            Show a popup menu at the given point which will allow the user to choose which columns
            are visible on this listview
            </summary>
            <param name="columnIndex"></param>
            <param name="pt">Where should the menu be placed</param>
        </member>
        <member name="P:Fluent.Lists.AdvancedListView.MenuLabelSortAscending">
            <summary>
            Gets or set the text to be used for the sorting ascending command
            </summary>
        </member>
        <member name="P:Fluent.Lists.AdvancedListView.MenuLabelSortDescending">
            <summary>
            
            </summary>
        </member>
        <member name="P:Fluent.Lists.AdvancedListView.MenuLabelGroupBy">
            <summary>
            
            </summary>
        </member>
        <member name="P:Fluent.Lists.AdvancedListView.MenuLabelLockGroupingOn">
            <summary>
            
            </summary>
        </member>
        <member name="P:Fluent.Lists.AdvancedListView.MenuLabelUnlockGroupingOn">
            <summary>
            
            </summary>
        </member>
        <member name="P:Fluent.Lists.AdvancedListView.MenuLabelTurnOffGroups">
            <summary>
            
            </summary>
        </member>
        <member name="P:Fluent.Lists.AdvancedListView.MenuLabelUnsort">
            <summary>
            
            </summary>
        </member>
        <member name="P:Fluent.Lists.AdvancedListView.MenuLabelColumns">
            <summary>
            
            </summary>
        </member>
        <member name="P:Fluent.Lists.AdvancedListView.MenuLabelSelectColumns">
            <summary>
            
            </summary>
        </member>
        <member name="F:Fluent.Lists.AdvancedListView.SortAscendingImage">
            <summary>
            Gets or sets the image that will be place next to the Sort Ascending command
            </summary>
        </member>
        <member name="F:Fluent.Lists.AdvancedListView.SortDescendingImage">
            <summary>
            Gets or sets the image that will be placed next to the Sort Descending command
            </summary>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.MakeColumnCommandMenu(System.Windows.Forms.ToolStripDropDown,System.Int32)">
            <summary>
            Append the column selection menu items to the given menu strip.
            </summary>
            <param name="strip">The menu to which the items will be added.</param>
            <param name="columnIndex"></param>
            <returns>Return the menu to which the items were added</returns>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.MakeColumnSelectMenu(System.Windows.Forms.ToolStripDropDown)">
            <summary>
            Append the column selection menu items to the given menu strip.
            </summary>
            <param name="strip">The menu to which the items will be added.</param>
            <returns>Return the menu to which the items were added</returns>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.AddItemsToColumnSelectMenu(System.Windows.Forms.ToolStripItemCollection)">
            <summary>
            Create the menu items that will allow columns to be choosen and add them to the 
            given collection
            </summary>
            <param name="items"></param>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.MakeFilteringMenu(System.Windows.Forms.ToolStripDropDown,System.Int32)">
            <summary>
            Create a Filtering menu
            </summary>
            <param name="strip"></param>
            <param name="columnIndex"></param>
            <returns></returns>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.OnColumnReordered(System.Windows.Forms.ColumnReorderedEventArgs)">
            <summary>
            Override the OnColumnReordered method to do what we want
            </summary>
            <param name="e"></param>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.HandleColumnWidthChanging(System.Object,System.Windows.Forms.ColumnWidthChangingEventArgs)">
            <summary>
            When the column widths are changing, resize the space filling columns
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.HandleColumnWidthChanged(System.Object,System.Windows.Forms.ColumnWidthChangedEventArgs)">
            <summary>
            When the column widths change, resize the space filling columns
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.HandleLayout(System.Object,System.Windows.Forms.LayoutEventArgs)">
            <summary>
            When the size of the control changes, we have to resize our space filling columns.
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.ResizeFreeSpaceFillingColumns">
            <summary>
            Resize our space filling columns so they fill any unoccupied width in the control
            </summary>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.ResizeFreeSpaceFillingColumns(System.Int32)">
            <summary>
            Resize our space filling columns so they fill any unoccupied width in the control
            </summary>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.CheckAll">
            <summary>
            Check all rows
            </summary>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.CheckHeaderCheckBox(Fluent.OLVColumn)">
            <summary>
            Check the checkbox in the given column header
            </summary>
            <remarks>If the given columns header check box is linked to the cell check boxes,
            then checkboxes in all cells will also be checked.</remarks>
            <param name="column"></param>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.CheckIndeterminateHeaderCheckBox(Fluent.OLVColumn)">
            <summary>
            Mark the checkbox in the given column header as having an indeterminate value
            </summary>
            <param name="column"></param>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.CheckIndeterminateObject(System.Object)">
            <summary>
            Mark the given object as indeterminate check state
            </summary>
            <param name="modelObject">The model object to be marked indeterminate</param>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.CheckObject(System.Object)">
            <summary>
            Mark the given object as checked in the list
            </summary>
            <param name="modelObject">The model object to be checked</param>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.CheckObjects(System.Collections.IEnumerable)">
            <summary>
            Mark the given objects as checked in the list
            </summary>
            <param name="modelObjects">The model object to be checked</param>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.CheckSubItem(System.Object,Fluent.OLVColumn)">
            <summary>
            Put a check into the check box at the given cell
            </summary>
            <param name="rowObject"></param>
            <param name="column"></param>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.CheckIndeterminateSubItem(System.Object,Fluent.OLVColumn)">
            <summary>
            Put an indeterminate check into the check box at the given cell
            </summary>
            <param name="rowObject"></param>
            <param name="column"></param>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.IsChecked(System.Object)">
            <summary>
            Return true of the given object is checked
            </summary>
            <param name="modelObject">The model object whose checkedness is returned</param>
            <returns>Is the given object checked?</returns>
            <remarks>If the given object is not in the list, this method returns false.</remarks>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.IsCheckedIndeterminate(System.Object)">
            <summary>
            Return true of the given object is indeterminately checked
            </summary>
            <param name="modelObject">The model object whose checkedness is returned</param>
            <returns>Is the given object indeterminately checked?</returns>
            <remarks>If the given object is not in the list, this method returns false.</remarks>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.IsSubItemChecked(System.Object,Fluent.OLVColumn)">
            <summary>
            Is there a check at the check box at the given cell
            </summary>
            <param name="rowObject"></param>
            <param name="column"></param>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.GetCheckState(System.Object)">
            <summary>
            Get the checkedness of an object from the model. Returning null means the
            model does not know and the value from the control will be used.
            </summary>
            <param name="modelObject"></param>
            <returns></returns>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.PutCheckState(System.Object,System.Windows.Forms.CheckState)">
            <summary>
            Record the change of checkstate for the given object in the model.
            This does not update the UI -- only the model
            </summary>
            <param name="modelObject"></param>
            <param name="state"></param>
            <returns>The check state that was recorded and that should be used to update
            the control.</returns>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.SetObjectCheckedness(System.Object,System.Windows.Forms.CheckState)">
            <summary>
            Change the check state of the given object to be the given state.
            </summary>
            <remarks>
            If the given model object isn't in the list, we still try to remember
            its state, in case it is referenced in the future.</remarks>
            <param name="modelObject"></param>
            <param name="state"></param>
            <returns>True if the checkedness of the model changed</returns>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.ToggleCheckObject(System.Object)">
            <summary>
            Toggle the checkedness of the given object. A checked object becomes
            unchecked; an unchecked or indeterminate object becomes checked.
            If the list has tristate checkboxes, the order is:
               unchecked -> checked -> indeterminate -> unchecked ...
            </summary>
            <param name="modelObject">The model object to be checked</param>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.ToggleHeaderCheckBox(Fluent.OLVColumn)">
            <summary>
            Toggle the checkbox in the header of the given column
            </summary>
            <remarks>Obviously, this is only useful if the column actually has a header checkbox.</remarks>
            <param name="column"></param>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.ToggleSubItemCheckBox(System.Object,Fluent.OLVColumn)">
            <summary>
            Toggle the check at the check box of the given cell
            </summary>
            <param name="rowObject"></param>
            <param name="column"></param>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.UncheckAll">
            <summary>
            Uncheck all rows
            </summary>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.UncheckObject(System.Object)">
            <summary>
            Mark the given object as unchecked in the list
            </summary>
            <param name="modelObject">The model object to be unchecked</param>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.UncheckObjects(System.Collections.IEnumerable)">
            <summary>
            Mark the given objects as unchecked in the list
            </summary>
            <param name="modelObjects">The model object to be checked</param>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.UncheckHeaderCheckBox(Fluent.OLVColumn)">
            <summary>
            Uncheck the checkbox in the given column header
            </summary>
            <param name="column"></param>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.UncheckSubItem(System.Object,Fluent.OLVColumn)">
            <summary>
            Uncheck the check at the given cell
            </summary>
            <param name="rowObject"></param>
            <param name="column"></param>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.GetColumn(System.Int32)">
            <summary>
            Return the column at the given index
            </summary>
            <param name="index">Index of the column to be returned</param>
            <returns>An OLVColumn</returns>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.GetColumn(System.String)">
            <summary>
            Return the column at the given title.
            </summary>
            <param name="name">Name of the column to be returned</param>
            <returns>An OLVColumn</returns>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.GetFilteredColumns(System.Windows.Forms.View)">
            <summary>
            Return a collection of columns that are visible to the given view.
            Only Tile and Details have columns; all other views have 0 columns.
            </summary>
            <param name="view">Which view are the columns being calculate for?</param>
            <returns>A list of columns</returns>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.GetItemCount">
            <summary>
            Return the number of items in the list
            </summary>
            <returns>the number of items in the list</returns>
            <remarks>If a filter is installed, this will return the number of items that match the filter.</remarks>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.GetItem(System.Int32)">
            <summary>
            Return the item at the given index
            </summary>
            <param name="index">Index of the item to be returned</param>
            <returns>An OLVListItem</returns>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.GetModelObject(System.Int32)">
            <summary>
            Return the model object at the given index
            </summary>
            <param name="index">Index of the model object to be returned</param>
            <returns>A model object</returns>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.GetItemAt(System.Int32,System.Int32,Fluent.OLVColumn@)">
            <summary>
            Find the item and column that are under the given co-ords
            </summary>
            <param name="x">X co-ord</param>
            <param name="y">Y co-ord</param>
            <param name="hitColumn">The column under the given point</param>
            <returns>The item under the given point. Can be null.</returns>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.GetSubItem(System.Int32,System.Int32)">
            <summary>
            Return the sub item at the given index/column
            </summary>
            <param name="index">Index of the item to be returned</param>
            <param name="columnIndex">Index of the subitem to be returned</param>
            <returns>An OLVListSubItem</returns>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.EnsureGroupVisible(System.Windows.Forms.ListViewGroup)">
            <summary>
            Scroll the listview so that the given group is at the top.
            </summary>
            <param name="lvg">The group to be revealed</param>
            <remarks><para>
            If the group is already visible, the list will still be scrolled to move
            the group to the top, if that is possible.
            </para>
            <para>This only works when the list is showing groups (obviously).</para>
            <para>This does not work on virtual lists, since virtual lists don't use ListViewGroups
            for grouping. Use <see cref="M:Fluent.Lists.VirtualFluentListView.EnsureNthGroupVisible(System.Int32)"/> instead.</para>
            </remarks>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.EnsureModelVisible(System.Object)">
            <summary>
            Ensure that the given model object is visible
            </summary>
            <param name="modelObject">The model object to be revealed</param>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.GetSelectedObject">
            <summary>
            Return the model object of the row that is selected or null if there is no selection or more than one selection
            </summary>
            <returns>Model object or null</returns>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.GetSelectedObjects">
            <summary>
            Return the model objects of the rows that are selected or an empty collection if there is no selection
            </summary>
            <returns>ArrayList</returns>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.GetCheckedObject">
            <summary>
            Return the model object of the row that is checked or null if no row is checked
            or more than one row is checked
            </summary>
            <returns>Model object or null</returns>
            <remarks>Use CheckedObject property instead of this method</remarks>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.GetCheckedObjects">
            <summary>
            Get the collection of model objects that are checked.
            </summary>
            <remarks>Use CheckedObjects property instead of this method</remarks>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.IndexOf(System.Object)">
            <summary>
            Find the given model object within the listview and return its index
            </summary>
            <param name="modelObject">The model object to be found</param>
            <returns>The index of the object. -1 means the object was not present</returns>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.RefreshItem(Fluent.OLVListItem)">
            <summary>
            Rebuild the given ListViewItem with the data from its associated model.
            </summary>
            <remarks>This method does not resort or regroup the view. It simply updates
            the displayed data of the given item</remarks>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.RefreshObject(System.Object)">
            <summary>
            Rebuild the data on the row that is showing the given object.
            </summary>
            <remarks>
            <para>
            This method does not resort or regroup the view.
            </para>
            <para>
            The given object is *not* used as the source of data for the rebuild.
            It is only used to locate the matching model in the <see cref="P:Fluent.Lists.AdvancedListView.Objects"/> collection,
            then that matching model is used as the data source. This distinction is
            only important in model classes that have overridden the Equals() method.
            </para>
            <para>
            If you want the given model object to replace the pre-existing model,
            use <see cref="M:Fluent.Lists.AdvancedListView.UpdateObject(System.Object)"/>. 
            </para>
            </remarks>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.RefreshObjects(System.Collections.IList)">
            <summary>
            Update the rows that are showing the given objects
            </summary>
            <remarks>
            <para>This method does not resort or regroup the view.</para>
            <para>This method can safely be called from background threads.</para>
            </remarks>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.RefreshSelectedObjects">
            <summary>
            Update the rows that are selected
            </summary>
            <remarks>This method does not resort or regroup the view.</remarks>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.SelectObject(System.Object)">
            <summary>
            Select the row that is displaying the given model object, in addition to any current selection.
            </summary>
            <param name="modelObject">The object to be selected</param>
            <remarks>Use the <see cref="P:Fluent.Lists.AdvancedListView.SelectedObject"/> property to deselect all other rows</remarks>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.SelectObject(System.Object,System.Boolean)">
            <summary>
            Select the row that is displaying the given model object, in addition to any current selection.
            </summary>
            <param name="modelObject">The object to be selected</param>
            <param name="setFocus">Should the object be focused as well?</param>
            <remarks>Use the <see cref="P:Fluent.Lists.AdvancedListView.SelectedObject"/> property to deselect all other rows</remarks>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.SelectObjects(System.Collections.IList)">
            <summary>
            Select the rows that is displaying any of the given model object. All other rows are deselected.
            </summary>
            <param name="modelObjects">A collection of model objects</param>
        </member>
        <member name="P:Fluent.Lists.AdvancedListView.Frozen">
            <summary>
            Get or set whether or not the listview is frozen. When the listview is
            frozen, it will not update itself.
            </summary>
            <remarks><para>The Frozen property is similar to the methods Freeze()/Unfreeze()
            except that setting Frozen property to false immediately unfreezes the control
            regardless of the number of Freeze() calls outstanding.</para></remarks>
            <example>objectListView1.Frozen = false; // unfreeze the control now!
            </example>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.Freeze">
            <summary>
            Freeze the listview so that it no longer updates itself.
            </summary>
            <remarks>Freeze()/Unfreeze() calls nest correctly</remarks>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.Unfreeze">
            <summary>
            Unfreeze the listview. If this call is the outermost Unfreeze(),
            the contents of the listview will be rebuilt.
            </summary>
            <remarks>Freeze()/Unfreeze() calls nest correctly</remarks>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.DoFreeze">
            <summary>
            Do the actual work required when the listview is frozen
            </summary>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.DoUnfreeze">
            <summary>
            Do the actual work required when the listview is unfrozen
            </summary>
        </member>
        <member name="P:Fluent.Lists.AdvancedListView.SelectionEventsSuspended">
            <summary>
            Returns true if selection events are currently suspended.
            While selection events are suspended, neither SelectedIndexChanged
            or SelectionChanged events will be raised.
            </summary>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.SuspendSelectionEvents">
            <summary>
            Suspend selection events until a matching ResumeSelectionEvents()
            is called.
            </summary>
            <remarks>Calls to this method nest correctly. Every call to SuspendSelectionEvents()
            must have a matching ResumeSelectionEvents().</remarks>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.ResumeSelectionEvents">
            <summary>
            Resume raising selection events.
            </summary>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.SuspendSelectionEventsDuring">
            <summary>
            Returns a disposable that will disable selection events
            during a using() block.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Fluent.Lists.AdvancedListView.SuspendSelectionDisposable">
            <summary>
            Implementation only class that suspends and resumes selection
            events on instance creation and disposal.
            </summary>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.Sort">
            <summary>
            Sort the items by the last sort column and order
            </summary>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.Sort(System.String)">
            <summary>
            Sort the items in the list view by the values in the given column and the last sort order
            </summary>
            <param name="columnToSortName">The name of the column whose values will be used for the sorting</param>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.Sort(System.Int32)">
            <summary>
            Sort the items in the list view by the values in the given column and the last sort order
            </summary>
            <param name="columnToSortIndex">The index of the column whose values will be used for the sorting</param>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.Sort(Fluent.OLVColumn)">
            <summary>
            Sort the items in the list view by the values in the given column and the last sort order
            </summary>
            <param name="columnToSort">The column whose values will be used for the sorting</param>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.Sort(Fluent.OLVColumn,System.Windows.Forms.SortOrder)">
            <summary>
            Sort the items in the list view by the values in the given column and by the given order.
            </summary>
            <param name="columnToSort">The column whose values will be used for the sorting.
            If null, the first column will be used.</param>
            <param name="order">The ordering to be used for sorting. If this is None,
            this.Sorting and then SortOrder.Ascending will be used</param>
            <remarks>If ShowGroups is true, the rows will be grouped by the given column.
            If AlwaysGroupsByColumn is not null, the rows will be grouped by that column,
            and the rows within each group will be sorted by the given column.</remarks>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.ShowSortIndicator">
            <summary>
            Put a sort indicator next to the text of the sort column
            </summary>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.ShowSortIndicator(Fluent.OLVColumn,System.Windows.Forms.SortOrder)">
            <summary>
            Put a sort indicator next to the text of the given given column
            </summary>
            <param name="columnToSort">The column to be marked</param>
            <param name="sortOrder">The sort order in effect on that column</param>
        </member>
        <member name="F:Fluent.Lists.AdvancedListView.SORT_INDICATOR_UP_KEY">
            <summary>
            The name of the image used when a column is sorted ascending
            </summary>
            <remarks>This image is only used on pre-XP systems. System images are used for XP and later</remarks>
        </member>
        <member name="F:Fluent.Lists.AdvancedListView.SORT_INDICATOR_DOWN_KEY">
            <summary>
            The name of the image used when a column is sorted descending
            </summary>
            <remarks>This image is only used on pre-XP systems. System images are used for XP and later</remarks>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.MakeSortIndicatorImages">
            <summary>
            If the sort indicator images don't already exist, this method will make and install them
            </summary>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.Unsort">
            <summary>
            Remove any sorting and revert to the given order of the model objects
            </summary>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.CreateGroups(System.Collections.Generic.IEnumerable{Fluent.OLVGroup})">
            <summary>
            Do the actual work of creating the given list of groups
            </summary>
            <param name="groups"></param>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.CorrectSubItemColors(System.Windows.Forms.ListViewItem)">
            <summary>
            For some reason, UseItemStyleForSubItems doesn't work for the colors
            when owner drawing the list, so we have to specifically give each subitem
            the desired colors
            </summary>
            <param name="olvi">The item whose subitems are to be corrected</param>
            <remarks>Cells drawn via BaseRenderer don't need this, but it is needed
            when an owner drawn cell uses DrawDefault=true</remarks>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.FillInValues(Fluent.OLVListItem,System.Object)">
            <summary>
            Fill in the given OLVListItem with values of the given row
            </summary>
            <param name="lvi">the OLVListItem that is to be stuff with values</param>
            <param name="rowObject">the model object from which values will be taken</param>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.ForceSubItemImagesExStyle">
            <summary>
            Make sure the ListView has the extended style that says to display subitem images.
            </summary>
            <remarks>This method must be called after any .NET call that update the extended styles
            since they seem to erase this setting.</remarks>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.GetActualImageIndex(System.Object)">
            <summary>
            Convert the given image selector to an index into our image list.
            Return -1 if that's not possible
            </summary>
            <param name="imageSelector"></param>
            <returns>Index of the image in the imageList, or -1</returns>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.GetHeaderToolTip(System.Int32)">
            <summary>
            Return the tooltip that should be shown when the mouse is hovered over the given column
            </summary>
            <param name="columnIndex">The column index whose tool tip is to be fetched</param>
            <returns>A string or null if no tool tip is to be shown</returns>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.GetCellToolTip(System.Int32,System.Int32)">
            <summary>
            Return the tooltip that should be shown when the mouse is hovered over the given cell
            </summary>
            <param name="columnIndex">The column index whose tool tip is to be fetched</param>
            <param name="rowIndex">The row index whose tool tip is to be fetched</param>
            <returns>A string or null if no tool tip is to be shown</returns>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.ModelToItem(System.Object)">
            <summary>
            Return the OLVListItem that displays the given model object
            </summary>
            <param name="modelObject">The modelObject whose item is to be found</param>
            <returns>The OLVListItem that displays the model, or null</returns>
            <remarks>This method has O(n) performance.</remarks>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.PostProcessRows">
            <summary>
            Do the work required after the items in a listview have been created
            </summary>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.PostProcessOneRow(System.Int32,System.Int32,Fluent.OLVListItem)">
            <summary>
            Do the work required after one item in a listview have been created
            </summary>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.PrepareAlternateBackColors">
             <summary>
             Prepare the listview to show alternate row backcolors
             </summary>
             <remarks>We cannot rely on lvi.Index in this method.
             In a straight list, lvi.Index is the display index, and can be used to determine
             whether the row should be colored. But when organised by groups, lvi.Index is not
             useable because it still refers to the position in the overall list, not the display order.
            </remarks>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.SetAllSubItemImages">
            <summary>
            Setup all subitem images on all rows
            </summary>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.SetSubItemImages(System.Int32,Fluent.OLVListItem)">
            <summary>
            Tell the underlying list control which images to show against the subitems
            </summary>
            <param name="rowIndex">the index at which the item occurs</param>
            <param name="item">the item whose subitems are to be set</param>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.SetSubItemImages(System.Int32,Fluent.OLVListItem,System.Boolean)">
            <summary>
            Tell the underlying list control which images to show against the subitems
            </summary>
            <param name="rowIndex">the index at which the item occurs</param>
            <param name="item">the item whose subitems are to be set</param>
            <param name="shouldClearImages">will existing images be cleared if no new image is provided?</param>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.SetSubItemImage(System.Int32,System.Int32,Fluent.OLVListSubItem,System.Boolean)">
            <summary>
            Set the subitem image natively
            </summary>
            <param name="rowIndex"></param>
            <param name="subItemIndex"></param>
            <param name="subItem"></param>
            <param name="shouldClearImages"></param>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.TakeOwnershipOfObjects">
            <summary>
            Take ownership of the 'objects' collection. This separats our collection from the source.
            </summary>
            <remarks>
            <para>
            This method
            separates the 'objects' instance variable from its source, so that any AddObject/RemoveObject
            calls will modify our collection and not the original colleciton.
            </para>
            <para>
            This method has the intentional side-effect of converting our list of objects to an ArrayList.
            </para>
            </remarks>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.TriggerFormatRowEvent(System.Int32,System.Int32,Fluent.OLVListItem)">
            <summary>
            Trigger FormatRow and possibly FormatCell events for the given item
            </summary>
            <param name="rowIndex"></param>
            <param name="displayIndex"></param>
            <param name="olvi"></param>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.TriggerFormatCellEvents(System.Int32,System.Int32,Fluent.OLVListItem)">
            <summary>
            Trigger FormatCell events for the given item
            </summary>
            <param name="rowIndex"></param>
            <param name="displayIndex"></param>
            <param name="olvi"></param>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.Reset">
            <summary>
            Make the list forget everything -- all rows and all columns
            </summary>
            <remarks>Use <see cref="M:Fluent.Lists.AdvancedListView.ClearObjects"/> if you want to remove just the rows.</remarks>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.SetupBaseImageList">
            <summary>
            Update our externally visible image list so it holds the same images as our shadow list, but sized correctly
            </summary>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.MakeResizedImageList(System.Int32,System.Int32,System.Windows.Forms.ImageList)">
            <summary>
            Return a copy of the given source image list, where each image has been resized to be height x height in size.
            If source is null, an empty image list of the given size is returned
            </summary>
            <param name="width">Height and width of the new images</param>
            <param name="height">Height and width of the new images</param>
            <param name="source">Source of the images (can be null)</param>
            <returns>A new image list</returns>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.MakeResizedImage(System.Int32,System.Int32,System.Drawing.Image,System.Drawing.Color)">
            <summary>
            Return a bitmap of the given height x height, which shows the given image, centred.
            </summary>
            <param name="width">Height and width of new bitmap</param>
            <param name="height">Height and width of new bitmap</param>
            <param name="image">Image to be centred</param>
            <param name="transparent">The background color</param>
            <returns>A new bitmap</returns>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.InitializeStateImageList">
            <summary>
            Initialize the state image list with the required checkbox images
            </summary>
        </member>
        <member name="F:Fluent.Lists.AdvancedListView.CHECKED_KEY">
            <summary>
            The name of the image used when a check box is checked
            </summary>
        </member>
        <member name="F:Fluent.Lists.AdvancedListView.UNCHECKED_KEY">
            <summary>
            The name of the image used when a check box is unchecked
            </summary>
        </member>
        <member name="F:Fluent.Lists.AdvancedListView.INDETERMINATE_KEY">
            <summary>
            The name of the image used when a check box is Indeterminate
            </summary>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.SetupSubItemCheckBoxes">
            <summary>
            Setup this control so it can display check boxes on subitems
            (or primary checkboxes in virtual mode)
            </summary>
            <remarks>This gives the ListView a small image list, if it doesn't already have one.</remarks>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.InitializeSubItemCheckBoxImages">
            <summary>
            Make sure the small image list for this control has checkbox images 
            (used for sub-item checkboxes).
            </summary>
            <remarks>
            <para>
            This gives the ListView a small image list, if it doesn't already have one.
            </para>
            <para>
            FluentListView has to manage checkboxes on subitems separate from the checkboxes on each row.
            The underlying ListView knows about the per-row checkboxes, and to make them work, OLV has to 
            correctly configure the StateImageList. However, the ListView cannot do checkboxes in subitems,
            so FluentListView has to handle them in a differnt fashion. So, per-row checkboxes are controlled
            by images in the StateImageList, but per-cell checkboxes are handled by images in the SmallImageList.
            </para>
            </remarks>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.OnDrawColumnHeader(System.Windows.Forms.DrawListViewColumnHeaderEventArgs)">
            <summary>
            Owner draw the column header
            </summary>
            <param name="e"></param>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.OnDrawItem(System.Windows.Forms.DrawListViewItemEventArgs)">
            <summary>
            Owner draw the item
            </summary>
            <param name="e"></param>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.OnDrawSubItem(System.Windows.Forms.DrawListViewSubItemEventArgs)">
            <summary>
            Owner draw a single subitem
            </summary>
            <param name="e"></param>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.OnMouseDown(System.Windows.Forms.MouseEventArgs)">
            <summary>
            We need the click count in the mouse up event, but that is always 1.
            So we have to remember the click count from the preceding mouse down event.
            </summary>
            <param name="e"></param>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.OnMouseLeave(System.EventArgs)">
            <summary>
            When the mouse leaves the control, remove any hot item highlighting
            </summary>
            <param name="e"></param>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.OnMouseMove(System.Windows.Forms.MouseEventArgs)">
            <summary>
            When the mouse moves, we might need to change the hot item.
            </summary>
            <param name="e"></param>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.OnMouseUp(System.Windows.Forms.MouseEventArgs)">
            <summary>
            Check to see if we need to start editing a cell
            </summary>
            <param name="e"></param>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.ProcessHyperlinkClicked(Fluent.CellClickEventArgs)">
            <summary>
            Tell the world that a hyperlink was clicked and if the event isn't handled,
            do the default processing.
            </summary>
            <param name="e"></param>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.StandardHyperlinkClickedProcessing(Fluent.HyperlinkClickedEventArgs)">
            <summary>
            Do the default processing for a hyperlink clicked event, which
            is to try and open the url.
            </summary>
            <param name="args"></param>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.OnRightMouseUp(System.Windows.Forms.MouseEventArgs)">
            <summary>
            The user right clicked on the control
            </summary>
            <param name="e"></param>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.OnSelectedIndexChanged(System.EventArgs)">
            <summary>
            This method is called every time a row is selected or deselected. This can be
            a pain if the user shift-clicks 100 rows. We override this method so we can
            trigger one event for any number of select/deselects that come from one user action
            </summary>
            <param name="e"></param>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.OnHandleCreated(System.EventArgs)">
            <summary>
            Called when the handle of the underlying control is created
            </summary>
            <param name="e"></param>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.OnControlCreated">
            <summary>
            This method is called after the control has been fully created.
            </summary>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.ShouldStartCellEdit(System.Windows.Forms.MouseEventArgs)">
            <summary>
            Should we start editing the cell in response to the given mouse button event?
            </summary>
            <param name="e"></param>
            <returns></returns>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.ProcessDialogKey(System.Windows.Forms.Keys)">
            <summary>
            Handle a key press on this control. We specifically look for F2 which edits the primary column,
            or a Tab character during an edit operation, which tries to start editing on the next (or previous) cell.
            </summary>
            <param name="keyData"></param>
            <returns></returns>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.EditModel(System.Object)">
            <summary>
            Start an editing operation on the first editable column of the given model.
            </summary>
            <param name="rowModel"></param>
            <remarks>
            <para>
            If the model doesn't exist, or there are no editable columns, this method
            will do nothing.</para>
            <para>
            This will start an edit operation regardless of CellActivationMode.
            </para>
            </remarks>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.EditSubItem(Fluent.OLVListItem,System.Int32)">
            <summary>
            Begin an edit operation on the given cell.
            </summary>
            <remarks>This performs various sanity checks and passes off the real work to StartCellEdit().</remarks>
            <param name="item">The row to be edited</param>
            <param name="subItemIndex">The index of the cell to be edited</param>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.StartCellEdit(Fluent.OLVListItem,System.Int32)">
            <summary>
            Really start an edit operation on a given cell. The parameters are assumed to be sane.
            </summary>
            <param name="item">The row to be edited</param>
            <param name="subItemIndex">The index of the cell to be edited</param>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.CalculateCellEditorBounds(Fluent.OLVListItem,System.Int32,System.Drawing.Size)">
            <summary>
            Calculate the bounds of the edit control for the given item/column
            </summary>
            <param name="item"></param>
            <param name="subItemIndex"></param>
            <param name="preferredSize"> </param>
            <returns></returns>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.CalculateCellEditorBoundsOwnerDrawn(Fluent.OLVListItem,System.Int32,System.Drawing.Rectangle,System.Drawing.Size)">
            <summary>
            Calculate the bounds of the edit control for the given item/column, when the listview
            is being owner drawn.
            </summary>
            <param name="item"></param>
            <param name="subItemIndex"></param>
            <param name="r"></param>
            <param name="preferredSize"> </param>
            <returns>A rectangle that is the bounds of the cell editor</returns>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.CalculateCellEditorBoundsStandard(Fluent.OLVListItem,System.Int32,System.Drawing.Rectangle,System.Drawing.Size)">
            <summary>
            Calculate the bounds of the edit control for the given item/column, when the listview
            is not being owner drawn.
            </summary>
            <param name="item"></param>
            <param name="subItemIndex"></param>
            <param name="cellBounds"></param>
            <param name="preferredSize"> </param>
            <returns>A rectangle that is the bounds of the cell editor</returns>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.SetControlValue(System.Windows.Forms.Control,System.Object,System.String)">
            <summary>
            Try to give the given value to the provided control. Fall back to assigning a string
            if the value assignment fails.
            </summary>
            <param name="control">A control</param>
            <param name="value">The value to be given to the control</param>
            <param name="stringValue">The string to be given if the value doesn't work</param>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.ConfigureControl">
            <summary>
            Setup the given control to be a cell editor
            </summary>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.GetControlValue(System.Windows.Forms.Control)">
            <summary>
            Return the value that the given control is showing
            </summary>
            <param name="control"></param>
            <returns></returns>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.CellEditor_Validating(System.Object,System.ComponentModel.CancelEventArgs)">
            <summary>
            Called when the cell editor could be about to lose focus. Time to commit the change
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.CalculateCellBounds(Fluent.OLVListItem,System.Int32)">
            <summary>
            Return the bounds of the given cell
            </summary>
            <param name="item">The row to be edited</param>
            <param name="subItemIndex">The index of the cell to be edited</param>
            <returns>A Rectangle</returns>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.CalculateCellTextBounds(Fluent.OLVListItem,System.Int32)">
            <summary>
            Return the bounds of the given cell only until the edge of the current text
            </summary>
            <param name="item">The row to be edited</param>
            <param name="subItemIndex">The index of the cell to be edited</param>
            <returns>A Rectangle</returns>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.CalculateColumnVisibleBounds(System.Drawing.Rectangle,Fluent.OLVColumn)">
            <summary>
            Calculate the visible bounds of the given column. The column's bottom edge is 
            either the bottom of the last row or the bottom of the control.
            </summary>
            <param name="bounds">The bounds of the control itself</param>
            <param name="column">The column</param>
            <returns>A Rectangle</returns>
            <remarks>This returns an empty rectnage if the control isn't in Details mode, 
            OR has doesn't have any rows, OR if the given column is hidden.</remarks>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.GetCellEditor(Fluent.OLVListItem,System.Int32)">
            <summary>
            Return a control that can be used to edit the value of the given cell.
            </summary>
            <param name="item">The row to be edited</param>
            <param name="subItemIndex">The index of the cell to be edited</param>
            <returns>A Control to edit the given cell</returns>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.GetFirstNonNullValue(Fluent.OLVColumn)">
            <summary>
            Get the first non-null value of the given column.
            At most 1000 rows will be considered.
            </summary>
            <param name="column"></param>
            <returns>The first non-null value, or null if no non-null values were found</returns>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.MakeDefaultCellEditor(Fluent.OLVColumn)">
            <summary>
            Return a TextBox that can be used as a default cell editor.
            </summary>
            <param name="column">What column does the cell belong to?</param>
            <returns></returns>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.ConfigureAutoComplete(System.Windows.Forms.TextBox,Fluent.OLVColumn)">
            <summary>
            Configure the given text box to autocomplete unique values
            from the given column. At most 1000 rows will be considered.
            </summary>
            <param name="tb">The textbox to configure</param>
            <param name="column">The column used to calculate values</param>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.ConfigureAutoComplete(System.Windows.Forms.TextBox,Fluent.OLVColumn,System.Int32)">
            <summary>
            Configure the given text box to autocomplete unique values
            from the given column. At most 1000 rows will be considered.
            </summary>
            <param name="tb">The textbox to configure</param>
            <param name="column">The column used to calculate values</param>
            <param name="maxRows">Consider only this many rows</param>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.CancelCellEdit">
            <summary>
            Stop editing a cell and throw away any changes.
            </summary>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.PossibleFinishCellEditing">
            <summary>
            If a cell edit is in progress, finish the edit.
            </summary>
            <returns>Returns false if the finishing process was cancelled
            (i.e. the cell editor is still on screen)</returns>
            <remarks>This method does not guarantee that the editing will finish. The validation
            process can cause the finishing to be aborted. Developers should check the return value
            or use IsCellEditing property after calling this method to see if the user is still
            editing a cell.</remarks>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.PossibleFinishCellEditing(System.Boolean)">
            <summary>
            If a cell edit is in progress, finish the edit.
            </summary>
            <returns>Returns false if the finishing process was cancelled
            (i.e. the cell editor is still on screen)</returns>
            <remarks>This method does not guarantee that the editing will finish. The validation
            process can cause the finishing to be aborted. Developers should check the return value
            or use IsCellEditing property after calling this method to see if the user is still
            editing a cell.</remarks>
            <param name="expectingCellEdit">True if it is likely that another cell is going to be 
            edited immediately after this cell finishes editing</param>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.FinishCellEdit">
            <summary>
            Finish the cell edit operation, writing changed data back to the model object
            </summary>
            <remarks>This method does not trigger a Validating event, so it always finishes
            the cell edit.</remarks>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.FinishCellEdit(System.Boolean)">
            <summary>
            Finish the cell edit operation, writing changed data back to the model object
            </summary>
            <remarks>This method does not trigger a Validating event, so it always finishes
            the cell edit.</remarks>
            <param name="expectingCellEdit">True if it is likely that another cell is going to be 
            edited immediately after this cell finishes editing</param>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.CleanupCellEdit(System.Boolean,System.Boolean)">
            <summary>
            Remove all trace of any existing cell edit operation
            </summary>
            <param name="expectingCellEdit">True if it is likely that another cell is going to be 
            edited immediately after this cell finishes editing</param>
            <param name="disposeOfCellEditor">True if the cell editor should be disposed </param>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.ClearHotItem">
            <summary>
            Force the hot item to be recalculated
            </summary>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.RefreshHotItem">
            <summary>
            Force the hot item to be recalculated
            </summary>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.UpdateHotItem(System.Drawing.Point)">
            <summary>
            The mouse has moved to the given pt. See if the hot item needs to be updated
            </summary>
            <param name="pt">Where is the mouse?</param>
            <remarks>This is the main entry point for hot item handling</remarks>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.UpdateHotItem(Fluent.OlvListViewHitTestInfo)">
            <summary>
            The mouse has moved to the given pt. See if the hot item needs to be updated
            </summary>
            <param name="hti"></param>
            <remarks>This is the main entry point for hot item handling</remarks>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.UpdateHotRow(Fluent.OLVListItem)">
            <summary>
            Update the given row using the current hot item information
            </summary>
            <param name="olvi"></param>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.UpdateHotRow(System.Int32,System.Int32,Fluent.HitTestLocation,Fluent.OLVListItem)">
            <summary>
            Update the given row using the given hot item information
            </summary>
            <param name="rowIndex"></param>
            <param name="columnIndex"></param>
            <param name="hitLocation"></param>
            <param name="olvi"></param>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.ApplyRowStyle(Fluent.OLVListItem,Fluent.IItemStyle)">
            <summary>
            Apply a style to the given row
            </summary>
            <param name="olvi"></param>
            <param name="style"></param>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.ApplyCellStyle(Fluent.OLVListItem,System.Int32,Fluent.IItemStyle)">
            <summary>
            Apply a style to a cell
            </summary>
            <param name="olvi"></param>
            <param name="columnIndex"></param>
            <param name="style"></param>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.UnapplyHotItem(System.Int32)">
            <summary>
            Remove hot item styling from the given row
            </summary>
            <param name="index"></param>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.OnItemDrag(System.Windows.Forms.ItemDragEventArgs)">
            <summary>
            
            </summary>
            <param name="e"></param>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.OnDragEnter(System.Windows.Forms.DragEventArgs)">
            <summary>
            
            </summary>
            <param name="args"></param>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.OnDragOver(System.Windows.Forms.DragEventArgs)">
            <summary>
            
            </summary>
            <param name="args"></param>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.OnDragDrop(System.Windows.Forms.DragEventArgs)">
            <summary>
            
            </summary>
            <param name="args"></param>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.OnDragLeave(System.EventArgs)">
            <summary>
            
            </summary>
            <param name="e"></param>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.OnGiveFeedback(System.Windows.Forms.GiveFeedbackEventArgs)">
            <summary>
            
            </summary>
            <param name="args"></param>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.OnQueryContinueDrag(System.Windows.Forms.QueryContinueDragEventArgs)">
            <summary>
            
            </summary>
            <param name="args"></param>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.AddDecoration(Fluent.IDecoration)">
            <summary>
            Add the given decoration to those on this list and make it appear
            </summary>
            <param name="decoration">The decoration</param>
            <remarks>
            A decoration scrolls with the listview. An overlay stays fixed in place.
            </remarks>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.AddOverlay(Fluent.IOverlay)">
            <summary>
            Add the given overlay to those on this list and make it appear
            </summary>
            <param name="overlay">The overlay</param>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.DrawAllDecorations(System.Drawing.Graphics,System.Collections.Generic.List{Fluent.OLVListItem})">
            <summary>
            Draw all the decorations
            </summary>
            <param name="g">A Graphics</param>
            <param name="itemsThatWereRedrawn">The items that were redrawn and whose decorations should also be redrawn</param>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.HasDecoration(Fluent.IDecoration)">
            <summary>
            Is the given decoration shown on this list
            </summary>
            <param name="decoration">The overlay</param>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.HasOverlay(Fluent.IOverlay)">
            <summary>
            Is the given overlay shown on this list?
            </summary>
            <param name="overlay">The overlay</param>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.HideOverlays">
            <summary>
            Hide any overlays.
            </summary>
            <remarks>
            This is only a temporary hiding -- the overlays will be shown
            the next time the FluentListView redraws.
            </remarks>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.InitializeEmptyListMsgOverlay">
            <summary>
            Create and configure the empty list msg overlay
            </summary>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.InitializeStandardOverlays">
            <summary>
            Initialize the standard image and text overlays
            </summary>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.ShowOverlays">
            <summary>
            Make sure that any overlays are visible.
            </summary>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.RefreshOverlays">
            <summary>
            Refresh the display of the overlays
            </summary>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.RefreshOverlay(Fluent.IOverlay)">
            <summary>
            Refresh the display of just one overlays
            </summary>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.RemoveDecoration(Fluent.IDecoration)">
            <summary>
            Remove the given decoration from this list
            </summary>
            <param name="decoration">The decoration to remove</param>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.RemoveOverlay(Fluent.IOverlay)">
            <summary>
            Remove the given overlay to those on this list
            </summary>
            <param name="overlay">The overlay</param>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.CreateColumnFilter">
            <summary>
            Create a filter that will enact all the filtering currently installed
            on the visible columns.
            </summary>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.FilterObjects(System.Collections.IEnumerable,Fluent.IModelFilter,Fluent.IListFilter)">
            <summary>
            Do the actual work of filtering
            </summary>
            <param name="originalObjects"></param>
            <param name="aModelFilter"></param>
            <param name="aListFilter"></param>
            <returns></returns>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.ResetColumnFiltering">
            <summary>
            Remove all column filtering.
            </summary>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.UpdateColumnFiltering">
            <summary>
            Update the filtering of this FluentListView based on the value filtering
            defined in each column
            </summary>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.UpdateFiltering">
            <summary>
            When some setting related to filtering changes, this method is called.
            </summary>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.NotifyNewModelFilter">
            <summary>
            Update all renderers with the currently installed model filter
            </summary>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.GetPersistentCheckState(System.Object)">
            <summary>
            Gets the checkedness of the given model.
            </summary>
            <param name="model">The model</param>
            <returns>The checkedness of the model. Defaults to unchecked.</returns>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.SetPersistentCheckState(System.Object,System.Windows.Forms.CheckState)">
            <summary>
            Remember the check state of the given model object
            </summary>
            <param name="model">The model to be remembered</param>
            <param name="state">The model's checkedness</param>
            <returns>The state given to the method</returns>
        </member>
        <member name="M:Fluent.Lists.AdvancedListView.ClearPersistentCheckState">
            <summary>
            Forget any persistent checkbox state
            </summary>
        </member>
        <member name="T:Fluent.Lists.TreeListView">
            <summary>
            A TreeListView combines an expandable tree structure with list view columns.
            </summary>
            <remarks>
            <para>To support tree operations, two delegates must be provided:</para>
            <list type="table">
            <item>
            <term>
            CanExpandGetter
            </term> 
            <description>
            This delegate must accept a model object and return a boolean indicating
            if that model should be expandable. 
            </description>
            </item>
            <item>
            <term>
            ChildrenGetter
            </term> 
            <description>
            This delegate must accept a model object and return an IEnumerable of model
            objects that will be displayed as children of the parent model. This delegate will only be called
            for a model object if the CanExpandGetter has already returned true for that model.
            </description>
            </item>
            <item>
            <term>
            ParentGetter
            </term> 
            <description>
            This delegate must accept a model object and return the parent model. 
            This delegate will only be called when HierarchicalCheckboxes is true OR when Reveal() is called. 
            </description>
            </item>
            </list>
            <para>
            The top level branches of the tree are set via the Roots property. SetObjects(), AddObjects() 
            and RemoveObjects() are interpreted as operations on this collection of roots.
            </para>
            <para>
            To add new children to an existing branch, make changes to your model objects and then
            call RefreshObject() on the parent.
            </para>
            <para>The tree must be a directed acyclic graph -- no cycles are allowed. Put more mundanely, 
            each model object must appear only once in the tree. If the same model object appears in two
            places in the tree, the control will become confused.</para>
            </remarks>
        </member>
        <member name="E:Fluent.Lists.TreeListView.Expanding">
            <summary>
            This event is triggered when user input requests the expansion of a list item.
            </summary>
        </member>
        <member name="E:Fluent.Lists.TreeListView.Collapsing">
            <summary>
            This event is triggered when user input requests the collapse of a list item.
            </summary>
        </member>
        <member name="E:Fluent.Lists.TreeListView.Expanded">
            <summary>
            This event is triggered after the expansion of a list item due to user input.
            </summary>
        </member>
        <member name="E:Fluent.Lists.TreeListView.Collapsed">
            <summary>
            This event is triggered after the collapse of a list item due to user input.
            </summary>
        </member>
        <member name="M:Fluent.Lists.TreeListView.OnExpanding(Fluent.TreeBranchExpandingEventArgs)">
            <summary>
            Trigger the expanding event
            </summary>
            <param name="e"></param>
        </member>
        <member name="M:Fluent.Lists.TreeListView.OnCollapsing(Fluent.TreeBranchCollapsingEventArgs)">
            <summary>
            Trigger the collapsing event
            </summary>
            <param name="e"></param>
        </member>
        <member name="M:Fluent.Lists.TreeListView.OnExpanded(Fluent.TreeBranchExpandedEventArgs)">
            <summary>
            Trigger the expanded event
            </summary>
            <param name="e"></param>
        </member>
        <member name="M:Fluent.Lists.TreeListView.OnCollapsed(Fluent.TreeBranchCollapsedEventArgs)">
            <summary>
            Trigger the collapsed event
            </summary>
            <param name="e"></param>
        </member>
        <member name="M:Fluent.Lists.TreeListView.#ctor">
            <summary>
            Make a default TreeListView
            </summary>
        </member>
        <member name="P:Fluent.Lists.TreeListView.CanExpandGetter">
            <summary>
            This is the delegate that will be used to decide if a model object can be expanded.
            </summary>
            <remarks>
            <para>
            This is called *often* -- on every mouse move when required. It must be fast.
            Don't do database lookups, linear searches, or pi calculations. Just return the
            value of a property.
            </para>
            <para>
            When this delegate is called, the TreeListView is not in a stable state. Don't make
            calls back into the control.
            </para>
            </remarks>
        </member>
        <member name="P:Fluent.Lists.TreeListView.CanShowGroups">
            <summary>
            Gets whether or not this listview is capable of showing groups
            </summary>
        </member>
        <member name="P:Fluent.Lists.TreeListView.ChildrenGetter">
            <summary>
            This is the delegate that will be used to fetch the children of a model object
            </summary>
            <remarks>
            <para>
            This delegate will only be called if the CanExpand delegate has 
            returned true for the model object.
            </para>
            <para>
            When this delegate is called, the TreeListView is not in a stable state. Don't do anything
            that will result in calls being made back into the control.
            </para>
            </remarks>
        </member>
        <member name="P:Fluent.Lists.TreeListView.ParentGetter">
            <summary>
            This is the delegate that will be used to fetch the parent of a model object
            </summary>
            <returns>The parent of the given model, or null if the model doesn't exist or 
            if the model is a root</returns>
        </member>
        <member name="P:Fluent.Lists.TreeListView.CheckedObjects">
            <summary>
            Get or set the collection of model objects that are checked.
            When setting this property, any row whose model object isn't
            in the given collection will be unchecked. Setting to null is
            equivalent to unchecking all.
            </summary>
            <remarks>
            <para>
            This property returns a simple collection. Changes made to the returned
            collection do NOT affect the list. This is different to the behaviour of
            CheckedIndicies collection.
            </para>
            <para>
            When getting CheckedObjects, the performance of this method is O(n) where n is the number of checked objects.
            When setting CheckedObjects, the performance of this method is O(n) where n is the number of checked objects plus
            the number of objects to be checked.
            </para>
            <para>
            If the ListView is not currently showing CheckBoxes, this property does nothing. It does
            not remember any check box settings made.
            </para>
            </remarks>
        </member>
        <member name="P:Fluent.Lists.TreeListView.ExpandedObjects">
            <summary>
            Gets or sets the model objects that are expanded.
            </summary>
            <remarks>
            <para>This can be used to expand model objects before they are seen.</para>
            <para>
            Setting this does *not* force the control to rebuild
            its display. You need to call RebuildAll(true).
            </para>
            </remarks>
        </member>
        <member name="P:Fluent.Lists.TreeListView.ListFilter">
            <summary>
            Gets or  sets the filter that is applied to our whole list of objects.
            TreeListViews do not currently support whole list filters.
            </summary>
        </member>
        <member name="P:Fluent.Lists.TreeListView.HierarchicalCheckboxes">
            <summary>
            Gets or sets whether this tree list view will display hierarchical checkboxes.
            Hierarchical checkboxes is when a parent's "checkedness" is calculated from
            the "checkedness" of its children. If all children are checked, the parent
            will be checked. If all children are unchecked, the parent will also be unchecked.
            If some children are checked and others are not, the parent will be indeterminate.
            </summary>
            <remarks>
            Hierarchical checkboxes don't work with either CheckStateGetters or CheckedAspectName
            (which is basically the same thing). This is because it is too expensive to build the 
            initial state of the control if these are installed, since the control would have to walk
            *every* branch recursively since a single bottom level leaf could change the checkedness
            of the top root.
            </remarks>
        </member>
        <member name="P:Fluent.Lists.TreeListView.Objects">
            <summary>
            Gets or sets the collection of root objects of the tree
            </summary>
        </member>
        <member name="P:Fluent.Lists.TreeListView.ObjectsForClustering">
            <summary>
            Gets the collection of objects that will be considered when creating clusters
            (which are used to generate Excel-like column filters)
            </summary>
        </member>
        <member name="P:Fluent.Lists.TreeListView.RevealAfterExpand">
            <summary>
            After expanding a branch, should the TreeListView attempts to show as much of the 
            revealed descendents as possible.
            </summary>
        </member>
        <member name="P:Fluent.Lists.TreeListView.Roots">
            <summary>
            The model objects that form the top level branches of the tree.
            </summary>
            <remarks>Setting this does <b>NOT</b> reset the state of the control.
            In particular, it does not collapse branches.</remarks>
        </member>
        <member name="M:Fluent.Lists.TreeListView.EnsureTreeRendererPresent(Fluent.Lists.TreeListView.TreeRenderer)">
            <summary>
            Make sure that at least one column is displaying a tree. 
            If no columns is showing the tree, make column 0 do it.
            </summary>
        </member>
        <member name="P:Fluent.Lists.TreeListView.TreeColumnRenderer">
            <summary>
            Gets or sets the renderer that will be used to draw the tree structure.
            Setting this to null resets the renderer to default.
            </summary>
            <remarks>If a column is currently rendering the tree, the renderer
            for that column will be replaced. If no column is rendering the tree,
            column 0 will be given this renderer.</remarks>
        </member>
        <member name="P:Fluent.Lists.TreeListView.TreeFactory">
            <summary>
            This is the delegate that will be used to create the underlying Tree structure
            that the TreeListView uses to manage the information about the tree.
            </summary>
            <remarks>
            <para>The factory must not return null. </para>
            <para>
            Most users of TreeListView will never have to use this delegate.
            </para>
            </remarks>
        </member>
        <member name="P:Fluent.Lists.TreeListView.UseWaitCursorWhenExpanding">
            <summary>
            Should a wait cursor be shown when a branch is being expanded?
            </summary>
            <remarks>When this is true, the wait cursor will be shown whilst the children of the 
            branch are being fetched. If the children of the branch have already been cached, 
            the cursor will not change.</remarks>
        </member>
        <member name="P:Fluent.Lists.TreeListView.TreeModel">
            <summary>
            Gets the model that is used to manage the tree structure
            </summary>
            <remarks>
            Don't mess with this property unless you really know what you are doing.
            If you don't already know what it's for, you don't need it.</remarks>
        </member>
        <member name="M:Fluent.Lists.TreeListView.IsExpanded(System.Object)">
            <summary>
            Return true if the branch at the given model is expanded
            </summary>
            <param name="model"></param>
            <returns></returns>
        </member>
        <member name="M:Fluent.Lists.TreeListView.Collapse(System.Object)">
            <summary>
            Collapse the subtree underneath the given model
            </summary>
            <param name="model"></param>
        </member>
        <member name="M:Fluent.Lists.TreeListView.CollapseAll">
            <summary>
            Collapse all subtrees within this control
            </summary>
        </member>
        <member name="M:Fluent.Lists.TreeListView.ClearObjects">
            <summary>
            Remove all items from this list
            </summary>
            <remark>This method can safely be called from background threads.</remark>
        </member>
        <member name="M:Fluent.Lists.TreeListView.DiscardAllState">
            <summary>
            Collapse all roots and forget everything we know about all models
            </summary>
        </member>
        <member name="M:Fluent.Lists.TreeListView.Expand(System.Object)">
            <summary>
            Expand the subtree underneath the given model object
            </summary>
            <param name="model"></param>
        </member>
        <member name="M:Fluent.Lists.TreeListView.ExpandAll">
            <summary>
            Expand all the branches within this tree recursively.
            </summary>
            <remarks>Be careful: this method could take a long time for large trees.</remarks>
        </member>
        <member name="M:Fluent.Lists.TreeListView.RebuildAll(System.Boolean)">
            <summary>
            Completely rebuild the tree structure
            </summary>
            <param name="preserveState">If true, the control will try to preserve selection and expansion</param>
        </member>
        <member name="M:Fluent.Lists.TreeListView.RebuildAll(System.Collections.IList,System.Collections.IEnumerable,System.Collections.IList)">
            <summary>
            Completely rebuild the tree structure
            </summary>
            <param name="selected">If not null, this list of objects will be selected after the tree is rebuilt</param>
            <param name="expanded">If not null, this collection of objects will be expanded after the tree is rebuilt</param>
            <param name="checkedObjects">If not null, this collection of objects will be checked after the tree is rebuilt</param>
        </member>
        <member name="M:Fluent.Lists.TreeListView.Reveal(System.Object,System.Boolean)">
            <summary>
            Unroll all the ancestors of the given model and make sure it is then visible.
            </summary>
            <remarks>This works best when a ParentGetter is installed.</remarks>
            <param name="modelToReveal">The object to be revealed</param>
            <param name="selectAfterReveal">If true, the model will be selected and focused after being revealed</param>
            <returns>True if the object was found and revealed. False if it was not found.</returns>
        </member>
        <member name="M:Fluent.Lists.TreeListView.RefreshObjects(System.Collections.IList)">
            <summary>
            Update the rows that are showing the given objects
            </summary>
        </member>
        <member name="M:Fluent.Lists.TreeListView.SetObjectCheckedness(System.Object,System.Windows.Forms.CheckState)">
            <summary>
            Change the check state of the given object to be the given state.
            </summary>
            <remarks>
            If the given model object isn't in the list, we still try to remember
            its state, in case it is referenced in the future.</remarks>
            <param name="modelObject"></param>
            <param name="state"></param>
            <returns>True if the checkedness of the model changed</returns>
        </member>
        <member name="M:Fluent.Lists.TreeListView.ToggleExpansion(System.Object)">
            <summary>
            Toggle the expanded state of the branch at the given model object
            </summary>
            <param name="model"></param>
        </member>
        <member name="M:Fluent.Lists.TreeListView.CanExpand(System.Object)">
            <summary>
            Return whether or not the given model can expand.
            </summary>
            <param name="model"></param>
            <remarks>The given model must have already been seen in the tree</remarks>
        </member>
        <member name="M:Fluent.Lists.TreeListView.GetParent(System.Object)">
            <summary>
            Return the model object that is the parent of the given model object.
            </summary>
            <param name="model"></param>
            <returns></returns>
            <remarks>The given model must have already been seen in the tree.</remarks>
        </member>
        <member name="M:Fluent.Lists.TreeListView.GetChildren(System.Object)">
            <summary>
            Return the collection of model objects that are the children of the 
            given model as they exist in the tree at the moment.
            </summary>
            <param name="model"></param>
            <remarks>
            <para>
            This method returns the collection of children as the tree knows them. If the given
            model has never been presented to the user (e.g. it belongs to a parent that has
            never been expanded), then this method will return an empty collection.</para>
            <para>
            Because of this, if you want to traverse the whole tree, this is not the method to use.
            It's better to traverse the your data model directly.
            </para>
            <para>
            If the given model has not already been seen in the tree or
            if it is not expandable, an empty collection will be returned.
            </para>
            </remarks>
        </member>
        <member name="T:Fluent.Lists.TreeListView.CanExpandGetterDelegate">
            <summary>
            Delegates of this type are use to decide if the given model object can be expanded
            </summary>
            <param name="model">The model under consideration</param>
            <returns>Can the given model be expanded?</returns>
        </member>
        <member name="T:Fluent.Lists.TreeListView.ChildrenGetterDelegate">
            <summary>
            Delegates of this type are used to fetch the children of the given model object
            </summary>
            <param name="model">The parent whose children should be fetched</param>
            <returns>An enumerable over the children</returns>
        </member>
        <member name="T:Fluent.Lists.TreeListView.ParentGetterDelegate">
            <summary>
            Delegates of this type are used to fetch the parent of the given model object.
            </summary>
            <param name="model">The child whose parent should be fetched</param>
            <returns>The parent of the child or null if the child is a root</returns>
        </member>
        <member name="T:Fluent.Lists.TreeListView.TreeFactoryDelegate">
            <summary>
            Delegates of this type are used to create a new underlying Tree structure.
            </summary>
            <param name="view">The view for which the Tree is being created</param>
            <returns>A subclass of Tree</returns>
        </member>
        <member name="M:Fluent.Lists.TreeListView.ProcessLButtonDown(Fluent.OlvListViewHitTestInfo)">
            <summary>
            Handle a left button down event
            </summary>
            <param name="hti"></param>
            <returns></returns>
        </member>
        <member name="M:Fluent.Lists.TreeListView.MakeListViewItem(System.Int32)">
            <summary>
            Create a OLVListItem for given row index
            </summary>
            <param name="itemIndex">The index of the row that is needed</param>
            <returns>An OLVListItem</returns>
            <remarks>This differs from the base method by also setting up the IndentCount property.</remarks>
        </member>
        <member name="M:Fluent.Lists.TreeListView.RegenerateTree">
            <summary>
            Reinitialize the Tree structure
            </summary>
        </member>
        <member name="M:Fluent.Lists.TreeListView.RecalculateHierarchicalCheckBoxGraph(System.Collections.IList)">
            <summary>
            Recalculate the state of the checkboxes of all the items in the given list
            and their ancestors.
            </summary>
            <remarks>This only makes sense when HierarchicalCheckboxes is true.</remarks>
            <param name="toCheck"></param>
        </member>
        <member name="M:Fluent.Lists.TreeListView.RecalculateSingleHierarchicalCheckBox(System.Object)">
            <summary>
            Recalculate the hierarchy state of the given item and its ancestors
            </summary>
            <remarks>This only makes sense when HierarchicalCheckboxes is true.</remarks>
            <param name="modelObject"></param>
        </member>
        <member name="M:Fluent.Lists.TreeListView.CalculateDistinctAncestors(System.Collections.IList)">
            <summary>
            Yield the unique ancestors of the given collection of objects.
            The order of the ancestors is guaranteed to be deeper objects first.
            Roots will always be last.
            </summary>
            <param name="toCheck"></param>
            <returns>Unique ancestors of the given objects</returns>
        </member>
        <member name="M:Fluent.Lists.TreeListView.GetAncestors(System.Object)">
            <summary>
            Return all the ancestors of the given model
            </summary>
            <remarks>
            <para>
            This uses ParentGetter if possible.
            </para>
            <para>If the given model is a root OR if the model doesn't exist, the collection will be empty</para>
            </remarks>
            <param name="model">The model whose ancestors should be calculated</param>
            <returns>Return a collection of ancestors of the given model.</returns>
        </member>
        <member name="M:Fluent.Lists.TreeListView.HandleApplicationIdle(System.Object,System.EventArgs)">
            <summary>
            The application is idle and a SelectionChanged event has been scheduled
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="M:Fluent.Lists.TreeListView.IsInputKey(System.Windows.Forms.Keys)">
            <summary>
            Decide if the given key event should be handled as a normal key input to the control?
            </summary>
            <param name="keyData"></param>
            <returns></returns>
        </member>
        <member name="M:Fluent.Lists.TreeListView.OnLostFocus(System.EventArgs)">
            <summary>
            Handle focus being lost, including making sure that the whole control is redrawn.
            </summary>
            <param name="e"></param>
        </member>
        <member name="M:Fluent.Lists.TreeListView.OnKeyDown(System.Windows.Forms.KeyEventArgs)">
            <summary>
            Handle the keyboard input to mimic a TreeView.
            </summary>
            <param name="e"></param>
            <returns>Was the key press handled?</returns>
        </member>
        <member name="T:Fluent.Lists.TreeListView.Tree">
            <summary>
            A Tree object represents a tree structure data model that supports both 
            tree and flat list operations as well as fast access to branches.
            </summary>
            <remarks>If you create a subclass of Tree, you must install it in the TreeListView
            via the TreeFactory delegate.</remarks>
        </member>
        <member name="M:Fluent.Lists.TreeListView.Tree.#ctor(Fluent.Lists.TreeListView)">
            <summary>
            Create a Tree
            </summary>
            <param name="treeView"></param>
        </member>
        <member name="P:Fluent.Lists.TreeListView.Tree.CanExpandGetter">
            <summary>
            This is the delegate that will be used to decide if a model object can be expanded.
            </summary>
        </member>
        <member name="P:Fluent.Lists.TreeListView.Tree.ChildrenGetter">
            <summary>
            This is the delegate that will be used to fetch the children of a model object
            </summary>
            <remarks>This delegate will only be called if the CanExpand delegate has 
            returned true for the model object.</remarks>
        </member>
        <member name="P:Fluent.Lists.TreeListView.Tree.RootObjects">
            <summary>
            Get or return the top level model objects in the tree
            </summary>
        </member>
        <member name="P:Fluent.Lists.TreeListView.Tree.TreeView">
            <summary>
            What tree view is this Tree the model for?
            </summary>
        </member>
        <member name="M:Fluent.Lists.TreeListView.Tree.Collapse(System.Object)">
            <summary>
            Collapse the subtree underneath the given model
            </summary>
            <param name="model">The model to be collapsed. If the model isn't in the tree,
            or if it is already collapsed, the command does nothing.</param>
            <returns>The index of the model in flat list version of the tree</returns>
        </member>
        <member name="M:Fluent.Lists.TreeListView.Tree.CollapseAll">
            <summary>
            Collapse all branches in this tree
            </summary>
            <returns>Nothing useful</returns>
        </member>
        <member name="M:Fluent.Lists.TreeListView.Tree.Expand(System.Object)">
            <summary>
            Expand the subtree underneath the given model object
            </summary>
            <param name="model">The model to be expanded.</param> 
            <returns>The index of the model in flat list version of the tree</returns>
            <remarks>
            If the model isn't in the tree,
            if it cannot be expanded or if it is already expanded, the command does nothing.
            </remarks>
        </member>
        <member name="M:Fluent.Lists.TreeListView.Tree.ExpandAll">
            <summary>
            Expand all branches in this tree
            </summary>
            <returns>Return the index of the first branch that was expanded</returns>
        </member>
        <member name="M:Fluent.Lists.TreeListView.Tree.GetBranch(System.Object)">
            <summary>
            Return the Branch object that represents the given model in the tree
            </summary>
            <param name="model">The model whose branches is to be returned</param>
            <returns>The branch that represents the given model, or null if the model
            isn't in the tree.</returns>
        </member>
        <member name="M:Fluent.Lists.TreeListView.Tree.GetVisibleDescendentCount(System.Object)">
            <summary>
            Return the number of visible descendents that are below the given model.
            </summary>
            <param name="model">The model whose descendent count is to be returned</param>
            <returns>The number of visible descendents. 0 if the model doesn't exist or is collapsed</returns>
        </member>
        <member name="M:Fluent.Lists.TreeListView.Tree.RebuildChildren(System.Object)">
            <summary>
            Rebuild the children of the given model, refreshing any cached information held about the given object
            </summary>
            <param name="model"></param>
            <returns>The index of the model in flat list version of the tree</returns>
        </member>
        <member name="M:Fluent.Lists.TreeListView.Tree.IsModelExpanded(System.Object)">
            <summary>
            Is the given model expanded?
            </summary>
            <param name="model"></param>
            <returns></returns>
        </member>
        <member name="M:Fluent.Lists.TreeListView.Tree.SetModelExpanded(System.Object,System.Boolean)">
            <summary>
            Remember whether or not the given model was expanded
            </summary>
            <param name="model"></param>
            <param name="isExpanded"></param>
        </member>
        <member name="M:Fluent.Lists.TreeListView.Tree.InsertChildren(Fluent.Lists.TreeListView.Branch,System.Int32)">
            <summary>
            Insert the children of the given branch into the given position
            </summary>
            <param name="br">The branch whose children should be inserted</param>
            <param name="index">The index where the children should be inserted</param>
        </member>
        <member name="M:Fluent.Lists.TreeListView.Tree.RebuildList">
            <summary>
            Rebuild our flat internal list of objects.
            </summary>
        </member>
        <member name="M:Fluent.Lists.TreeListView.Tree.RebuildObjectMap(System.Int32)">
            <summary>
            Rebuild our reverse index that maps an object to its location
            in the filteredObjectList array.
            </summary>
            <param name="startIndex"></param>
        </member>
        <member name="M:Fluent.Lists.TreeListView.Tree.MakeBranch(Fluent.Lists.TreeListView.Branch,System.Object)">
            <summary>
            Create a new branch within this tree
            </summary>
            <param name="parent"></param>
            <param name="model"></param>
            <returns></returns>
        </member>
        <member name="M:Fluent.Lists.TreeListView.Tree.GetNthObject(System.Int32)">
            <summary>
            
            </summary>
            <param name="n"></param>
            <returns></returns>
        </member>
        <member name="M:Fluent.Lists.TreeListView.Tree.GetObjectCount">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:Fluent.Lists.TreeListView.Tree.GetObjectIndex(System.Object)">
            <summary>
            
            </summary>
            <param name="model"></param>
            <returns></returns>
        </member>
        <member name="M:Fluent.Lists.TreeListView.Tree.PrepareCache(System.Int32,System.Int32)">
            <summary>
            
            </summary>
            <param name="first"></param>
            <param name="last"></param>
        </member>
        <member name="M:Fluent.Lists.TreeListView.Tree.SearchText(System.String,System.Int32,System.Int32,Fluent.OLVColumn)">
            <summary>
            
            </summary>
            <param name="value"></param>
            <param name="first"></param>
            <param name="last"></param>
            <param name="column"></param>
            <returns></returns>
        </member>
        <member name="M:Fluent.Lists.TreeListView.Tree.Sort(Fluent.OLVColumn,System.Windows.Forms.SortOrder)">
            <summary>
            Sort the tree on the given column and in the given order
            </summary>
            <param name="column"></param>
            <param name="order"></param>
        </member>
        <member name="M:Fluent.Lists.TreeListView.Tree.GetBranchComparer">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:Fluent.Lists.TreeListView.Tree.AddObjects(System.Collections.ICollection)">
            <summary>
            Add the given collection of objects to the roots of this tree
            </summary>
            <param name="modelObjects"></param>
        </member>
        <member name="M:Fluent.Lists.TreeListView.Tree.InsertObjects(System.Int32,System.Collections.ICollection)">
            <summary>
            
            </summary>
            <param name="index"></param>
            <param name="modelObjects"></param>
        </member>
        <member name="M:Fluent.Lists.TreeListView.Tree.RemoveObjects(System.Collections.ICollection)">
            <summary>
            Remove all of the given objects from the roots of the tree.
            Any objects that is not already in the roots collection is ignored.
            </summary>
            <param name="modelObjects"></param>
        </member>
        <member name="M:Fluent.Lists.TreeListView.Tree.SetObjects(System.Collections.IEnumerable)">
            <summary>
            Set the roots of this tree to be the given collection
            </summary>
            <param name="collection"></param>
        </member>
        <member name="M:Fluent.Lists.TreeListView.Tree.UpdateObject(System.Int32,System.Object)">
            <summary>
            Update/replace the nth object with the given object
            </summary>
            <param name="index"></param>
            <param name="modelObject"></param>
        </member>
        <member name="M:Fluent.Lists.TreeListView.Tree.ApplyFilters(Fluent.IModelFilter,Fluent.IListFilter)">
            <summary>
            
            </summary>
            <param name="mFilter"></param>
            <param name="lFilter"></param>
        </member>
        <member name="P:Fluent.Lists.TreeListView.Tree.IsFiltering">
            <summary>
            Is this list currently being filtered?
            </summary>
        </member>
        <member name="M:Fluent.Lists.TreeListView.Tree.IncludeModel(System.Object)">
            <summary>
            Should the given model be included in this control?
            </summary>
            <param name="model">The model to consider</param>
            <returns>True if it will be included</returns>
        </member>
        <member name="F:Fluent.Lists.TreeListView.Tree.modelFilter">
            <summary>
            
            </summary>
        </member>
        <member name="F:Fluent.Lists.TreeListView.Tree.listFilter">
            <summary>
            
            </summary>
        </member>
        <member name="T:Fluent.Lists.TreeListView.Branch">
            <summary>
            A Branch represents a sub-tree within a tree
            </summary>
        </member>
        <member name="T:Fluent.Lists.TreeListView.Branch.BranchFlags">
            <summary>
            Indicators for branches
            </summary>
        </member>
        <member name="F:Fluent.Lists.TreeListView.Branch.BranchFlags.FirstBranch">
            <summary>
            FirstBranch of tree
            </summary>
        </member>
        <member name="F:Fluent.Lists.TreeListView.Branch.BranchFlags.LastChild">
            <summary>
            LastChild of parent
            </summary>
        </member>
        <member name="F:Fluent.Lists.TreeListView.Branch.BranchFlags.OnlyBranch">
            <summary>
            OnlyBranch of tree
            </summary>
        </member>
        <member name="M:Fluent.Lists.TreeListView.Branch.#ctor(Fluent.Lists.TreeListView.Branch,Fluent.Lists.TreeListView.Tree,System.Object)">
            <summary>
            Create a Branch
            </summary>
            <param name="parent"></param>
            <param name="tree"></param>
            <param name="model"></param>
        </member>
        <member name="P:Fluent.Lists.TreeListView.Branch.Ancestors">
            <summary>
            Get the ancestor branches of this branch, with the 'oldest' ancestor first.
            </summary>
        </member>
        <member name="P:Fluent.Lists.TreeListView.Branch.CanExpand">
            <summary>
            Can this branch be expanded?
            </summary>
        </member>
        <member name="P:Fluent.Lists.TreeListView.Branch.ChildBranches">
            <summary>
            Gets or sets our children
            </summary>
        </member>
        <member name="P:Fluent.Lists.TreeListView.Branch.Children">
            <summary>
            Get/set the model objects that are beneath this branch
            </summary>
        </member>
        <member name="P:Fluent.Lists.TreeListView.Branch.FilteredChildBranches">
            <summary>
            Gets a list of all the branches that survive filtering
            </summary>
        </member>
        <member name="P:Fluent.Lists.TreeListView.Branch.IsExpanded">
            <summary>
            Gets or set whether this branch is expanded
            </summary>
        </member>
        <member name="P:Fluent.Lists.TreeListView.Branch.IsFirstBranch">
            <summary>
            Return true if this branch is the first branch of the entire tree
            </summary>
        </member>
        <member name="P:Fluent.Lists.TreeListView.Branch.IsLastChild">
            <summary>
            Return true if this branch is the last child of its parent
            </summary>
        </member>
        <member name="P:Fluent.Lists.TreeListView.Branch.IsOnlyBranch">
            <summary>
            Return true if this branch is the only top level branch
            </summary>
        </member>
        <member name="P:Fluent.Lists.TreeListView.Branch.Level">
            <summary>
            Gets the depth level of this branch
            </summary>
        </member>
        <member name="P:Fluent.Lists.TreeListView.Branch.Model">
            <summary>
            Gets or sets which model is represented by this branch
            </summary>
        </member>
        <member name="P:Fluent.Lists.TreeListView.Branch.NumberVisibleDescendents">
            <summary>
            Return the number of descendents of this branch that are currently visible
            </summary>
            <returns></returns>
        </member>
        <member name="P:Fluent.Lists.TreeListView.Branch.ParentBranch">
            <summary>
            Gets or sets our parent branch
            </summary>
        </member>
        <member name="P:Fluent.Lists.TreeListView.Branch.Tree">
            <summary>
            Gets or sets our overall tree
            </summary>
        </member>
        <member name="P:Fluent.Lists.TreeListView.Branch.Visible">
            <summary>
            Is this branch currently visible? A branch is visible
            if it has no parent (i.e. it's a root), or its parent
            is visible and expanded.
            </summary>
        </member>
        <member name="M:Fluent.Lists.TreeListView.Branch.ClearCachedInfo">
            <summary>
            Clear any cached information that this branch is holding
            </summary>
        </member>
        <member name="M:Fluent.Lists.TreeListView.Branch.Collapse">
            <summary>
            Collapse this branch
            </summary>
        </member>
        <member name="M:Fluent.Lists.TreeListView.Branch.Expand">
            <summary>
            Expand this branch
            </summary>
        </member>
        <member name="M:Fluent.Lists.TreeListView.Branch.ExpandAll">
            <summary>
            Expand this branch recursively
            </summary>
        </member>
        <member name="M:Fluent.Lists.TreeListView.Branch.CollapseAll">
            <summary>
            Collapse all branches in this tree
            </summary>
            <returns>Nothing useful</returns>
        </member>
        <member name="M:Fluent.Lists.TreeListView.Branch.FetchChildren">
            <summary>
            Fetch the children of this branch.
            </summary>
            <remarks>This should only be called when CanExpand is true.</remarks>
        </member>
        <member name="M:Fluent.Lists.TreeListView.Branch.Flatten">
            <summary>
            Collapse the visible descendents of this branch into list of model objects
            </summary>
            <returns></returns>
        </member>
        <member name="M:Fluent.Lists.TreeListView.Branch.FlattenOnto(System.Collections.IList)">
            <summary>
            Flatten this branch's visible descendents onto the given list.
            </summary>
            <param name="flatList"></param>
            <remarks>The branch itself is <b>not</b> included in the list.</remarks>
        </member>
        <member name="M:Fluent.Lists.TreeListView.Branch.RefreshChildren">
            <summary>
            Force a refresh of all children recursively
            </summary>
        </member>
        <member name="M:Fluent.Lists.TreeListView.Branch.Sort(Fluent.Lists.TreeListView.BranchComparer)">
            <summary>
            Sort the sub-branches and their descendents so they are ordered according
            to the given comparer.
            </summary>
            <param name="comparer">The comparer that orders the branches</param>
        </member>
        <member name="T:Fluent.Lists.TreeListView.BranchComparer">
            <summary>
            This class sorts branches according to how their respective model objects are sorted
            </summary>
        </member>
        <member name="M:Fluent.Lists.TreeListView.BranchComparer.#ctor(System.Collections.IComparer)">
            <summary>
            Create a BranchComparer
            </summary>
            <param name="actualComparer"></param>
        </member>
        <member name="M:Fluent.Lists.TreeListView.BranchComparer.Compare(Fluent.Lists.TreeListView.Branch,Fluent.Lists.TreeListView.Branch)">
            <summary>
            Order the two branches
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <returns></returns>
        </member>
        <member name="T:Fluent.Lists.TreeListView.TreeRenderer">
            <summary>
            This class handles drawing the tree structure of the primary column.
            </summary>
        </member>
        <member name="M:Fluent.Lists.TreeListView.TreeRenderer.#ctor">
            <summary>
            Create a TreeRenderer
            </summary>
        </member>
        <member name="P:Fluent.Lists.TreeListView.TreeRenderer.IsShowGlyphs">
            <summary>
            Should the renderer draw glyphs at the expansion points?
            </summary>
            <remarks>The expansion points will still function to expand/collapse even if this is false.</remarks>
        </member>
        <member name="P:Fluent.Lists.TreeListView.TreeRenderer.IsShowLines">
            <summary>
            Should the renderer draw lines connecting siblings?
            </summary>
        </member>
        <member name="P:Fluent.Lists.TreeListView.TreeRenderer.LinePen">
            <summary>
            Return the pen that will be used to draw the lines between branches
            </summary>
        </member>
        <member name="P:Fluent.Lists.TreeListView.TreeRenderer.UseTriangles">
            <summary>
            Should the renderer draw triangles as the expansion glyphs?
            </summary>
            <remarks>
            This looks best with ShowLines = false
            </remarks>
        </member>
        <member name="P:Fluent.Lists.TreeListView.TreeRenderer.Branch">
            <summary>
            Return the branch that the renderer is currently drawing.
            </summary>
        </member>
        <member name="P:Fluent.Lists.TreeListView.TreeRenderer.TreeListView">
            <summary>
            Return the TreeListView for which the renderer is being used.
            </summary>
        </member>
        <member name="F:Fluent.Lists.TreeListView.TreeRenderer.PIXELS_PER_LEVEL">
            <summary>
            How many pixels will be reserved for each level of indentation?
            </summary>
        </member>
        <member name="M:Fluent.Lists.TreeListView.TreeRenderer.Render(System.Drawing.Graphics,System.Drawing.Rectangle)">
            <summary>
            The real work of drawing the tree is done in this method
            </summary>
            <param name="g"></param>
            <param name="r"></param>
        </member>
        <member name="M:Fluent.Lists.TreeListView.TreeRenderer.DrawExpansionGlyph(System.Drawing.Graphics,System.Drawing.Rectangle,System.Boolean)">
            <summary>
            Draw the expansion indicator
            </summary>
            <param name="g"></param>
            <param name="r"></param>
            <param name="isExpanded"></param>
        </member>
        <member name="P:Fluent.Lists.TreeListView.TreeRenderer.UseStyles">
            <summary>
            Gets whether or not we should render using styles
            </summary>
        </member>
        <member name="M:Fluent.Lists.TreeListView.TreeRenderer.DrawExpansionGlyphStyled(System.Drawing.Graphics,System.Drawing.Rectangle,System.Boolean)">
            <summary>
            Draw the expansion indicator using styles
            </summary>
            <param name="g"></param>
            <param name="r"></param>
            <param name="isExpanded"></param>
        </member>
        <member name="P:Fluent.Lists.TreeListView.TreeRenderer.IsExpansionHot">
            <summary>
            Is the mouse over a checkbox in this cell?
            </summary>
        </member>
        <member name="M:Fluent.Lists.TreeListView.TreeRenderer.DrawExpansionGlyphManual(System.Drawing.Graphics,System.Drawing.Rectangle,System.Boolean)">
            <summary>
            Draw the expansion indicator without using styles
            </summary>
            <param name="g"></param>
            <param name="r"></param>
            <param name="isExpanded"></param>
        </member>
        <member name="M:Fluent.Lists.TreeListView.TreeRenderer.DrawLines(System.Drawing.Graphics,System.Drawing.Rectangle,System.Drawing.Pen,Fluent.Lists.TreeListView.Branch,System.Int32)">
            <summary>
            Draw the lines of the tree
            </summary>
            <param name="g"></param>
            <param name="r"></param>
            <param name="p"></param>
            <param name="br"></param>
            <param name="glyphMidVertical"> </param>
        </member>
        <member name="M:Fluent.Lists.TreeListView.TreeRenderer.HandleHitTest(System.Drawing.Graphics,Fluent.OlvListViewHitTestInfo,System.Int32,System.Int32)">
            <summary>
            Do the hit test
            </summary>
            <param name="g"></param>
            <param name="hti"></param>
            <param name="x"></param>
            <param name="y"></param>
        </member>
        <member name="M:Fluent.Lists.TreeListView.TreeRenderer.HandleGetEditRectangle(System.Drawing.Graphics,System.Drawing.Rectangle,Fluent.OLVListItem,System.Int32,System.Drawing.Size)">
            <summary>
            Calculate the edit rect
            </summary>
            <param name="g"></param>
            <param name="cellBounds"></param>
            <param name="item"></param>
            <param name="subItemIndex"></param>
            <param name="preferredSize"> </param>
            <returns></returns>
        </member>
        <member name="T:Fluent.Lists.FastListView">
            <summary>
            A FastFluentListView trades function for speed.
            </summary>
            <remarks>
            <para>On my mid-range laptop, this view builds a list of 10,000 objects in 0.1 seconds,
            as opposed to a normal FluentListView which takes 10-15 seconds. Lists of up to 50,000 items should be
            able to be handled with sub-second response times even on low end machines.</para>
            <para>
            A FastFluentListView is implemented as a virtual list with many of the virtual modes limits (e.g. no sorting)
            fixed through coding. There are some functions that simply cannot be provided. Specifically, a FastFluentListView cannot:
            <list type="bullet">
            <item><description>use Tile view</description></item>
            <item><description>show groups on XP</description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:Fluent.Lists.FastListView.#ctor">
            <summary>
            Make a FastFluentListView
            </summary>
        </member>
        <member name="P:Fluent.Lists.FastListView.FilteredObjects">
            <summary>
            Gets the collection of objects that survive any filtering that may be in place.
            </summary>
        </member>
        <member name="P:Fluent.Lists.FastListView.Objects">
            <summary>
            Get/set the collection of objects that this list will show
            </summary>
            <remarks>
            <para>
            The contents of the control will be updated immediately after setting this property.
            </para>
            <para>This method preserves selection, if possible. Use SetObjects() if
            you do not want to preserve the selection. Preserving selection is the slowest part of this
            code and performance is O(n) where n is the number of selected rows.</para>
            <para>This method is not thread safe.</para>
            </remarks>
        </member>
        <member name="M:Fluent.Lists.FastListView.MoveObjects(System.Int32,System.Collections.ICollection)">
            <summary>
            Move the given collection of objects to the given index.
            </summary>
            <remarks>This operation only makes sense on non-grouped FluentListViews.</remarks>
            <param name="index"></param>
            <param name="modelObjects"></param>
        </member>
        <member name="M:Fluent.Lists.FastListView.Unsort">
            <summary>
            Remove any sorting and revert to the given order of the model objects
            </summary>
            <remarks>To be really honest, Unsort() doesn't work on FastFluentListViews since
            the original ordering of model objects is lost when Sort() is called. So this method
            effectively just turns off sorting.</remarks>
        </member>
        <member name="T:Fluent.Lists.FastObjectListDataSource">
            <summary>
            Provide a data source for a FastFluentListView
            </summary>
            <remarks>
            This class isn't intended to be used directly, but it is left as a public
            class just in case someone wants to subclass it.
            </remarks>
        </member>
        <member name="M:Fluent.Lists.FastObjectListDataSource.#ctor(Fluent.Lists.FastListView)">
            <summary>
            Create a FastObjectListDataSource
            </summary>
            <param name="listView"></param>
        </member>
        <member name="M:Fluent.Lists.FastObjectListDataSource.GetNthObject(System.Int32)">
            <summary>
            Get n'th object
            </summary>
            <param name="n"></param>
            <returns></returns>
        </member>
        <member name="M:Fluent.Lists.FastObjectListDataSource.GetObjectCount">
            <summary>
            How many items are in the data source
            </summary>
            <returns></returns>
        </member>
        <member name="M:Fluent.Lists.FastObjectListDataSource.GetObjectIndex(System.Object)">
            <summary>
            Get the index of the given model
            </summary>
            <param name="model"></param>
            <returns></returns>
        </member>
        <member name="M:Fluent.Lists.FastObjectListDataSource.SearchText(System.String,System.Int32,System.Int32,Fluent.OLVColumn)">
            <summary>
            
            </summary>
            <param name="text"></param>
            <param name="first"></param>
            <param name="last"></param>
            <param name="column"></param>
            <returns></returns>
        </member>
        <member name="M:Fluent.Lists.FastObjectListDataSource.Sort(Fluent.OLVColumn,System.Windows.Forms.SortOrder)">
            <summary>
            
            </summary>
            <param name="column"></param>
            <param name="sortOrder"></param>
        </member>
        <member name="M:Fluent.Lists.FastObjectListDataSource.AddObjects(System.Collections.ICollection)">
            <summary>
            
            </summary>
            <param name="modelObjects"></param>
        </member>
        <member name="M:Fluent.Lists.FastObjectListDataSource.InsertObjects(System.Int32,System.Collections.ICollection)">
            <summary>
            
            </summary>
            <param name="index"></param>
            <param name="modelObjects"></param>
        </member>
        <member name="M:Fluent.Lists.FastObjectListDataSource.RemoveObjects(System.Collections.ICollection)">
            <summary>
            Remove the given collection of models from this source.
            </summary>
            <param name="modelObjects"></param>
        </member>
        <member name="M:Fluent.Lists.FastObjectListDataSource.SetObjects(System.Collections.IEnumerable)">
            <summary>
            
            </summary>
            <param name="collection"></param>
        </member>
        <member name="M:Fluent.Lists.FastObjectListDataSource.UpdateObject(System.Int32,System.Object)">
            <summary>
            Update/replace the nth object with the given object
            </summary>
            <param name="index"></param>
            <param name="modelObject"></param>
        </member>
        <member name="M:Fluent.Lists.FastObjectListDataSource.ApplyFilters(Fluent.IModelFilter,Fluent.IListFilter)">
            <summary>
            Apply the given filters to this data source. One or both may be null.
            </summary>
            <param name="iModelFilter"></param>
            <param name="iListFilter"></param>
        </member>
        <member name="P:Fluent.Lists.FastObjectListDataSource.ObjectList">
            <summary>
            Gets the full list of objects being used for this fast list. 
            This list is unfiltered.
            </summary>
        </member>
        <member name="P:Fluent.Lists.FastObjectListDataSource.FilteredObjectList">
            <summary>
            Gets the list of objects from ObjectList which survive any installed filters.
            </summary>
        </member>
        <member name="M:Fluent.Lists.FastObjectListDataSource.RebuildIndexMap">
            <summary>
            Rebuild the map that remembers which model object is displayed at which line
            </summary>
        </member>
        <member name="M:Fluent.Lists.FastObjectListDataSource.FilterObjects">
            <summary>
            Build our filtered list from our full list.
            </summary>
        </member>
        <member name="T:Fluent.Lists.VirtualFluentListView">
            <summary>
            A virtual object list view operates in virtual mode, that is, it only gets model objects for
            a row when it is needed. This gives it the ability to handle very large numbers of rows with
            minimal resources.
            </summary>
            <remarks><para>A listview is not a great user interface for a large number of items. But if you've
            ever wanted to have a list with 10 million items, go ahead, knock yourself out.</para>
            <para>Virtual lists can never iterate their contents. That would defeat the whole purpose.</para>
            <para>Animated GIFs should not be used in virtual lists. Animated GIFs require some state
            information to be stored for each animation, but virtual lists specifically do not keep any state information.
            In any case, you really do not want to keep state information for 10 million animations!</para>
            <para>
            Although it isn't documented, .NET virtual lists cannot have checkboxes. This class codes around this limitation,
            but you must use the functions provided by FluentListView: CheckedObjects, CheckObject(), UncheckObject() and their friends. 
            If you use the normal check box properties (CheckedItems or CheckedIndicies), they will throw an exception, since the
            list is in virtual mode, and .NET "knows" it can't handle checkboxes in virtual mode.
            </para>
            <para>Due to the limits of the underlying Windows control, virtual lists do not trigger ItemCheck/ItemChecked events. 
            Use a CheckStatePutter instead.</para>
            <para>To enable grouping, you must provide an implmentation of IVirtualGroups interface, via the GroupingStrategy property.</para>
            <para>Similarly, to enable filtering on the list, your VirtualListDataSource must also implement the IFilterableDataSource interface.</para>
            </remarks>
        </member>
        <member name="M:Fluent.Lists.VirtualFluentListView.#ctor">
            <summary>
            Create a VirtualFluentListView
            </summary>
        </member>
        <member name="P:Fluent.Lists.VirtualFluentListView.CanShowGroups">
            <summary>
            Gets whether or not this listview is capabale of showing groups
            </summary>
        </member>
        <member name="P:Fluent.Lists.VirtualFluentListView.CheckedObjects">
            <summary>
            Get or set the collection of model objects that are checked.
            When setting this property, any row whose model object isn't
            in the given collection will be unchecked. Setting to null is
            equivilent to unchecking all.
            </summary>
            <remarks>
            <para>
            This property returns a simple collection. Changes made to the returned
            collection do NOT affect the list. This is different to the behaviour of
            CheckedIndicies collection.
            </para>
            <para>
            When getting CheckedObjects, the performance of this method is O(n) where n is the number of checked objects.
            When setting CheckedObjects, the performance of this method is O(n) where n is the number of checked objects plus
            the number of objects to be checked.
            </para>
            <para>
            If the ListView is not currently showing CheckBoxes, this property does nothing. It does
            not remember any check box settings made.
            </para>
            <para>
            This class optimizes the management of CheckStates so that it will work efficiently even on
            large lists of item. However, those optimizations are impossible if you install a CheckStateGetter.
            With a CheckStateGetter installed, the performance of this method is O(n) where n is the size 
            of the list. This could be painfully slow.</para>
            </remarks>
        </member>
        <member name="P:Fluent.Lists.VirtualFluentListView.CheckedObjectsMustStillExistInList">
            <summary>
            Gets or sets whether or not an object will be included in the CheckedObjects
            collection, even if it is not present in the control at the moment
            </summary>
            <remarks>
            This property is an implementation detail and should not be altered.
            </remarks>
        </member>
        <member name="P:Fluent.Lists.VirtualFluentListView.FilteredObjects">
            <summary>
            Gets the collection of objects that survive any filtering that may be in place.
            </summary>
        </member>
        <member name="P:Fluent.Lists.VirtualFluentListView.GroupingStrategy">
            <summary>
            Gets or sets the strategy that will be used to create groups
            </summary>
            <remarks>
            This must be provided for a virtual list to show groups.
            </remarks>
        </member>
        <member name="P:Fluent.Lists.VirtualFluentListView.IsFiltering">
            <summary>
            Gets whether or not the current list is filtering its contents
            </summary>
            <remarks>
            This is only possible if our underlying data source supports filtering.
            </remarks>
        </member>
        <member name="P:Fluent.Lists.VirtualFluentListView.Objects">
            <summary>
            Get/set the collection of objects that this list will show
            </summary>
            <remarks>
            <para>
            The contents of the control will be updated immediately after setting this property.
            </para>
            <para>Setting this property preserves selection, if possible. Use SetObjects() if
            you do not want to preserve the selection. Preserving selection is the slowest part of this
            code -- performance is O(n) where n is the number of selected rows.</para>
            <para>This method is not thread safe.</para>
            <para>The property DOES work on virtual lists, but if you try to iterate through a list 
            of 10 million objects, it may take some time :)</para>
            </remarks>
        </member>
        <member name="P:Fluent.Lists.VirtualFluentListView.RowGetter">
            <summary>
            This delegate is used to fetch a rowObject, given it's index within the list
            </summary>
            <remarks>Only use this property if you are not using a VirtualListDataSource.</remarks>
        </member>
        <member name="P:Fluent.Lists.VirtualFluentListView.ShowGroups">
            <summary>
            Should this list show its items in groups?
            </summary>
        </member>
        <member name="P:Fluent.Lists.VirtualFluentListView.VirtualListDataSource">
            <summary>
            Get/set the data source that is behind this virtual list
            </summary>
            <remarks>Setting this will cause the list to redraw.</remarks>
        </member>
        <member name="P:Fluent.Lists.VirtualFluentListView.VirtualListSize">
            <summary>
            Gets or sets the number of rows in this virtual list.
            </summary>
            <remarks>
            There is an annoying feature/bug in the .NET ListView class. 
            When you change the VirtualListSize property, it always scrolls so
            that the focused item is the top item. This is annoying since it makes
            the virtual list seem to flicker as the control scrolls to show the focused
            item and then scrolls back to where FluentListView wants it to be.
            </remarks>
        </member>
        <member name="M:Fluent.Lists.VirtualFluentListView.GetItemCount">
            <summary>
            Return the number of items in the list
            </summary>
            <returns>the number of items in the list</returns>
        </member>
        <member name="M:Fluent.Lists.VirtualFluentListView.GetModelObject(System.Int32)">
            <summary>
            Return the model object at the given index
            </summary>
            <param name="index">Index of the model object to be returned</param>
            <returns>A model object</returns>
        </member>
        <member name="M:Fluent.Lists.VirtualFluentListView.IndexOf(System.Object)">
            <summary>
            Find the given model object within the listview and return its index
            </summary>
            <param name="modelObject">The model object to be found</param>
            <returns>The index of the object. -1 means the object was not present</returns>
        </member>
        <member name="M:Fluent.Lists.VirtualFluentListView.ModelToItem(System.Object)">
            <summary>
            Return the OLVListItem that displays the given model object
            </summary>
            <param name="modelObject">The modelObject whose item is to be found</param>
            <returns>The OLVListItem that displays the model, or null</returns>
            <remarks>This method has O(n) performance.</remarks>
        </member>
        <member name="M:Fluent.Lists.VirtualFluentListView.AddObjects(System.Collections.ICollection)">
            <summary>
            Add the given collection of model objects to this control.
            </summary>
            <param name="modelObjects">A collection of model objects</param>
            <remarks>
            <para>The added objects will appear in their correct sort position, if sorting
            is active. Otherwise, they will appear at the end of the list.</para>
            <para>No check is performed to see if any of the objects are already in the ListView.</para>
            <para>Null objects are silently ignored.</para>
            </remarks>
        </member>
        <member name="M:Fluent.Lists.VirtualFluentListView.ClearObjects">
            <summary>
            Remove all items from this list
            </summary>
            <remark>This method can safely be called from background threads.</remark>
        </member>
        <member name="M:Fluent.Lists.VirtualFluentListView.EnsureNthGroupVisible(System.Int32)">
            <summary>
            Scroll the listview so that the given group is at the top.
            </summary>
            <param name="groupIndex">The index of the group to be revealed</param>
            <remarks><para>
            If the group is already visible, the list will still be scrolled to move
            the group to the top, if that is possible.
            </para>
            <para>This only works when the list is showing groups (obviously).</para>
            </remarks>
        </member>
        <member name="M:Fluent.Lists.VirtualFluentListView.InsertObjects(System.Int32,System.Collections.ICollection)">
            <summary>
            Inserts the given collection of model objects to this control at hte given location
            </summary>
            <param name="modelObjects">A collection of model objects</param>
            <remarks>
            <para>The added objects will appear in their correct sort position, if sorting
            is active. Otherwise, they will appear at the given position of the list.</para>
            <para>No check is performed to see if any of the objects are already in the ListView.</para>
            <para>Null objects are silently ignored.</para>
            </remarks>
        </member>
        <member name="M:Fluent.Lists.VirtualFluentListView.RefreshObjects(System.Collections.IList)">
            <summary>
            Update the rows that are showing the given objects
            </summary>
            <remarks>This method does not resort the items.</remarks>
        </member>
        <member name="M:Fluent.Lists.VirtualFluentListView.RefreshSelectedObjects">
            <summary>
            Update the rows that are selected
            </summary>
            <remarks>This method does not resort or regroup the view.</remarks>
        </member>
        <member name="M:Fluent.Lists.VirtualFluentListView.RemoveObjects(System.Collections.ICollection)">
            <summary>
            Remove all of the given objects from the control
            </summary>
            <param name="modelObjects">Collection of objects to be removed</param>
            <remarks>
            <para>Nulls and model objects that are not in the ListView are silently ignored.</para>
            <para>Due to problems in the underlying ListView, if you remove all the objects from
            the control using this method and the list scroll vertically when you do so,
            then when you subsequenially add more objects to the control,
            the vertical scroll bar will become confused and the control will draw one or more
            blank lines at the top of the list. </para>
            </remarks>
        </member>
        <member name="M:Fluent.Lists.VirtualFluentListView.SelectObject(System.Object,System.Boolean)">
            <summary>
            Select the row that is displaying the given model object. All other rows are deselected.
            </summary>
            <param name="modelObject">Model object to select</param>
            <param name="setFocus">Should the object be focused as well?</param>
        </member>
        <member name="M:Fluent.Lists.VirtualFluentListView.SelectObjects(System.Collections.IList)">
            <summary>
            Select the rows that is displaying any of the given model object. All other rows are deselected.
            </summary>
            <param name="modelObjects">A collection of model objects</param>
            <remarks>This method has O(n) performance where n is the number of model objects passed.
            Do not use this to select all the rows in the list -- use SelectAll() for that.</remarks>
        </member>
        <member name="M:Fluent.Lists.VirtualFluentListView.SetObjects(System.Collections.IEnumerable,System.Boolean)">
            <summary>
            Set the collection of objects that this control will show.
            </summary>
            <param name="collection"></param>
            <param name="preserveState">Should the state of the list be preserved as far as is possible.</param>
        </member>
        <member name="M:Fluent.Lists.VirtualFluentListView.GetCheckState(System.Object)">
            <summary>
            Get the checkedness of an object from the model. Returning null means the
            model does know and the value from the control will be used.
            </summary>
            <param name="modelObject"></param>
            <returns></returns>
        </member>
        <member name="M:Fluent.Lists.VirtualFluentListView.BuildList(System.Boolean)">
            <summary>
            Rebuild the list with its current contents.
            </summary>
            <remarks>
            Invalidate any cached information when we rebuild the list.
            </remarks>
        </member>
        <member name="M:Fluent.Lists.VirtualFluentListView.ClearCachedInfo">
            <summary>
            Clear any cached info this list may have been using
            </summary>
        </member>
        <member name="M:Fluent.Lists.VirtualFluentListView.CreateGroups(System.Collections.Generic.IEnumerable{Fluent.OLVGroup})">
            <summary>
            Do the work of creating groups for this control
            </summary>
            <param name="groups"></param>
        </member>
        <member name="M:Fluent.Lists.VirtualFluentListView.DisableVirtualGroups">
            <summary>
            Do the plumbing to disable groups on a virtual list
            </summary>
        </member>
        <member name="M:Fluent.Lists.VirtualFluentListView.EnableVirtualGroups">
            <summary>
            Do the plumbing to enable groups on a virtual list
            </summary>
        </member>
        <member name="M:Fluent.Lists.VirtualFluentListView.GetDisplayOrderOfItemIndex(System.Int32)">
            <summary>
            Return the position of the given itemIndex in the list as it currently shown to the user.
            If the control is not grouped, the display order is the same as the
            sorted list order. But if the list is grouped, the display order is different.
            </summary>
            <param name="itemIndex"></param>
            <returns></returns>
        </member>
        <member name="M:Fluent.Lists.VirtualFluentListView.GetLastItemInDisplayOrder">
            <summary>
            Return the last item in the order they are shown to the user.
            If the control is not grouped, the display order is the same as the
            sorted list order. But if the list is grouped, the display order is different.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Fluent.Lists.VirtualFluentListView.GetNthItemInDisplayOrder(System.Int32)">
            <summary>
            Return the n'th item (0-based) in the order they are shown to the user.
            If the control is not grouped, the display order is the same as the
            sorted list order. But if the list is grouped, the display order is different.
            </summary>
            <param name="n"></param>
            <returns></returns>
        </member>
        <member name="M:Fluent.Lists.VirtualFluentListView.GetNextItem(Fluent.OLVListItem)">
            <summary>
            Return the ListViewItem that appears immediately after the given item.
            If the given item is null, the first item in the list will be returned.
            Return null if the given item is the last item.
            </summary>
            <param name="itemToFind">The item that is before the item that is returned, or null</param>
            <returns>A OLVListItem</returns>
        </member>
        <member name="M:Fluent.Lists.VirtualFluentListView.GetPreviousItem(Fluent.OLVListItem)">
            <summary>
            Return the ListViewItem that appears immediately before the given item.
            If the given item is null, the last item in the list will be returned.
            Return null if the given item is the first item.
            </summary>
            <param name="itemToFind">The item that is before the item that is returned</param>
            <returns>A ListViewItem</returns>
        </member>
        <member name="M:Fluent.Lists.VirtualFluentListView.MakeGroups(Fluent.GroupingParameters)">
            <summary>
            Make a list of groups that should be shown according to the given parameters
            </summary>
            <param name="parms"></param>
            <returns></returns>
        </member>
        <member name="M:Fluent.Lists.VirtualFluentListView.MakeListViewItem(System.Int32)">
            <summary>
            Create a OLVListItem for given row index
            </summary>
            <param name="itemIndex">The index of the row that is needed</param>
            <returns>An OLVListItem</returns>
        </member>
        <member name="M:Fluent.Lists.VirtualFluentListView.PostProcessRows">
            <summary>
            On virtual lists, this cannot work.
            </summary>
        </member>
        <member name="M:Fluent.Lists.VirtualFluentListView.PutCheckState(System.Object,System.Windows.Forms.CheckState)">
            <summary>
            Record the change of checkstate for the given object in the model.
            This does not update the UI -- only the model
            </summary>
            <param name="modelObject"></param>
            <param name="state"></param>
            <returns>The check state that was recorded and that should be used to update
            the control.</returns>
        </member>
        <member name="M:Fluent.Lists.VirtualFluentListView.RefreshItem(Fluent.OLVListItem)">
            <summary>
            Refresh the given item in the list
            </summary>
            <param name="olvi">The item to refresh</param>
        </member>
        <member name="M:Fluent.Lists.VirtualFluentListView.SetVirtualListSize(System.Int32)">
            <summary>
            Change the size of the list
            </summary>
            <param name="newSize"></param>
        </member>
        <member name="M:Fluent.Lists.VirtualFluentListView.TakeOwnershipOfObjects">
            <summary>
            Take ownership of the 'objects' collection. This separates our collection from the source.
            </summary>
            <remarks>
            <para>
            This method
            separates the 'objects' instance variable from its source, so that any AddObject/RemoveObject
            calls will modify our collection and not the original colleciton.
            </para>
            <para>
            VirtualFluentListViews always own their collections, so this is a no-op.
            </para>
            </remarks>
        </member>
        <member name="M:Fluent.Lists.VirtualFluentListView.UpdateFiltering">
            <summary>
            Change the state of the control to reflect changes in filtering
            </summary>
        </member>
        <member name="M:Fluent.Lists.VirtualFluentListView.UpdateVirtualListSize">
            <summary>
            Change the size of the virtual list so that it matches its data source
            </summary>
        </member>
        <member name="M:Fluent.Lists.VirtualFluentListView.HandleCacheVirtualItems(System.Object,System.Windows.Forms.CacheVirtualItemsEventArgs)">
            <summary>
            Handle the CacheVirtualItems event
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="M:Fluent.Lists.VirtualFluentListView.HandleRetrieveVirtualItem(System.Object,System.Windows.Forms.RetrieveVirtualItemEventArgs)">
            <summary>
            Handle a RetrieveVirtualItem
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="M:Fluent.Lists.VirtualFluentListView.HandleSearchForVirtualItem(System.Object,System.Windows.Forms.SearchForVirtualItemEventArgs)">
            <summary>
            Handle the SearchForVirtualList event, which is called when the user types into a virtual list
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="M:Fluent.Lists.VirtualFluentListView.FindMatchInRange(System.String,System.Int32,System.Int32,Fluent.OLVColumn)">
            <summary>
            Find the first row in the given range of rows that prefix matches the string value of the given column.
            </summary>
            <param name="text"></param>
            <param name="first"></param>
            <param name="last"></param>
            <param name="column"></param>
            <returns>The index of the matched row, or -1</returns>
        </member>
        <member name="T:Fluent.ColumnSelectBehaviour">
            <summary>
            These values specify how column selection will be presented to the user
            </summary>
        </member>
        <member name="F:Fluent.ColumnSelectBehaviour.None">
            <summary>
            No column selection will be presented 
            </summary>
        </member>
        <member name="F:Fluent.ColumnSelectBehaviour.InlineMenu">
            <summary>
            The columns will be show in the main menu
            </summary>
        </member>
        <member name="F:Fluent.ColumnSelectBehaviour.Submenu">
            <summary>
            The columns will be shown in a submenu
            </summary>
        </member>
        <member name="F:Fluent.ColumnSelectBehaviour.ModelDialog">
            <summary>
            A model dialog will be presented to allow the user to choose columns
            </summary>
        </member>
        <member name="T:Fluent.CellEditEventHandler">
            <summary>
            The callbacks for CellEditing events
            </summary>
            <remarks> this 
            We could replace this with EventHandler&lt;CellEditEventArgs&gt; but that would break all
            cell editing event code from v1.x.
            </remarks>
        </member>
        <member name="T:Fluent.CellEditEventArgs">
            <summary>
            Let the world know that a cell edit operation is beginning or ending
            </summary>
        </member>
        <member name="M:Fluent.CellEditEventArgs.#ctor(Fluent.OLVColumn,System.Windows.Forms.Control,System.Drawing.Rectangle,Fluent.OLVListItem,System.Int32)">
            <summary>
            Create an event args
            </summary>
            <param name="column"></param>
            <param name="control"></param>
            <param name="cellBounds"></param>
            <param name="item"></param>
            <param name="subItemIndex"></param>
        </member>
        <member name="F:Fluent.CellEditEventArgs.Cancel">
            <summary>
            Change this to true to cancel the cell editing operation.
            </summary>
            <remarks>
            <para>During the CellEditStarting event, setting this to true will prevent the cell from being edited.</para>
            <para>During the CellEditFinishing event, if this value is already true, this indicates that the user has
            cancelled the edit operation and that the handler should perform cleanup only. Setting this to true,
            will prevent the FluentListView from trying to write the new value into the model object.</para>
            </remarks>
        </member>
        <member name="F:Fluent.CellEditEventArgs.Control">
            <summary>
            During the CellEditStarting event, this can be modified to be the control that you want
            to edit the value. You must fully configure the control before returning from the event,
            including its bounds and the value it is showing.
            During the CellEditFinishing event, you can use this to get the value that the user
            entered and commit that value to the model. Changing the control during the finishing
            event has no effect.
            </summary>
        </member>
        <member name="P:Fluent.CellEditEventArgs.Column">
            <summary>
            The column of the cell that is going to be or has been edited.
            </summary>
        </member>
        <member name="P:Fluent.CellEditEventArgs.RowObject">
            <summary>
            The model object of the row of the cell that is going to be or has been edited.
            </summary>
        </member>
        <member name="P:Fluent.CellEditEventArgs.ListViewItem">
            <summary>
            The listview item of the cell that is going to be or has been edited.
            </summary>
        </member>
        <member name="P:Fluent.CellEditEventArgs.NewValue">
            <summary>
            The data value of the cell as it stands in the control.
            </summary>
            <remarks>Only validate during Validating and Finishing events.</remarks>
        </member>
        <member name="P:Fluent.CellEditEventArgs.SubItemIndex">
            <summary>
            The index of the cell that is going to be or has been edited.
            </summary>
        </member>
        <member name="P:Fluent.CellEditEventArgs.Value">
            <summary>
            The data value of the cell before the edit operation began.
            </summary>
        </member>
        <member name="P:Fluent.CellEditEventArgs.CellBounds">
            <summary>
            The bounds of the cell that is going to be or has been edited.
            </summary>
        </member>
        <member name="P:Fluent.CellEditEventArgs.AutoDispose">
            <summary>
            Gets or sets whether the control used for editing should be auto matically disposed
            when the cell edit operation finishes. Defaults to true
            </summary>
            <remarks>If the control is expensive to create, you might want to cache it and reuse for
            for various cells. If so, you don't want FluentListView to dispose of the control automatically</remarks>
        </member>
        <member name="T:Fluent.CancellableEventArgs">
            <summary>
            Event blocks for events that can be cancelled
            </summary>
        </member>
        <member name="F:Fluent.CancellableEventArgs.Canceled">
            <summary>
            Has this event been cancelled by the event handler?
            </summary>
        </member>
        <member name="T:Fluent.BeforeSortingEventArgs">
            <summary>
            BeforeSorting
            </summary>
        </member>
        <member name="M:Fluent.BeforeSortingEventArgs.#ctor(Fluent.OLVColumn,System.Windows.Forms.SortOrder,Fluent.OLVColumn,System.Windows.Forms.SortOrder)">
            <summary>
            Create BeforeSortingEventArgs
            </summary>
            <param name="column"></param>
            <param name="order"></param>
            <param name="column2"></param>
            <param name="order2"></param>
        </member>
        <member name="M:Fluent.BeforeSortingEventArgs.#ctor(Fluent.OLVColumn,System.Windows.Forms.SortOrder,Fluent.OLVColumn,System.Windows.Forms.SortOrder,Fluent.OLVColumn,System.Windows.Forms.SortOrder)">
            <summary>
            Create BeforeSortingEventArgs
            </summary>
            <param name="groupColumn"></param>
            <param name="groupOrder"></param>
            <param name="column"></param>
            <param name="order"></param>
            <param name="column2"></param>
            <param name="order2"></param>
        </member>
        <member name="F:Fluent.BeforeSortingEventArgs.Handled">
            <summary>
            Did the event handler already do the sorting for us?
            </summary>
        </member>
        <member name="F:Fluent.BeforeSortingEventArgs.ColumnToGroupBy">
            <summary>
            What column will be used for grouping
            </summary>
        </member>
        <member name="F:Fluent.BeforeSortingEventArgs.GroupByOrder">
            <summary>
            How will groups be ordered
            </summary>
        </member>
        <member name="F:Fluent.BeforeSortingEventArgs.ColumnToSort">
            <summary>
            What column will be used for sorting
            </summary>
        </member>
        <member name="F:Fluent.BeforeSortingEventArgs.SortOrder">
            <summary>
            What order will be used for sorting. None means no sorting.
            </summary>
        </member>
        <member name="F:Fluent.BeforeSortingEventArgs.SecondaryColumnToSort">
            <summary>
            What column will be used for secondary sorting?
            </summary>
        </member>
        <member name="F:Fluent.BeforeSortingEventArgs.SecondarySortOrder">
            <summary>
            What order will be used for secondary sorting?
            </summary>
        </member>
        <member name="T:Fluent.AfterSortingEventArgs">
            <summary>
            Sorting has just occurred.
            </summary>
        </member>
        <member name="M:Fluent.AfterSortingEventArgs.#ctor(Fluent.OLVColumn,System.Windows.Forms.SortOrder,Fluent.OLVColumn,System.Windows.Forms.SortOrder,Fluent.OLVColumn,System.Windows.Forms.SortOrder)">
            <summary>
            Create a AfterSortingEventArgs
            </summary>
            <param name="groupColumn"></param>
            <param name="groupOrder"></param>
            <param name="column"></param>
            <param name="order"></param>
            <param name="column2"></param>
            <param name="order2"></param>
        </member>
        <member name="M:Fluent.AfterSortingEventArgs.#ctor(Fluent.BeforeSortingEventArgs)">
            <summary>
            Create a AfterSortingEventArgs
            </summary>
            <param name="args"></param>
        </member>
        <member name="P:Fluent.AfterSortingEventArgs.ColumnToGroupBy">
            <summary>
            What column was used for grouping?
            </summary>
        </member>
        <member name="P:Fluent.AfterSortingEventArgs.GroupByOrder">
            <summary>
            What ordering was used for grouping?
            </summary>
        </member>
        <member name="P:Fluent.AfterSortingEventArgs.ColumnToSort">
            <summary>
            What column was used for sorting?
            </summary>
        </member>
        <member name="P:Fluent.AfterSortingEventArgs.SortOrder">
            <summary>
            What ordering was used for sorting?
            </summary>
        </member>
        <member name="P:Fluent.AfterSortingEventArgs.SecondaryColumnToSort">
            <summary>
            What column was used for secondary sorting?
            </summary>
        </member>
        <member name="P:Fluent.AfterSortingEventArgs.SecondarySortOrder">
            <summary>
            What order was used for secondary sorting?
            </summary>
        </member>
        <member name="T:Fluent.FilterEventArgs">
            <summary>
            This event is triggered when the contents of a list have changed
            and we want the world to have a chance to filter the list.
            </summary>
        </member>
        <member name="M:Fluent.FilterEventArgs.#ctor(System.Collections.IEnumerable)">
            <summary>
            Create a FilterEventArgs
            </summary>
            <param name="objects"></param>
        </member>
        <member name="F:Fluent.FilterEventArgs.Objects">
            <summary>
            Gets or sets what objects are being filtered
            </summary>
        </member>
        <member name="F:Fluent.FilterEventArgs.FilteredObjects">
            <summary>
            Gets or sets what objects survived the filtering
            </summary>
        </member>
        <member name="T:Fluent.ItemsChangedEventArgs">
            <summary>
            This event is triggered after the items in the list have been changed,
            either through SetObjects, AddObjects or RemoveObjects.
            </summary>
        </member>
        <member name="M:Fluent.ItemsChangedEventArgs.#ctor">
            <summary>
            Create a ItemsChangedEventArgs
            </summary>
        </member>
        <member name="M:Fluent.ItemsChangedEventArgs.#ctor(System.Int32,System.Int32)">
            <summary>
            Constructor for this event when used by a virtual list
            </summary>
            <param name="oldObjectCount"></param>
            <param name="newObjectCount"></param>
        </member>
        <member name="P:Fluent.ItemsChangedEventArgs.OldObjectCount">
            <summary>
            Gets how many items were in the list before it changed
            </summary>
        </member>
        <member name="P:Fluent.ItemsChangedEventArgs.NewObjectCount">
            <summary>
            Gets how many objects are in the list after the change.
            </summary>
        </member>
        <member name="T:Fluent.ItemsAddingEventArgs">
            <summary>
            This event is triggered by AddObjects before any change has been made to the list.
            </summary>
        </member>
        <member name="M:Fluent.ItemsAddingEventArgs.#ctor(System.Collections.ICollection)">
            <summary>
            Create an ItemsAddingEventArgs
            </summary>
            <param name="objectsToAdd"></param>
        </member>
        <member name="M:Fluent.ItemsAddingEventArgs.#ctor(System.Int32,System.Collections.ICollection)">
            <summary>
            Create an ItemsAddingEventArgs
            </summary>
            <param name="index"></param>
            <param name="objectsToAdd"></param>
        </member>
        <member name="F:Fluent.ItemsAddingEventArgs.Index">
            <summary>
            Gets or sets where the collection is going to be inserted.
            </summary>
        </member>
        <member name="F:Fluent.ItemsAddingEventArgs.ObjectsToAdd">
            <summary>
            Gets or sets the objects to be added to the list
            </summary>
        </member>
        <member name="T:Fluent.ItemsChangingEventArgs">
            <summary>
            This event is triggered by SetObjects before any change has been made to the list.
            </summary>
            <remarks>
            When used with a virtual list, OldObjects will always be null.
            </remarks>
        </member>
        <member name="M:Fluent.ItemsChangingEventArgs.#ctor(System.Collections.IEnumerable,System.Collections.IEnumerable)">
            <summary>
            Create ItemsChangingEventArgs
            </summary>
            <param name="oldObjects"></param>
            <param name="newObjects"></param>
        </member>
        <member name="P:Fluent.ItemsChangingEventArgs.OldObjects">
            <summary>
            Gets the objects that were in the list before it change.
            For virtual lists, this will always be null.
            </summary>
        </member>
        <member name="F:Fluent.ItemsChangingEventArgs.NewObjects">
            <summary>
            Gets or sets the objects that will be in the list after it changes.
            </summary>
        </member>
        <member name="T:Fluent.ItemsRemovingEventArgs">
            <summary>
            This event is triggered by RemoveObjects before any change has been made to the list.
            </summary>
        </member>
        <member name="M:Fluent.ItemsRemovingEventArgs.#ctor(System.Collections.ICollection)">
            <summary>
            Create an ItemsRemovingEventArgs
            </summary>
            <param name="objectsToRemove"></param>
        </member>
        <member name="F:Fluent.ItemsRemovingEventArgs.ObjectsToRemove">
            <summary>
            Gets or sets the objects that will be removed
            </summary>
        </member>
        <member name="T:Fluent.AfterSearchingEventArgs">
            <summary>
            Triggered after the user types into a list
            </summary>
        </member>
        <member name="M:Fluent.AfterSearchingEventArgs.#ctor(System.String,System.Int32)">
            <summary>
            Create an AfterSearchingEventArgs
            </summary>
            <param name="stringToFind"></param>
            <param name="indexSelected"></param>
        </member>
        <member name="P:Fluent.AfterSearchingEventArgs.StringToFind">
            <summary>
            Gets the string that was actually searched for
            </summary>
        </member>
        <member name="F:Fluent.AfterSearchingEventArgs.Handled">
            <summary>
            Gets or sets whether an the event handler already handled this event
            </summary>
        </member>
        <member name="P:Fluent.AfterSearchingEventArgs.IndexSelected">
            <summary>
            Gets the index of the row that was selected by the search.
            -1 means that no row was matched
            </summary>
        </member>
        <member name="T:Fluent.BeforeSearchingEventArgs">
            <summary>
            Triggered when the user types into a list
            </summary>
        </member>
        <member name="M:Fluent.BeforeSearchingEventArgs.#ctor(System.String,System.Int32)">
            <summary>
            Create BeforeSearchingEventArgs
            </summary>
            <param name="stringToFind"></param>
            <param name="startSearchFrom"></param>
        </member>
        <member name="F:Fluent.BeforeSearchingEventArgs.StringToFind">
            <summary>
            Gets or sets the string that will be found by the search routine
            </summary>
            <remarks>Modifying this value does not modify the memory of what the user has typed. 
            When the user next presses a character, the search string will revert to what 
            the user has actually typed.</remarks>
        </member>
        <member name="F:Fluent.BeforeSearchingEventArgs.StartSearchFrom">
            <summary>
            Gets or sets the index of the first row that will be considered to matching.
            </summary>
        </member>
        <member name="T:Fluent.CellEventArgs">
            <summary>
            The parameter block when telling the world about a cell based event
            </summary>
        </member>
        <member name="P:Fluent.CellEventArgs.ListView">
            <summary>
            Gets the FluentListView that is the source of the event
            </summary>
        </member>
        <member name="P:Fluent.CellEventArgs.Model">
            <summary>
            Gets the model object under the cell
            </summary>
            <remarks>This is null for events triggered by the header.</remarks>
        </member>
        <member name="P:Fluent.CellEventArgs.RowIndex">
            <summary>
            Gets the row index of the cell
            </summary>
            <remarks>This is -1 for events triggered by the header.</remarks>
        </member>
        <member name="P:Fluent.CellEventArgs.ColumnIndex">
            <summary>
            Gets the column index of the cell
            </summary>
            <remarks>This is -1 when the view is not in details view.</remarks>
        </member>
        <member name="P:Fluent.CellEventArgs.Column">
            <summary>
            Gets the column of the cell 
            </summary>
            <remarks>This is null when the view is not in details view.</remarks>
        </member>
        <member name="P:Fluent.CellEventArgs.Location">
            <summary>
            Gets the location of the mouse at the time of the event
            </summary>
        </member>
        <member name="P:Fluent.CellEventArgs.ModifierKeys">
            <summary>
            Gets the state of the modifier keys at the time of the event
            </summary>
        </member>
        <member name="P:Fluent.CellEventArgs.Item">
            <summary>
            Gets the item of the cell
            </summary>
        </member>
        <member name="P:Fluent.CellEventArgs.SubItem">
            <summary>
            Gets the subitem of the cell
            </summary>
            <remarks>This is null when the view is not in details view and 
            for event triggered by the header</remarks>
        </member>
        <member name="P:Fluent.CellEventArgs.HitTest">
            <summary>
            Gets the HitTest object that determined which cell was hit
            </summary>
        </member>
        <member name="F:Fluent.CellEventArgs.Handled">
            <summary>
            Gets or set if this event completelely handled. If it was, no further processing
            will be done for it.
            </summary>
        </member>
        <member name="T:Fluent.CellClickEventArgs">
            <summary>
            Tells the world that a cell was clicked
            </summary>
        </member>
        <member name="P:Fluent.CellClickEventArgs.ClickCount">
            <summary>
            Gets or sets the number of clicks associated with this event
            </summary>
        </member>
        <member name="T:Fluent.CellRightClickEventArgs">
            <summary>
            Tells the world that a cell was right clicked
            </summary>
        </member>
        <member name="F:Fluent.CellRightClickEventArgs.MenuStrip">
            <summary>
            Gets or sets the menu that should be displayed as a result of this event.
            </summary>
            <remarks>The menu will be positioned at Location, so changing that property changes
            where the menu will be displayed.</remarks>
        </member>
        <member name="T:Fluent.CellOverEventArgs">
            <summary>
            Tell the world that the mouse is over a given cell
            </summary>
        </member>
        <member name="T:Fluent.FreezeEventArgs">
            <summary>
            Tells the world that the frozen-ness of the FluentListView has changed.
            </summary>
        </member>
        <member name="M:Fluent.FreezeEventArgs.#ctor(System.Int32)">
            <summary>
            Make a FreezeEventArgs
            </summary>
            <param name="freeze"></param>
        </member>
        <member name="P:Fluent.FreezeEventArgs.FreezeLevel">
            <summary>
            How frozen is the control? 0 means that the control is unfrozen, 
            more than 0 indicates froze.
            </summary>
        </member>
        <member name="T:Fluent.ToolTipShowingEventArgs">
            <summary>
            The parameter block when telling the world that a tool tip is about to be shown.
            </summary>
        </member>
        <member name="P:Fluent.ToolTipShowingEventArgs.ToolTipControl">
            <summary>
            Gets the tooltip control that is triggering the tooltip event
            </summary>
        </member>
        <member name="F:Fluent.ToolTipShowingEventArgs.Text">
            <summary>
            Gets or sets the text should be shown on the tooltip for this event
            </summary>
            <remarks>Setting this to empty or null prevents any tooltip from showing</remarks>
        </member>
        <member name="F:Fluent.ToolTipShowingEventArgs.RightToLeft">
            <summary>
            In what direction should the text for this tooltip be drawn?
            </summary>
        </member>
        <member name="F:Fluent.ToolTipShowingEventArgs.IsBalloon">
            <summary>
            Should the tooltip for this event been shown in bubble style?
            </summary>
            <remarks>This doesn't work reliable under Vista</remarks>
        </member>
        <member name="F:Fluent.ToolTipShowingEventArgs.BackColor">
            <summary>
            What color should be used for the background of the tooltip
            </summary>
            <remarks>Setting this does nothing under Vista</remarks>
        </member>
        <member name="F:Fluent.ToolTipShowingEventArgs.ForeColor">
            <summary>
            What color should be used for the foreground of the tooltip
            </summary>
            <remarks>Setting this does nothing under Vista</remarks>
        </member>
        <member name="F:Fluent.ToolTipShowingEventArgs.Title">
            <summary>
            What string should be used as the title for the tooltip for this event?
            </summary>
        </member>
        <member name="F:Fluent.ToolTipShowingEventArgs.StandardIcon">
            <summary>
            Which standard icon should be used for the tooltip for this event
            </summary>
        </member>
        <member name="F:Fluent.ToolTipShowingEventArgs.AutoPopDelay">
            <summary>
            How many milliseconds should the tooltip remain before it automatically
            disappears.
            </summary>
        </member>
        <member name="F:Fluent.ToolTipShowingEventArgs.Font">
            <summary>
            What font should be used to draw the text of the tooltip?
            </summary>
        </member>
        <member name="T:Fluent.HyperlinkEventArgs">
            <summary>
            Common information to all hyperlink events
            </summary>
        </member>
        <member name="P:Fluent.HyperlinkEventArgs.ListView">
            <summary>
            Gets the FluentListView that is the source of the event
            </summary>
        </member>
        <member name="P:Fluent.HyperlinkEventArgs.Model">
            <summary>
            Gets the model object under the cell
            </summary>
        </member>
        <member name="P:Fluent.HyperlinkEventArgs.RowIndex">
            <summary>
            Gets the row index of the cell
            </summary>
        </member>
        <member name="P:Fluent.HyperlinkEventArgs.ColumnIndex">
            <summary>
            Gets the column index of the cell
            </summary>
            <remarks>This is -1 when the view is not in details view.</remarks>
        </member>
        <member name="P:Fluent.HyperlinkEventArgs.Column">
            <summary>
            Gets the column of the cell 
            </summary>
            <remarks>This is null when the view is not in details view.</remarks>
        </member>
        <member name="P:Fluent.HyperlinkEventArgs.Item">
            <summary>
            Gets the item of the cell
            </summary>
        </member>
        <member name="P:Fluent.HyperlinkEventArgs.SubItem">
            <summary>
            Gets the subitem of the cell
            </summary>
            <remarks>This is null when the view is not in details view</remarks>
        </member>
        <member name="P:Fluent.HyperlinkEventArgs.Url">
            <summary>
            Gets the FluentListView that is the source of the event
            </summary>
        </member>
        <member name="P:Fluent.HyperlinkEventArgs.Handled">
            <summary>
            Gets or set if this event completelely handled. If it was, no further processing
            will be done for it.
            </summary>
        </member>
        <member name="T:Fluent.IsHyperlinkEventArgs">
            <summary>
            
            </summary>
        </member>
        <member name="P:Fluent.IsHyperlinkEventArgs.ListView">
            <summary>
            Gets the FluentListView that is the source of the event
            </summary>
        </member>
        <member name="P:Fluent.IsHyperlinkEventArgs.Model">
            <summary>
            Gets the model object under the cell
            </summary>
        </member>
        <member name="P:Fluent.IsHyperlinkEventArgs.Column">
            <summary>
            Gets the column of the cell 
            </summary>
            <remarks>This is null when the view is not in details view.</remarks>
        </member>
        <member name="P:Fluent.IsHyperlinkEventArgs.Text">
            <summary>
            Gets the text of the cell 
            </summary>
        </member>
        <member name="P:Fluent.IsHyperlinkEventArgs.IsHyperlink">
            <summary>
            Gets or sets whether or not this cell is a hyperlink.
            Defaults to true for enabled rows and false for disabled rows. 
            </summary>
        </member>
        <member name="F:Fluent.IsHyperlinkEventArgs.Url">
            <summary>
            Gets or sets the url that should be invoked when this cell is clicked.
            </summary>
            <remarks>Setting this to None or String.Empty means that this cell is not a hyperlink</remarks>
        </member>
        <member name="T:Fluent.FormatRowEventArgs">
            <summary>
            </summary>
        </member>
        <member name="P:Fluent.FormatRowEventArgs.ListView">
            <summary>
            Gets the FluentListView that is the source of the event
            </summary>
        </member>
        <member name="P:Fluent.FormatRowEventArgs.Item">
            <summary>
            Gets the item of the cell
            </summary>
        </member>
        <member name="P:Fluent.FormatRowEventArgs.Model">
            <summary>
            Gets the model object under the cell
            </summary>
        </member>
        <member name="P:Fluent.FormatRowEventArgs.RowIndex">
            <summary>
            Gets the row index of the cell
            </summary>
        </member>
        <member name="P:Fluent.FormatRowEventArgs.DisplayIndex">
            <summary>
            Gets the display index of the row
            </summary>
        </member>
        <member name="P:Fluent.FormatRowEventArgs.UseCellFormatEvents">
            <summary>
            Should events be triggered for each cell in this row?
            </summary>
        </member>
        <member name="T:Fluent.FormatCellEventArgs">
            <summary>
            Parameter block for FormatCellEvent
            </summary>
        </member>
        <member name="P:Fluent.FormatCellEventArgs.ColumnIndex">
            <summary>
            Gets the column index of the cell
            </summary>
            <remarks>This is -1 when the view is not in details view.</remarks>
        </member>
        <member name="P:Fluent.FormatCellEventArgs.Column">
            <summary>
            Gets the column of the cell 
            </summary>
            <remarks>This is null when the view is not in details view.</remarks>
        </member>
        <member name="P:Fluent.FormatCellEventArgs.SubItem">
            <summary>
            Gets the subitem of the cell
            </summary>
            <remarks>This is null when the view is not in details view</remarks>
        </member>
        <member name="P:Fluent.FormatCellEventArgs.CellValue">
            <summary>
            Gets the model value that is being displayed by the cell.
            </summary>
            <remarks>This is null when the view is not in details view</remarks>
        </member>
        <member name="T:Fluent.HyperlinkClickedEventArgs">
            <summary>
            The event args when a hyperlink is clicked
            </summary>
        </member>
        <member name="P:Fluent.HyperlinkClickedEventArgs.Url">
            <summary>
            Gets the url that was associated with this cell.
            </summary>
        </member>
        <member name="T:Fluent.HeaderCheckBoxChangingEventArgs">
            <summary>
            The event args when the check box in a column header is changing
            </summary>
        </member>
        <member name="P:Fluent.HeaderCheckBoxChangingEventArgs.Column">
            <summary>
            Get the column whose checkbox is changing
            </summary>
        </member>
        <member name="P:Fluent.HeaderCheckBoxChangingEventArgs.NewCheckState">
            <summary>
            Get or set the new state that should be used by the column
            </summary>
        </member>
        <member name="T:Fluent.HotItemChangedEventArgs">
            <summary>
            The event args when the hot item changed
            </summary>
        </member>
        <member name="P:Fluent.HotItemChangedEventArgs.Handled">
            <summary>
            Gets or set if this event completelely handled. If it was, no further processing
            will be done for it.
            </summary>
        </member>
        <member name="P:Fluent.HotItemChangedEventArgs.HotCellHitLocation">
            <summary>
            Gets the part of the cell that the mouse is over
            </summary>
        </member>
        <member name="P:Fluent.HotItemChangedEventArgs.HotCellHitLocationEx">
            <summary>
            Gets an extended indication of the part of item/subitem/group that the mouse is currently over
            </summary>
        </member>
        <member name="P:Fluent.HotItemChangedEventArgs.HotColumnIndex">
            <summary>
            Gets the index of the column that the mouse is over
            </summary>
            <remarks>In non-details view, this will always be 0.</remarks>
        </member>
        <member name="P:Fluent.HotItemChangedEventArgs.HotRowIndex">
            <summary>
            Gets the index of the row that the mouse is over
            </summary>
        </member>
        <member name="P:Fluent.HotItemChangedEventArgs.HotGroup">
            <summary>
            Gets the group that the mouse is over
            </summary>
        </member>
        <member name="P:Fluent.HotItemChangedEventArgs.OldHotCellHitLocation">
            <summary>
            Gets the part of the cell that the mouse used to be over
            </summary>
        </member>
        <member name="P:Fluent.HotItemChangedEventArgs.OldHotCellHitLocationEx">
            <summary>
            Gets an extended indication of the part of item/subitem/group that the mouse used to be over
            </summary>
        </member>
        <member name="P:Fluent.HotItemChangedEventArgs.OldHotColumnIndex">
            <summary>
            Gets the index of the column that the mouse used to be over
            </summary>
        </member>
        <member name="P:Fluent.HotItemChangedEventArgs.OldHotRowIndex">
            <summary>
            Gets the index of the row that the mouse used to be over
            </summary>
        </member>
        <member name="P:Fluent.HotItemChangedEventArgs.OldHotGroup">
            <summary>
            Gets the group that the mouse used to be over
            </summary>
        </member>
        <member name="M:Fluent.HotItemChangedEventArgs.ToString">
            <summary>
            Returns a string that represents the current object.
            </summary>
            <returns>
            A string that represents the current object.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="T:Fluent.SubItemCheckingEventArgs">
            <summary>
            Let the world know that a checkbox on a subitem is changing
            </summary>
        </member>
        <member name="M:Fluent.SubItemCheckingEventArgs.#ctor(Fluent.OLVColumn,Fluent.OLVListItem,System.Int32,System.Windows.Forms.CheckState,System.Windows.Forms.CheckState)">
            <summary>
            Create a new event block
            </summary>
            <param name="column"></param>
            <param name="item"></param>
            <param name="subItemIndex"></param>
            <param name="currentValue"></param>
            <param name="newValue"></param>
        </member>
        <member name="P:Fluent.SubItemCheckingEventArgs.Column">
            <summary>
            The column of the cell that is having its checkbox changed.
            </summary>
        </member>
        <member name="P:Fluent.SubItemCheckingEventArgs.RowObject">
            <summary>
            The model object of the row of the cell that is having its checkbox changed.
            </summary>
        </member>
        <member name="P:Fluent.SubItemCheckingEventArgs.ListViewItem">
            <summary>
            The listview item of the cell that is having its checkbox changed.
            </summary>
        </member>
        <member name="P:Fluent.SubItemCheckingEventArgs.CurrentValue">
            <summary>
            The current check state of the cell.
            </summary>
        </member>
        <member name="P:Fluent.SubItemCheckingEventArgs.NewValue">
            <summary>
            The proposed new check state of the cell.
            </summary>
        </member>
        <member name="P:Fluent.SubItemCheckingEventArgs.SubItemIndex">
            <summary>
            The index of the cell that is going to be or has been edited.
            </summary>
        </member>
        <member name="T:Fluent.CreateGroupsEventArgs">
            <summary>
            This event argument block is used when groups are created for a list.
            </summary>
        </member>
        <member name="M:Fluent.CreateGroupsEventArgs.#ctor(Fluent.GroupingParameters)">
            <summary>
            Create a CreateGroupsEventArgs
            </summary>
            <param name="parms"></param>
        </member>
        <member name="P:Fluent.CreateGroupsEventArgs.Parameters">
            <summary>
            Gets the settings that control the creation of groups
            </summary>
        </member>
        <member name="P:Fluent.CreateGroupsEventArgs.Groups">
            <summary>
            Gets or sets the groups that should be used
            </summary>
        </member>
        <member name="P:Fluent.CreateGroupsEventArgs.Canceled">
            <summary>
            Has this event been cancelled by the event handler?
            </summary>
        </member>
        <member name="T:Fluent.GroupTaskClickedEventArgs">
            <summary>
            This event argument block is used when the text of a group task is clicked
            </summary>
        </member>
        <member name="M:Fluent.GroupTaskClickedEventArgs.#ctor(Fluent.OLVGroup)">
            <summary>
            Create a GroupTaskClickedEventArgs
            </summary>
            <param name="group"></param>
        </member>
        <member name="P:Fluent.GroupTaskClickedEventArgs.Group">
            <summary>
            Gets which group was clicked
            </summary>
        </member>
        <member name="T:Fluent.GroupExpandingCollapsingEventArgs">
            <summary>
            This event argument block is used when a group is about to expand or collapse
            </summary>
        </member>
        <member name="M:Fluent.GroupExpandingCollapsingEventArgs.#ctor(Fluent.OLVGroup)">
            <summary>
            Create a GroupExpandingCollapsingEventArgs
            </summary>
            <param name="group"> </param>
        </member>
        <member name="P:Fluent.GroupExpandingCollapsingEventArgs.Group">
            <summary>
            Gets which group is expanding/collapsing
            </summary>
        </member>
        <member name="P:Fluent.GroupExpandingCollapsingEventArgs.IsExpanding">
            <summary>
            Gets whether this event is going to expand the group.
            If this is false, the group must be collapsing.
            </summary>
        </member>
        <member name="T:Fluent.GroupStateChangedEventArgs">
            <summary>
            This event argument block is used when the state of group has changed (collapsed, selected)
            </summary>
        </member>
        <member name="M:Fluent.GroupStateChangedEventArgs.#ctor(Fluent.OLVGroup,Fluent.GroupState,Fluent.GroupState)">
            <summary>
            Create a GroupStateChangedEventArgs
            </summary>
            <param name="group"></param>
            <param name="oldState"> </param>
            <param name="newState"> </param>
        </member>
        <member name="P:Fluent.GroupStateChangedEventArgs.Collapsed">
            <summary>
            Gets whether the group was collapsed by this event
            </summary>
        </member>
        <member name="P:Fluent.GroupStateChangedEventArgs.Focused">
            <summary>
            Gets whether the group was focused by this event
            </summary>
        </member>
        <member name="P:Fluent.GroupStateChangedEventArgs.Selected">
            <summary>
            Gets whether the group was selected by this event
            </summary>
        </member>
        <member name="P:Fluent.GroupStateChangedEventArgs.Uncollapsed">
            <summary>
            Gets whether the group was uncollapsed by this event
            </summary>
        </member>
        <member name="P:Fluent.GroupStateChangedEventArgs.Unfocused">
            <summary>
            Gets whether the group was unfocused by this event
            </summary>
        </member>
        <member name="P:Fluent.GroupStateChangedEventArgs.Unselected">
            <summary>
            Gets whether the group was unselected by this event
            </summary>
        </member>
        <member name="P:Fluent.GroupStateChangedEventArgs.Group">
            <summary>
            Gets which group had its state changed
            </summary>
        </member>
        <member name="P:Fluent.GroupStateChangedEventArgs.OldState">
            <summary>
            Gets the previous state of the group
            </summary>
        </member>
        <member name="P:Fluent.GroupStateChangedEventArgs.NewState">
            <summary>
            Gets the new state of the group
            </summary>
        </member>
        <member name="T:Fluent.TreeBranchExpandingEventArgs">
            <summary>
            This event argument block is used when a branch of a tree is about to be expanded
            </summary>
        </member>
        <member name="M:Fluent.TreeBranchExpandingEventArgs.#ctor(System.Object,Fluent.OLVListItem)">
            <summary>
            Create a new event args
            </summary>
            <param name="model"></param>
            <param name="item"></param>
        </member>
        <member name="P:Fluent.TreeBranchExpandingEventArgs.Model">
            <summary>
            Gets the model that is about to expand. If null, all branches are going to be expanded.
            </summary>
        </member>
        <member name="P:Fluent.TreeBranchExpandingEventArgs.Item">
            <summary>
            Gets the OLVListItem that is about to be expanded
            </summary>
        </member>
        <member name="T:Fluent.TreeBranchExpandedEventArgs">
            <summary>
            This event argument block is used when a branch of a tree has just been expanded
            </summary>
        </member>
        <member name="M:Fluent.TreeBranchExpandedEventArgs.#ctor(System.Object,Fluent.OLVListItem)">
            <summary>
            Create a new event args
            </summary>
            <param name="model"></param>
            <param name="item"></param>
        </member>
        <member name="P:Fluent.TreeBranchExpandedEventArgs.Model">
            <summary>
            Gets the model that is was expanded. If null, all branches were expanded.
            </summary>
        </member>
        <member name="P:Fluent.TreeBranchExpandedEventArgs.Item">
            <summary>
            Gets the OLVListItem that was expanded
            </summary>
        </member>
        <member name="T:Fluent.TreeBranchCollapsingEventArgs">
            <summary>
            This event argument block is used when a branch of a tree is about to be collapsed
            </summary>
        </member>
        <member name="M:Fluent.TreeBranchCollapsingEventArgs.#ctor(System.Object,Fluent.OLVListItem)">
            <summary>
            Create a new event args
            </summary>
            <param name="model"></param>
            <param name="item"></param>
        </member>
        <member name="P:Fluent.TreeBranchCollapsingEventArgs.Model">
            <summary>
            Gets the model that is about to collapse. If this is null, all models are going to collapse.
            </summary>
        </member>
        <member name="P:Fluent.TreeBranchCollapsingEventArgs.Item">
            <summary>
            Gets the OLVListItem that is about to be collapsed. Can be null
            </summary>
        </member>
        <member name="T:Fluent.TreeBranchCollapsedEventArgs">
            <summary>
            This event argument block is used when a branch of a tree has just been collapsed
            </summary>
        </member>
        <member name="M:Fluent.TreeBranchCollapsedEventArgs.#ctor(System.Object,Fluent.OLVListItem)">
            <summary>
            Create a new event args
            </summary>
            <param name="model"></param>
            <param name="item"></param>
        </member>
        <member name="P:Fluent.TreeBranchCollapsedEventArgs.Model">
            <summary>
            Gets the model that is was collapsed. If null, all branches were collapsed
            </summary>
        </member>
        <member name="P:Fluent.TreeBranchCollapsedEventArgs.Item">
            <summary>
            Gets the OLVListItem that was collapsed
            </summary>
        </member>
        <member name="T:Fluent.GroupingParameters">
            <summary>
            This class contains all the settings used when groups are created
            </summary>
        </member>
        <member name="M:Fluent.GroupingParameters.#ctor(Fluent.Lists.AdvancedListView,Fluent.OLVColumn,System.Windows.Forms.SortOrder,Fluent.OLVColumn,System.Windows.Forms.SortOrder,Fluent.OLVColumn,System.Windows.Forms.SortOrder,System.String,System.String,System.Boolean)">
            <summary>
            Create a GroupingParameters
            </summary>
            <param name="olv"></param>
            <param name="groupByColumn"></param>
            <param name="groupByOrder"></param>
            <param name="column"></param>
            <param name="order"></param>
            <param name="secondaryColumn"></param>
            <param name="secondaryOrder"></param>
            <param name="titleFormat"></param>
            <param name="titleSingularFormat"></param>
            <param name="sortItemsByPrimaryColumn"></param>
        </member>
        <member name="P:Fluent.GroupingParameters.ListView">
            <summary>
            Gets or sets the FluentListView being grouped
            </summary>
        </member>
        <member name="P:Fluent.GroupingParameters.GroupByColumn">
            <summary>
            Gets or sets the column used to create groups
            </summary>
        </member>
        <member name="P:Fluent.GroupingParameters.GroupByOrder">
            <summary>
            In what order will the groups themselves be sorted?
            </summary>
        </member>
        <member name="P:Fluent.GroupingParameters.GroupComparer">
            <summary>
            If this is set, this comparer will be used to order the groups
            </summary>
        </member>
        <member name="P:Fluent.GroupingParameters.ItemComparer">
            <summary>
            If this is set, this comparer will be used to order items within each group
            </summary>
        </member>
        <member name="P:Fluent.GroupingParameters.PrimarySort">
            <summary>
            Gets or sets the column that will be the primary sort
            </summary>
        </member>
        <member name="P:Fluent.GroupingParameters.PrimarySortOrder">
            <summary>
            Gets or sets the ordering for the primary sort
            </summary>
        </member>
        <member name="P:Fluent.GroupingParameters.SecondarySort">
            <summary>
            Gets or sets the column used for secondary sorting
            </summary>
        </member>
        <member name="P:Fluent.GroupingParameters.SecondarySortOrder">
            <summary>
            Gets or sets the ordering for the secondary sort
            </summary>
        </member>
        <member name="P:Fluent.GroupingParameters.TitleFormat">
            <summary>
            Gets or sets the title format used for groups with zero or more than one element
            </summary>
        </member>
        <member name="P:Fluent.GroupingParameters.TitleSingularFormat">
            <summary>
            Gets or sets the title format used for groups with only one element
            </summary>
        </member>
        <member name="P:Fluent.GroupingParameters.SortItemsByPrimaryColumn">
            <summary>
            Gets or sets whether the items should be sorted by the primary column
            </summary>
        </member>
        <member name="T:Fluent.GroupState">
            <summary>
            These values indicate what is the state of the group. These values
            are taken directly from the SDK and many are not used by FluentListView.
            </summary>
        </member>
        <member name="F:Fluent.GroupState.LVGS_NORMAL">
            <summary>
            Normal
            </summary>
        </member>
        <member name="F:Fluent.GroupState.LVGS_COLLAPSED">
            <summary>
            Collapsed
            </summary>
        </member>
        <member name="F:Fluent.GroupState.LVGS_HIDDEN">
            <summary>
            Hidden
            </summary>
        </member>
        <member name="F:Fluent.GroupState.LVGS_NOHEADER">
            <summary>
            NoHeader
            </summary>
        </member>
        <member name="F:Fluent.GroupState.LVGS_COLLAPSIBLE">
            <summary>
            Can be collapsed
            </summary>
        </member>
        <member name="F:Fluent.GroupState.LVGS_FOCUSED">
            <summary>
            Has focus
            </summary>
        </member>
        <member name="F:Fluent.GroupState.LVGS_SELECTED">
            <summary>
            Is Selected
            </summary>
        </member>
        <member name="F:Fluent.GroupState.LVGS_SUBSETED">
            <summary>
            Is subsetted
            </summary>
        </member>
        <member name="F:Fluent.GroupState.LVGS_SUBSETLINKFOCUSED">
            <summary>
            Subset link has focus
            </summary>
        </member>
        <member name="F:Fluent.GroupState.LVGS_ALL">
            <summary>
            All styles
            </summary>
        </member>
        <member name="T:Fluent.GroupMask">
            <summary>
            This mask indicates which members of a LVGROUP have valid data. These values
            are taken directly from the SDK and many are not used by FluentListView.
            </summary>
        </member>
        <member name="F:Fluent.GroupMask.LVGF_NONE">
            <summary>
            No mask
            </summary>
        </member>
        <member name="F:Fluent.GroupMask.LVGF_HEADER">
            <summary>
            Group has header
            </summary>
        </member>
        <member name="F:Fluent.GroupMask.LVGF_FOOTER">
            <summary>
            Group has footer
            </summary>
        </member>
        <member name="F:Fluent.GroupMask.LVGF_STATE">
            <summary>
            Group has state
            </summary>
        </member>
        <member name="F:Fluent.GroupMask.LVGF_ALIGN">
            <summary>
            
            </summary>
        </member>
        <member name="F:Fluent.GroupMask.LVGF_GROUPID">
            <summary>
            
            </summary>
        </member>
        <member name="F:Fluent.GroupMask.LVGF_SUBTITLE">
            <summary>
            pszSubtitle is valid
            </summary>
        </member>
        <member name="F:Fluent.GroupMask.LVGF_TASK">
            <summary>
            pszTask is valid
            </summary>
        </member>
        <member name="F:Fluent.GroupMask.LVGF_DESCRIPTIONTOP">
            <summary>
            pszDescriptionTop is valid
            </summary>
        </member>
        <member name="F:Fluent.GroupMask.LVGF_DESCRIPTIONBOTTOM">
            <summary>
            pszDescriptionBottom is valid
            </summary>
        </member>
        <member name="F:Fluent.GroupMask.LVGF_TITLEIMAGE">
            <summary>
            iTitleImage is valid
            </summary>
        </member>
        <member name="F:Fluent.GroupMask.LVGF_EXTENDEDIMAGE">
            <summary>
            iExtendedImage is valid
            </summary>
        </member>
        <member name="F:Fluent.GroupMask.LVGF_ITEMS">
            <summary>
            iFirstItem and cItems are valid
            </summary>
        </member>
        <member name="F:Fluent.GroupMask.LVGF_SUBSET">
            <summary>
            pszSubsetTitle is valid
            </summary>
        </member>
        <member name="F:Fluent.GroupMask.LVGF_SUBSETITEMS">
            <summary>
            readonly, cItems holds count of items in visible subset, iFirstItem is valid
            </summary>
        </member>
        <member name="T:Fluent.GroupMetricsMask">
            <summary>
            This mask indicates which members of a GROUPMETRICS structure are valid
            </summary>
        </member>
        <member name="F:Fluent.GroupMetricsMask.LVGMF_NONE">
            <summary>
            
            </summary>
        </member>
        <member name="F:Fluent.GroupMetricsMask.LVGMF_BORDERSIZE">
            <summary>
            
            </summary>
        </member>
        <member name="F:Fluent.GroupMetricsMask.LVGMF_BORDERCOLOR">
            <summary>
            
            </summary>
        </member>
        <member name="F:Fluent.GroupMetricsMask.LVGMF_TEXTCOLOR">
            <summary>
            
            </summary>
        </member>
        <member name="T:Fluent.OLVGroup">
            <summary>
            Instances of this class enhance the capabilities of a normal ListViewGroup,
            enabling the functionality that was released in v6 of the common controls.
            </summary>
            <remarks>
            <para>
            In this implementation (2009-09), these objects are essentially passive.
            Setting properties does not automatically change the associated group in
            the listview. Collapsed and Collapsible are two exceptions to this and 
            give immediate results.
            </para>
            <para>
            This really should be a subclass of ListViewGroup, but that class is 
            sealed (why is that?). So this class provides the same interface as a
            ListViewGroup, plus many other new properties.
            </para>
            </remarks>
        </member>
        <member name="M:Fluent.OLVGroup.#ctor">
            <summary>
            Create an OLVGroup
            </summary>
        </member>
        <member name="M:Fluent.OLVGroup.#ctor(System.String)">
            <summary>
            Create a group with the given title
            </summary>
            <param name="header">Title of the group</param>
        </member>
        <member name="P:Fluent.OLVGroup.BottomDescription">
            <summary>
            Gets or sets the bottom description of the group
            </summary>
            <remarks>
            Descriptions only appear when group is centered and there is a title image
            </remarks>
        </member>
        <member name="P:Fluent.OLVGroup.Collapsed">
            <summary>
            Gets or sets whether or not this group is collapsed
            </summary>
        </member>
        <member name="P:Fluent.OLVGroup.Collapsible">
            <summary>
            Gets or sets whether or not this group can be collapsed
            </summary>
        </member>
        <member name="P:Fluent.OLVGroup.Contents">
            <summary>
            Gets or sets some representation of the contents of this group
            </summary>
            <remarks>This is user defined (like Tag)</remarks>
        </member>
        <member name="P:Fluent.OLVGroup.Created">
            <summary>
            Gets whether this group has been created.
            </summary>
        </member>
        <member name="P:Fluent.OLVGroup.ExtendedImage">
            <summary>
            Gets or sets the int or string that will select the extended image to be shown against the title
            </summary>
        </member>
        <member name="P:Fluent.OLVGroup.Footer">
            <summary>
            Gets or sets the footer of the group
            </summary>
        </member>
        <member name="P:Fluent.OLVGroup.GroupId">
            <summary>
            Gets the internal id of our associated ListViewGroup.
            </summary>
        </member>
        <member name="P:Fluent.OLVGroup.Header">
            <summary>
            Gets or sets the header of the group
            </summary>
        </member>
        <member name="P:Fluent.OLVGroup.HeaderAlignment">
            <summary>
            Gets or sets the horizontal alignment of the group header
            </summary>
        </member>
        <member name="P:Fluent.OLVGroup.Id">
            <summary>
            Gets or sets the internally created id of the group
            </summary>
        </member>
        <member name="P:Fluent.OLVGroup.Items">
            <summary>
            Gets or sets ListViewItems that are members of this group
            </summary>
            <remarks>Listener of the BeforeCreatingGroups event can populate this collection.
            It is only used on non-virtual lists.</remarks>
        </member>
        <member name="P:Fluent.OLVGroup.Key">
            <summary>
            Gets or sets the key that was used to partition objects into this group
            </summary>
            <remarks>This is user defined (like Tag)</remarks>
        </member>
        <member name="P:Fluent.OLVGroup.ListView">
            <summary>
            Gets the FluentListView that this group belongs to
            </summary>
            <remarks>If this is null, the group has not yet been created.</remarks>
        </member>
        <member name="P:Fluent.OLVGroup.Name">
            <summary>
            Gets or sets the name of the group
            </summary>
            <remarks>As of 2009-09-01, this property is not used.</remarks>
        </member>
        <member name="P:Fluent.OLVGroup.Focused">
            <summary>
            Gets or sets whether this group is focused
            </summary>
        </member>
        <member name="P:Fluent.OLVGroup.Selected">
            <summary>
            Gets or sets whether this group is selected
            </summary>
        </member>
        <member name="P:Fluent.OLVGroup.SubsetTitle">
            <summary>
            Gets or sets the text that will show that this group is subsetted
            </summary>
            <remarks>
            As of WinSDK v7.0, subsetting of group is officially unimplemented.
            We can get around this using undocumented interfaces and may do so.
            </remarks>
        </member>
        <member name="P:Fluent.OLVGroup.Subtitle">
            <summary>
            Gets or set the subtitleof the task
            </summary>
        </member>
        <member name="P:Fluent.OLVGroup.SortValue">
            <summary>
            Gets or sets the value by which this group will be sorted.
            </summary>
        </member>
        <member name="P:Fluent.OLVGroup.State">
            <summary>
            Gets or sets the state of the group
            </summary>
        </member>
        <member name="P:Fluent.OLVGroup.StateMask">
            <summary>
            Gets or sets which bits of State are valid
            </summary>
        </member>
        <member name="P:Fluent.OLVGroup.Subseted">
            <summary>
            Gets or sets whether this group is showing only a subset of its elements
            </summary>
            <remarks>
            As of WinSDK v7.0, this property officially does nothing.
            </remarks>
        </member>
        <member name="P:Fluent.OLVGroup.Tag">
            <summary>
            Gets or sets the user-defined data attached to this group
            </summary>
        </member>
        <member name="P:Fluent.OLVGroup.Task">
            <summary>
            Gets or sets the task of this group
            </summary>
            <remarks>This task is the clickable text that appears on the right margin
            of the group header.</remarks>
        </member>
        <member name="P:Fluent.OLVGroup.TitleImage">
            <summary>
            Gets or sets the int or string that will select the image to be shown against the title
            </summary>
        </member>
        <member name="P:Fluent.OLVGroup.TopDescription">
            <summary>
            Gets or sets the top description of the group
            </summary>
            <remarks>
            Descriptions only appear when group is centered and there is a title image
            </remarks>
        </member>
        <member name="P:Fluent.OLVGroup.VirtualItemCount">
            <summary>
            Gets or sets the number of items that are within this group.
            </summary>
            <remarks>This should only be used for virtual groups.</remarks>
        </member>
        <member name="P:Fluent.OLVGroup.ListViewGroup">
            <summary>
            Gets or sets the ListViewGroup that is shadowed by this group.
            </summary>
            <remarks>For virtual groups, this will always be null.</remarks>
        </member>
        <member name="M:Fluent.OLVGroup.GetImageIndex(System.Object)">
            <summary>
            Calculate the index into the group image list of the given image selector
            </summary>
            <param name="imageSelector"></param>
            <returns></returns>
        </member>
        <member name="M:Fluent.OLVGroup.ToString">
            <summary>
            Convert this object to a string representation
            </summary>
            <returns></returns>
        </member>
        <member name="M:Fluent.OLVGroup.InsertGroupNewStyle(Fluent.Lists.AdvancedListView)">
            <summary>
            Insert a native group into the underlying Windows control,
            *without* using a ListViewGroup
            </summary>
            <param name="olv"></param>
            <remarks>This is used when creating virtual groups</remarks>
        </member>
        <member name="M:Fluent.OLVGroup.InsertGroupOldStyle(Fluent.Lists.AdvancedListView)">
            <summary>
            Insert a native group into the underlying control via a ListViewGroup
            </summary>
            <param name="olv"></param>
        </member>
        <member name="M:Fluent.OLVGroup.SetItemsOldStyle">
            <summary>
            Change the members of the group to match the current contents of Items,
            using a ListViewGroup
            </summary>
        </member>
        <member name="M:Fluent.OLVGroup.AsNativeGroup(System.Boolean)">
            <summary>
            Create a native LVGROUP structure that matches this group
            </summary>
        </member>
        <member name="M:Fluent.OLVGroup.GetState">
            <summary>
            Get the current state of this group from the underlying control
            </summary>
        </member>
        <member name="M:Fluent.OLVGroup.SetState(Fluent.GroupState,Fluent.GroupState)">
            <summary>
            Get the current state of this group from the underlying control
            </summary>
        </member>
        <member name="T:Fluent.Munger">
            <summary>
            An instance of Munger gets a value from or puts a value into a target object. The property
            to be peeked (or poked) is determined from a string. The peeking or poking is done using reflection.
            </summary>
            <remarks>
            Name of the aspect to be peeked can be a field, property or parameterless method. The name of an
            aspect to poke can be a field, writable property or single parameter method.
            <para>
            Aspect names can be dotted to chain a series of references. 
            </para>
            <example>Order.Customer.HomeAddress.State</example>
            </remarks>
        </member>
        <member name="M:Fluent.Munger.#ctor">
            <summary>
            Create a do nothing Munger
            </summary>
        </member>
        <member name="M:Fluent.Munger.#ctor(System.String)">
            <summary>
            Create a Munger that works on the given aspect name
            </summary>
            <param name="aspectName">The name of the </param>
        </member>
        <member name="M:Fluent.Munger.PutProperty(System.Object,System.String,System.Object)">
            <summary>
            A helper method to put the given value into the given aspect of the given object.
            </summary>
            <remarks>This method catches and silently ignores any errors that occur
            while modifying the target object</remarks>
            <param name="target">The object to be modified</param>
            <param name="propertyName">The name of the property/field to be modified</param>
            <param name="value">The value to be assigned</param>
            <returns>Did the modification work?</returns>
        </member>
        <member name="P:Fluent.Munger.IgnoreMissingAspects">
            <summary>
            Gets or sets whether Mungers will silently ignore missing aspect errors.
            </summary>
            <remarks>
            <para>
            By default, if a Munger is asked to fetch a field/property/method
            that does not exist from a model, it returns an error message, since that 
            condition is normally a programming error. There are some use cases where
            this is not an error, and the munger should simply keep quiet.
            </para>
            <para>By default this is true during release builds.</para>
            </remarks>
        </member>
        <member name="P:Fluent.Munger.AspectName">
            <summary>
            The name of the aspect that is to be peeked or poked.
            </summary>
            <remarks>
            <para>
            This name can be a field, property or parameter-less method.
            </para>
            <para>
            The name can be dotted, which chains references. If any link in the chain returns
            null, the entire chain is considered to return null.
            </para>
            </remarks>
            <example>"DateOfBirth"</example>
            <example>"Owner.HomeAddress.Postcode"</example>
        </member>
        <member name="M:Fluent.Munger.GetValue(System.Object)">
            <summary>
            Extract the value indicated by our AspectName from the given target.
            </summary>
            <remarks>If the aspect name is null or empty, this will return null.</remarks>
            <param name="target">The object that will be peeked</param>
            <returns>The value read from the target</returns>
        </member>
        <member name="M:Fluent.Munger.GetValueEx(System.Object)">
            <summary>
            Extract the value indicated by our AspectName from the given target, raising exceptions
            if the munger fails.
            </summary>
            <remarks>If the aspect name is null or empty, this will return null.</remarks>
            <param name="target">The object that will be peeked</param>
            <returns>The value read from the target</returns>
        </member>
        <member name="M:Fluent.Munger.PutValue(System.Object,System.Object)">
            <summary>
            Poke the given value into the given target indicated by our AspectName.
            </summary>
            <remarks>
            <para>
            If the AspectName is a dotted path, all the selectors bar the last
            are used to find the object that should be updated, and the last
            selector is used as the property to update on that object.
            </para>
            <para>
            So, if 'target' is a Person and the AspectName is "HomeAddress.Postcode",
            this method will first fetch "HomeAddress" property, and then try to set the
            "Postcode" property on the home address object.
            </para>
            </remarks>
            <param name="target">The object that will be poked</param>
            <param name="value">The value that will be poked into the target</param>
            <returns>bool indicating whether the put worked</returns>
        </member>
        <member name="P:Fluent.Munger.Parts">
            <summary>
            Gets the list of SimpleMungers that match our AspectName
            </summary>
        </member>
        <member name="M:Fluent.Munger.BuildParts(System.String)">
            <summary>
            Convert a possibly dotted AspectName into a list of SimpleMungers
            </summary>
            <param name="aspect"></param>
            <returns></returns>
        </member>
        <member name="M:Fluent.Munger.EvaluateParts(System.Object,System.Collections.Generic.IList{Fluent.SimpleMunger})">
            <summary>
            Evaluate the given chain of SimpleMungers against an initial target.
            </summary>
            <param name="target"></param>
            <param name="parts"></param>
            <returns></returns>
        </member>
        <member name="T:Fluent.SimpleMunger">
            <summary>
            A SimpleMunger deals with a single property/field/method on its target.
            </summary>
            <remarks>
            Munger uses a chain of these resolve a dotted aspect name.
            </remarks>
        </member>
        <member name="M:Fluent.SimpleMunger.#ctor(System.String)">
            <summary>
            Create a SimpleMunger
            </summary>
            <param name="aspectName"></param>
        </member>
        <member name="P:Fluent.SimpleMunger.AspectName">
            <summary>
            The name of the aspect that is to be peeked or poked.
            </summary>
            <remarks>
            <para>
            This name can be a field, property or method. 
            When using a method to get a value, the method must be parameter-less.
            When using a method to set a value, the method must accept 1 parameter.
            </para>
            <para>
            It cannot be a dotted name.
            </para>
            </remarks>
        </member>
        <member name="M:Fluent.SimpleMunger.GetValue(System.Object)">
            <summary>
            Get a value from the given target
            </summary>
            <param name="target"></param>
            <returns></returns>
        </member>
        <member name="M:Fluent.SimpleMunger.PutValue(System.Object,System.Object)">
            <summary>
            Poke the given value into the given target indicated by our AspectName.
            </summary>
            <param name="target">The object that will be poked</param>
            <param name="value">The value that will be poked into the target</param>
            <returns>bool indicating if the put worked</returns>
        </member>
        <member name="T:Fluent.MungerException">
            <summary>
            These exceptions are raised when a munger finds something it cannot process
            </summary>
        </member>
        <member name="M:Fluent.MungerException.#ctor(Fluent.SimpleMunger,System.Object,System.Exception)">
            <summary>
            Create a MungerException
            </summary>
            <param name="munger"></param>
            <param name="target"></param>
            <param name="ex"></param>
        </member>
        <member name="P:Fluent.MungerException.Munger">
            <summary>
            Get the munger that raised the exception
            </summary>
        </member>
        <member name="P:Fluent.MungerException.Target">
            <summary>
            Gets the target that threw the exception
            </summary>
        </member>
        <member name="T:Fluent.NativeMethods">
            <summary>
            Wrapper for all native method calls on ListView controls
            </summary>
        </member>
        <member name="M:Fluent.NativeMethods.SetBackgroundImage(System.Windows.Forms.ListView,System.Drawing.Image,System.Boolean,System.Boolean,System.Int32,System.Int32)">
            <summary>
            Put an image under the ListView.
            </summary>
            <remarks>
            <para>
            The ListView must have its handle created before calling this.
            </para>
            <para>
            This doesn't work very well. Specifically, it doesn't play well with owner drawn, 
            and grid lines are drawn over it.
            </para>
            </remarks>
            <param name="lv"></param>
            <param name="image">The image to be used as the background. If this is null, any existing background image will be cleared.</param>
            <param name="isWatermark">If this is true, the image is pinned to the bottom right and does not scroll. The other parameters are ignored</param>
            <param name="isTiled">If this is true, the image will be tiled to fill the whole control background. The offset parameters will be ignored.</param>
            <param name="xOffset">If both watermark and tiled are false, this indicates the horizontal percentage where the image will be placed. 0 is absolute left, 100 is absolute right.</param>
            <param name="yOffset">If both watermark and tiled are false, this indicates the vertical percentage where the image will be placed.</param>
            <returns></returns>
        </member>
        <member name="T:Fluent.NativeMethods.ImageListDrawItemConstants">
            <summary>
            Flags controlling how the Image List item is 
            drawn
            </summary>
        </member>
        <member name="F:Fluent.NativeMethods.ImageListDrawItemConstants.ILD_NORMAL">
            <summary>
            Draw item normally.
            </summary>
        </member>
        <member name="F:Fluent.NativeMethods.ImageListDrawItemConstants.ILD_TRANSPARENT">
            <summary>
            Draw item transparently.
            </summary>
        </member>
        <member name="F:Fluent.NativeMethods.ImageListDrawItemConstants.ILD_BLEND25">
            <summary>
            Draw item blended with 25% of the specified foreground colour
            or the Highlight colour if no foreground colour specified.
            </summary>
        </member>
        <member name="F:Fluent.NativeMethods.ImageListDrawItemConstants.ILD_SELECTED">
            <summary>
            Draw item blended with 50% of the specified foreground colour
            or the Highlight colour if no foreground colour specified.
            </summary>
        </member>
        <member name="F:Fluent.NativeMethods.ImageListDrawItemConstants.ILD_MASK">
            <summary>
            Draw the icon's mask
            </summary>
        </member>
        <member name="F:Fluent.NativeMethods.ImageListDrawItemConstants.ILD_IMAGE">
            <summary>
            Draw the icon image without using the mask
            </summary>
        </member>
        <member name="F:Fluent.NativeMethods.ImageListDrawItemConstants.ILD_ROP">
            <summary>
            Draw the icon using the ROP specified.
            </summary>
        </member>
        <member name="F:Fluent.NativeMethods.ImageListDrawItemConstants.ILD_PRESERVEALPHA">
            <summary>
            Preserves the alpha channel in dest. XP only.
            </summary>
        </member>
        <member name="F:Fluent.NativeMethods.ImageListDrawItemConstants.ILD_SCALE">
            <summary>
            Scale the image to cx, cy instead of clipping it. XP only.
            </summary>
        </member>
        <member name="F:Fluent.NativeMethods.ImageListDrawItemConstants.ILD_DPISCALE">
            <summary>
            Scale the image to the current DPI of the display. XP only.
            </summary>
        </member>
        <member name="T:Fluent.NativeMethods.ImageListDrawStateConstants">
            <summary>
            Enumeration containing XP ImageList Draw State options
            </summary>
        </member>
        <member name="F:Fluent.NativeMethods.ImageListDrawStateConstants.ILS_NORMAL">
            <summary>
            The image state is not modified. 
            </summary>
        </member>
        <member name="F:Fluent.NativeMethods.ImageListDrawStateConstants.ILS_GLOW">
            <summary>
            Adds a glow effect to the icon, which causes the icon to appear to glow 
            with a given color around the edges. (Note: does not appear to be implemented)
            </summary>
        </member>
        <member name="F:Fluent.NativeMethods.ImageListDrawStateConstants.ILS_SHADOW">
            <summary>
            Adds a drop shadow effect to the icon. (Note: does not appear to be implemented)
            </summary>
        </member>
        <member name="F:Fluent.NativeMethods.ImageListDrawStateConstants.ILS_SATURATE">
            <summary>
            Saturates the icon by increasing each color component 
            of the RGB triplet for each pixel in the icon. (Note: only ever appears to result in a completely unsaturated icon)
            </summary>
        </member>
        <member name="F:Fluent.NativeMethods.ImageListDrawStateConstants.ILS_ALPHA">
            <summary>
            Alpha blends the icon. Alpha blending controls the transparency 
            level of an icon, according to the value of its alpha channel. 
            (Note: does not appear to be implemented).
            </summary>
        </member>
        <member name="M:Fluent.NativeMethods.DrawImage(System.Windows.Forms.ImageList,System.IntPtr,System.Int32,System.Int32,System.Int32,Fluent.NativeMethods.ImageListDrawItemConstants,System.Int32,System.Int32,Fluent.NativeMethods.ImageListDrawStateConstants)">
            <summary>
            Draws an image using the specified flags and state on XP systems.
            </summary>
            <param name="il">The image list from which an item will be drawn</param>
            <param name="hdc">Device context to draw to</param>
            <param name="index">Index of image to draw</param>
            <param name="x">X Position to draw at</param>
            <param name="y">Y Position to draw at</param>
            <param name="flags">Drawing flags</param>
            <param name="cx">Width to draw</param>
            <param name="cy">Height to draw</param>
            <param name="stateFlags">State flags</param>
        </member>
        <member name="M:Fluent.NativeMethods.ForceSubItemImagesExStyle(System.Windows.Forms.ListView)">
            <summary>
            Make sure the ListView has the extended style that says to display subitem images.
            </summary>
            <remarks>This method must be called after any .NET call that update the extended styles
            since they seem to erase this setting.</remarks>
            <param name="list">The listview to send a m to</param>
        </member>
        <member name="M:Fluent.NativeMethods.SetItemCount(System.Windows.Forms.ListView,System.Int32)">
            <summary>
            Change the virtual list size of the given ListView (which must be in virtual mode)
            </summary>
            <remarks>This will not change the scroll position</remarks>
            <param name="list">The listview to send a message to</param>
            <param name="count">How many rows should the list have?</param>
        </member>
        <member name="M:Fluent.NativeMethods.SetExtendedStyle(System.Windows.Forms.ListView,System.Int32,System.Int32)">
            <summary>
            Make sure the ListView has the extended style that says to display subitem images.
            </summary>
            <remarks>This method must be called after any .NET call that update the extended styles
            since they seem to erase this setting.</remarks>
            <param name="list">The listview to send a m to</param>
            <param name="style"></param>
            <param name="styleMask"></param>
        </member>
        <member name="M:Fluent.NativeMethods.GetCountPerPage(System.Windows.Forms.ListView)">
            <summary>
            Calculates the number of items that can fit vertically in the visible area of a list-view (which
            must be in details or list view.
            </summary>
            <param name="list">The listView</param>
            <returns>Number of visible items per page</returns>
        </member>
        <member name="M:Fluent.NativeMethods.SetSubItemImage(System.Windows.Forms.ListView,System.Int32,System.Int32,System.Int32)">
            <summary>
            For the given item and subitem, make it display the given image
            </summary>
            <param name="list">The listview to send a m to</param>
            <param name="itemIndex">row number (0 based)</param>
            <param name="subItemIndex">subitem (0 is the item itself)</param>
            <param name="imageIndex">index into the image list</param>
        </member>
        <member name="M:Fluent.NativeMethods.SetColumnImage(System.Windows.Forms.ListView,System.Int32,System.Windows.Forms.SortOrder,System.Int32)">
            <summary>
            Setup the given column of the listview to show the given image to the right of the text.
            If the image index is -1, any previous image is cleared
            </summary>
            <param name="list">The listview to send a m to</param>
            <param name="columnIndex">Index of the column to modifiy</param>
            <param name="order"></param>
            <param name="imageIndex">Index into the small image list</param>
        </member>
        <member name="M:Fluent.NativeMethods.HasBuiltinSortIndicators">
            <summary>
            Does this version of the operating system have builtin sort indicators?
            </summary>
            <returns>Are there builtin sort indicators</returns>
            <remarks>XP and later have these</remarks>
        </member>
        <member name="M:Fluent.NativeMethods.GetUpdateRect(System.Windows.Forms.Control)">
            <summary>
            Return the bounds of the update region on the given control.
            </summary>
            <remarks>The BeginPaint() system call validates the update region, effectively wiping out this information.
            So this call has to be made before the BeginPaint() call.</remarks>
            <param name="cntl">The control whose update region is be calculated</param>
            <returns>A rectangle</returns>
        </member>
        <member name="M:Fluent.NativeMethods.ValidateRect(System.Windows.Forms.Control,System.Drawing.Rectangle)">
            <summary>
            Validate an area of the given control. A validated area will not be repainted at the next redraw.
            </summary>
            <param name="cntl">The control to be validated</param>
            <param name="r">The area of the control to be validated</param>
        </member>
        <member name="M:Fluent.NativeMethods.SelectAllItems(System.Windows.Forms.ListView)">
            <summary>
            Select all rows on the given listview
            </summary>
            <param name="list">The listview whose items are to be selected</param>
        </member>
        <member name="M:Fluent.NativeMethods.DeselectAllItems(System.Windows.Forms.ListView)">
            <summary>
            Deselect all rows on the given listview
            </summary>
            <param name="list">The listview whose items are to be deselected</param>
        </member>
        <member name="M:Fluent.NativeMethods.DeselectOneItem(System.Windows.Forms.ListView,System.Int32)">
            <summary>
            Deselect a single row
            </summary>
            <param name="list"></param>
            <param name="index"></param>
        </member>
        <member name="M:Fluent.NativeMethods.SetItemState(System.Windows.Forms.ListView,System.Int32,System.Int32,System.Int32)">
            <summary>
            Set the item state on the given item
            </summary>
            <param name="list">The listview whose item's state is to be changed</param>
            <param name="itemIndex">The index of the item to be changed</param>
            <param name="mask">Which bits of the value are to be set?</param>
            <param name="value">The value to be set</param>
        </member>
        <member name="M:Fluent.NativeMethods.Scroll(System.Windows.Forms.ListView,System.Int32,System.Int32)">
            <summary>
            Scroll the given listview by the given deltas
            </summary>
            <param name="list"></param>
            <param name="dx"></param>
            <param name="dy"></param>
            <returns>true if the scroll succeeded</returns>
        </member>
        <member name="M:Fluent.NativeMethods.GetHeaderControl(System.Windows.Forms.ListView)">
            <summary>
            Return the handle to the header control on the given list
            </summary>
            <param name="list">The listview whose header control is to be returned</param>
            <returns>The handle to the header control</returns>
        </member>
        <member name="M:Fluent.NativeMethods.GetColumnSides(Fluent.Lists.AdvancedListView,System.Int32)">
            <summary>
            Return the edges of the given column.
            </summary>
            <param name="lv"></param>
            <param name="columnIndex"></param>
            <returns>A Point holding the left and right co-ords of the column.
            -1 means that the sides could not be retrieved.</returns>
        </member>
        <member name="M:Fluent.NativeMethods.GetScrolledColumnSides(System.Windows.Forms.ListView,System.Int32)">
            <summary>
            Return the edges of the given column.
            </summary>
            <param name="lv"></param>
            <param name="columnIndex"></param>
            <returns>A Point holding the left and right co-ords of the column.
            -1 means that the sides could not be retrieved.</returns>
        </member>
        <member name="M:Fluent.NativeMethods.GetColumnUnderPoint(System.IntPtr,System.Drawing.Point)">
            <summary>
            Return the index of the column of the header that is under the given point.
            Return -1 if no column is under the pt
            </summary>
            <param name="handle">The list we are interested in</param>
            <param name="pt">The client co-ords</param>
            <returns>The index of the column under the point, or -1 if no column header is under that point</returns>
        </member>
        <member name="M:Fluent.NativeMethods.GetDividerUnderPoint(System.IntPtr,System.Drawing.Point)">
            <summary>
            Return the index of the divider under the given point. Return -1 if no divider is under the pt
            </summary>
            <param name="handle">The list we are interested in</param>
            <param name="pt">The client co-ords</param>
            <returns>The index of the divider under the point, or -1 if no divider is under that point</returns>
        </member>
        <member name="M:Fluent.NativeMethods.GetScrollPosition(System.Windows.Forms.ListView,System.Boolean)">
            <summary>
            Get the scroll position of the given scroll bar
            </summary>
            <param name="lv"></param>
            <param name="horizontalBar"></param>
            <returns></returns>
        </member>
        <member name="M:Fluent.NativeMethods.ChangeZOrder(System.Windows.Forms.IWin32Window,System.Windows.Forms.IWin32Window)">
            <summary>
            Change the z-order to the window 'toBeMoved' so it appear directly on top of 'reference'
            </summary>
            <param name="toBeMoved"></param>
            <param name="reference"></param>
            <returns></returns>
        </member>
        <member name="M:Fluent.NativeMethods.MakeTopMost(System.Windows.Forms.IWin32Window)">
            <summary>
            Make the given control/window a topmost window
            </summary>
            <param name="toBeMoved"></param>
            <returns></returns>
        </member>
        <member name="M:Fluent.NativeMethods.ChangeSize(System.Windows.Forms.IWin32Window,System.Int32,System.Int32)">
            <summary>
            Change the size of the window without affecting any other attributes
            </summary>
            <param name="toBeMoved"></param>
            <param name="width"></param>
            <param name="height"></param>
            <returns></returns>
        </member>
        <member name="M:Fluent.NativeMethods.ShowWithoutActivate(System.Windows.Forms.IWin32Window)">
            <summary>
            Show the given window without activating it
            </summary>
            <param name="win">The window to show</param>
        </member>
        <member name="M:Fluent.NativeMethods.SetSelectedColumn(System.Windows.Forms.ListView,System.Windows.Forms.ColumnHeader)">
            <summary>
            Mark the given column as being selected.
            </summary>
            <param name="objectListView"></param>
            <param name="value">The OLVColumn or null to clear</param>
            <remarks>
            This method works, but it prevents subitems in the given column from having
            back colors. 
            </remarks>
        </member>
        <member name="T:Fluent.NullableDictionary`2">
            <summary>
            A simple-minded implementation of a Dictionary that can handle null as a key.
            </summary>
            <typeparam name="TKey">The type of the dictionary key</typeparam>
            <typeparam name="TValue">The type of the values to be stored</typeparam>
            <remarks>This is not a full implementation and is only meant to handle
            collecting groups by their keys, since groups can have null as a key value.</remarks>
        </member>
        <member name="T:Fluent.OLVListItem">
            <summary>
            OLVListItems are specialized ListViewItems that know which row object they came from,
            and the row index at which they are displayed, even when in group view mode. They
            also know the image they should draw against themselves
            </summary>
        </member>
        <member name="M:Fluent.OLVListItem.#ctor(System.Object)">
            <summary>
            Create a OLVListItem for the given row object
            </summary>
        </member>
        <member name="M:Fluent.OLVListItem.#ctor(System.Object,System.String,System.Object)">
            <summary>
            Create a OLVListItem for the given row object, represented by the given string and image
            </summary>
        </member>
        <member name="P:Fluent.OLVListItem.Bounds">
            <summary>
            Gets the bounding rectangle of the item, including all subitems
            </summary>
        </member>
        <member name="P:Fluent.OLVListItem.CellPadding">
            <summary>
            Gets or sets how many pixels will be left blank around each cell of this item
            </summary>
            <remarks>This setting only takes effect when the control is owner drawn.</remarks>
        </member>
        <member name="P:Fluent.OLVListItem.CellVerticalAlignment">
            <summary>
            Gets or sets how the cells of this item will be vertically aligned
            </summary>
            <remarks>This setting only takes effect when the control is owner drawn.</remarks>
        </member>
        <member name="P:Fluent.OLVListItem.Checked">
            <summary>
            Gets or sets the checkedness of this item.
            </summary>
            <remarks>
            Virtual lists don't handle checkboxes well, so we have to intercept attempts to change them
            through the items, and change them into something that will work.
            Unfortunately, this won't work if this property is set through the base class, since
            the property is not declared as virtual.
            </remarks>
        </member>
        <member name="P:Fluent.OLVListItem.CheckState">
            <summary>
            Enable tri-state checkbox.
            </summary>
            <remarks>.NET's Checked property was not built to handle tri-state checkboxes,
            and will return True for both Checked and Indeterminate states.</remarks>
        </member>
        <member name="P:Fluent.OLVListItem.HasDecoration">
            <summary>
            Gets if this item has any decorations set for it.
            </summary>
        </member>
        <member name="P:Fluent.OLVListItem.Decoration">
            <summary>
            Gets or sets the decoration that will be drawn over this item
            </summary>
            <remarks>Setting this replaces all other decorations</remarks>
        </member>
        <member name="P:Fluent.OLVListItem.Decorations">
            <summary>
            Gets the collection of decorations that will be drawn over this item
            </summary>
        </member>
        <member name="P:Fluent.OLVListItem.Enabled">
            <summary>
            Gets whether or not this row can be selected and activated
            </summary>
        </member>
        <member name="P:Fluent.OLVListItem.HasAnyHyperlinks">
            <summary>
            Gets whether any cell on this item is showing a hyperlink
            </summary>
        </member>
        <member name="P:Fluent.OLVListItem.ImageSelector">
            <summary>
            Get or set the image that should be shown against this item
            </summary>
            <remarks><para>This can be an Image, a string or an int. A string or an int will
            be used as an index into the small image list.</para></remarks>
        </member>
        <member name="P:Fluent.OLVListItem.RowObject">
            <summary>
            Gets or sets the the model object that is source of the data for this list item.
            </summary>
        </member>
        <member name="P:Fluent.OLVListItem.SelectedBackColor">
            <summary>
            Gets or sets the color that will be used for this row's background when it is selected and 
            the control is focused.
            </summary>
            <remarks>
            <para>To work reliably, this property must be set during a FormatRow event.</para>
            <para>
            If this is not set, the normal selection BackColor will be used.
            </para>
            </remarks>
        </member>
        <member name="P:Fluent.OLVListItem.SelectedForeColor">
            <summary>
            Gets or sets the color that will be used for this row's foreground when it is selected and 
            the control is focused.
            </summary>
            <remarks>
            <para>To work reliably, this property must be set during a FormatRow event.</para>
            <para>
            If this is not set, the normal selection ForeColor will be used.
            </para>
            </remarks>
        </member>
        <member name="M:Fluent.OLVListItem.GetSubItem(System.Int32)">
            <summary>
            Return the sub item at the given index
            </summary>
            <param name="index">Index of the subitem to be returned</param>
            <returns>An OLVListSubItem</returns>
        </member>
        <member name="M:Fluent.OLVListItem.GetSubItemBounds(System.Int32)">
            <summary>
            Return bounds of the given subitem
            </summary>
            <remarks>This correctly calculates the bounds even for column 0.</remarks>
        </member>
        <member name="T:Fluent.OLVListSubItem">
            <summary>
            A ListViewSubItem that knows which image should be drawn against it.
            </summary>
        </member>
        <member name="M:Fluent.OLVListSubItem.#ctor">
            <summary>
            Create a OLVListSubItem
            </summary>
        </member>
        <member name="M:Fluent.OLVListSubItem.#ctor(System.Object,System.String,System.Object)">
            <summary>
            Create a OLVListSubItem that shows the given string and image
            </summary>
        </member>
        <member name="P:Fluent.OLVListSubItem.CellPadding">
            <summary>
            Gets or sets how many pixels will be left blank around this cell
            </summary>
            <remarks>This setting only takes effect when the control is owner drawn.</remarks>
        </member>
        <member name="P:Fluent.OLVListSubItem.CellVerticalAlignment">
            <summary>
            Gets or sets how this cell will be vertically aligned
            </summary>
            <remarks>This setting only takes effect when the control is owner drawn.</remarks>
        </member>
        <member name="P:Fluent.OLVListSubItem.ModelValue">
            <summary>
            Gets or sets the model value is being displayed by this subitem.
            </summary>
        </member>
        <member name="P:Fluent.OLVListSubItem.HasDecoration">
            <summary>
            Gets if this subitem has any decorations set for it.
            </summary>
        </member>
        <member name="P:Fluent.OLVListSubItem.Decoration">
            <summary>
            Gets or sets the decoration that will be drawn over this item
            </summary>
            <remarks>Setting this replaces all other decorations</remarks>
        </member>
        <member name="P:Fluent.OLVListSubItem.Decorations">
            <summary>
            Gets the collection of decorations that will be drawn over this item
            </summary>
        </member>
        <member name="P:Fluent.OLVListSubItem.ImageSelector">
            <summary>
            Get or set the image that should be shown against this item
            </summary>
            <remarks><para>This can be an Image, a string or an int. A string or an int will
            be used as an index into the small image list.</para></remarks>
        </member>
        <member name="P:Fluent.OLVListSubItem.Url">
            <summary>
            Gets or sets the url that should be invoked when this subitem is clicked
            </summary>
        </member>
        <member name="P:Fluent.OLVListSubItem.Selected">
            <summary>
            Gets or sets whether this cell is selected
            </summary>
        </member>
        <member name="F:Fluent.OLVListSubItem.AnimationState">
            <summary>
            Return the state of the animatation of the image on this subitem.
            Null means there is either no image, or it is not an animation
            </summary>
        </member>
        <member name="T:Fluent.HitTestLocation">
            <summary>
            An indication of where a hit was within FluentListView cell
            </summary>
        </member>
        <member name="F:Fluent.HitTestLocation.Nothing">
            <summary>
            Nowhere
            </summary>
        </member>
        <member name="F:Fluent.HitTestLocation.Text">
            <summary>
            On the text
            </summary>
        </member>
        <member name="F:Fluent.HitTestLocation.Image">
            <summary>
            On the image
            </summary>
        </member>
        <member name="F:Fluent.HitTestLocation.CheckBox">
            <summary>
            On the checkbox
            </summary>
        </member>
        <member name="F:Fluent.HitTestLocation.ExpandButton">
            <summary>
            On the expand button (TreeListView)
            </summary>
        </member>
        <member name="F:Fluent.HitTestLocation.Button">
            <summary>
            in a button (cell must have ButtonRenderer)
            </summary>
        </member>
        <member name="F:Fluent.HitTestLocation.InCell">
            <summary>
            in the cell but not in any more specific location
            </summary>
        </member>
        <member name="F:Fluent.HitTestLocation.UserDefined">
            <summary>
            UserDefined location1 (used for custom renderers)
            </summary>
        </member>
        <member name="F:Fluent.HitTestLocation.GroupExpander">
            <summary>
            On the expand/collapse widget of the group
            </summary>
        </member>
        <member name="F:Fluent.HitTestLocation.Group">
            <summary>
            Somewhere on a group
            </summary>
        </member>
        <member name="F:Fluent.HitTestLocation.Header">
            <summary>
            Somewhere in a column header
            </summary>
        </member>
        <member name="F:Fluent.HitTestLocation.HeaderCheckBox">
            <summary>
            Somewhere in a column header checkbox
            </summary>
        </member>
        <member name="F:Fluent.HitTestLocation.HeaderDivider">
            <summary>
            Somewhere in a header divider
            </summary>
        </member>
        <member name="T:Fluent.HitTestLocationEx">
            <summary>
            A collection of ListViewHitTest constants
            </summary>
        </member>
        <member name="F:Fluent.HitTestLocationEx.LVHT_NOWHERE">
            <summary>
            
            </summary>
        </member>
        <member name="F:Fluent.HitTestLocationEx.LVHT_ONITEMICON">
            <summary>
            
            </summary>
        </member>
        <member name="F:Fluent.HitTestLocationEx.LVHT_ONITEMLABEL">
            <summary>
            
            </summary>
        </member>
        <member name="F:Fluent.HitTestLocationEx.LVHT_ONITEMSTATEICON">
            <summary>
            
            </summary>
        </member>
        <member name="F:Fluent.HitTestLocationEx.LVHT_ONITEM">
            <summary>
            
            </summary>
        </member>
        <member name="F:Fluent.HitTestLocationEx.LVHT_ABOVE">
            <summary>
            
            </summary>
        </member>
        <member name="F:Fluent.HitTestLocationEx.LVHT_BELOW">
            <summary>
            
            </summary>
        </member>
        <member name="F:Fluent.HitTestLocationEx.LVHT_TORIGHT">
            <summary>
            
            </summary>
        </member>
        <member name="F:Fluent.HitTestLocationEx.LVHT_TOLEFT">
            <summary>
            
            </summary>
        </member>
        <member name="F:Fluent.HitTestLocationEx.LVHT_EX_GROUP_HEADER">
            <summary>
            
            </summary>
        </member>
        <member name="F:Fluent.HitTestLocationEx.LVHT_EX_GROUP_FOOTER">
            <summary>
            
            </summary>
        </member>
        <member name="F:Fluent.HitTestLocationEx.LVHT_EX_GROUP_COLLAPSE">
            <summary>
            
            </summary>
        </member>
        <member name="F:Fluent.HitTestLocationEx.LVHT_EX_GROUP_BACKGROUND">
            <summary>
            
            </summary>
        </member>
        <member name="F:Fluent.HitTestLocationEx.LVHT_EX_GROUP_STATEICON">
            <summary>
            
            </summary>
        </member>
        <member name="F:Fluent.HitTestLocationEx.LVHT_EX_GROUP_SUBSETLINK">
            <summary>
            
            </summary>
        </member>
        <member name="F:Fluent.HitTestLocationEx.LVHT_EX_GROUP">
            <summary>
            
            </summary>
        </member>
        <member name="F:Fluent.HitTestLocationEx.LVHT_EX_GROUP_MINUS_FOOTER_AND_BKGRD">
            <summary>
            
            </summary>
        </member>
        <member name="F:Fluent.HitTestLocationEx.LVHT_EX_ONCONTENTS">
            <summary>
            
            </summary>
        </member>
        <member name="F:Fluent.HitTestLocationEx.LVHT_EX_FOOTER">
            <summary>
            
            </summary>
        </member>
        <member name="T:Fluent.OlvListViewHitTestInfo">
            <summary>
            Instances of this class encapsulate the information gathered during a OlvHitTest()
            operation.
            </summary>
            <remarks>Custom renderers can use HitTestLocation.UserDefined and the UserData
            object to store more specific locations for use during event handlers.</remarks>
        </member>
        <member name="M:Fluent.OlvListViewHitTestInfo.#ctor(Fluent.OLVListItem,Fluent.OLVListSubItem,System.Int32,Fluent.OLVGroup,System.Int32)">
            <summary>
            Create a OlvListViewHitTestInfo
            </summary>
        </member>
        <member name="M:Fluent.OlvListViewHitTestInfo.#ctor(Fluent.Lists.AdvancedListView,System.Int32,System.Boolean,System.Int32)">
            <summary>
            Create a OlvListViewHitTestInfo when the header was hit
            </summary>
        </member>
        <member name="F:Fluent.OlvListViewHitTestInfo.HitTestLocation">
            <summary>
            Where is the hit location?
            </summary>
        </member>
        <member name="F:Fluent.OlvListViewHitTestInfo.HitTestLocationEx">
            <summary>
            Where is the hit location?
            </summary>
        </member>
        <member name="F:Fluent.OlvListViewHitTestInfo.Group">
            <summary>
            Which group was hit?
            </summary>
        </member>
        <member name="F:Fluent.OlvListViewHitTestInfo.UserData">
            <summary>
            Custom renderers can use this information to supply more details about the hit location
            </summary>
        </member>
        <member name="P:Fluent.OlvListViewHitTestInfo.Item">
            <summary>
            Gets the item that was hit
            </summary>
        </member>
        <member name="P:Fluent.OlvListViewHitTestInfo.SubItem">
            <summary>
            Gets the subitem that was hit
            </summary>
        </member>
        <member name="P:Fluent.OlvListViewHitTestInfo.Location">
            <summary>
            Gets the part of the subitem that was hit
            </summary>
        </member>
        <member name="P:Fluent.OlvListViewHitTestInfo.ListView">
            <summary>
            Gets the FluentListView that was tested
            </summary>
        </member>
        <member name="P:Fluent.OlvListViewHitTestInfo.RowObject">
            <summary>
            Gets the model object that was hit
            </summary>
        </member>
        <member name="P:Fluent.OlvListViewHitTestInfo.RowIndex">
            <summary>
            Gets the index of the row under the hit point or -1
            </summary>
        </member>
        <member name="P:Fluent.OlvListViewHitTestInfo.ColumnIndex">
            <summary>
            Gets the index of the column under the hit point
            </summary>
        </member>
        <member name="P:Fluent.OlvListViewHitTestInfo.HeaderDividerIndex">
            <summary>
            Gets the index of the header divider
            </summary>
        </member>
        <member name="P:Fluent.OlvListViewHitTestInfo.Column">
            <summary>
            Gets the column that was hit
            </summary>
        </member>
        <member name="M:Fluent.OlvListViewHitTestInfo.ToString">
            <summary>
            Returns a string that represents the current object.
            </summary>
            <returns>
            A string that represents the current object.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="T:Fluent.IVirtualGroups">
            <summary>
            A IVirtualGroups is the interface that a virtual list must implement to support virtual groups
            </summary>
        </member>
        <member name="M:Fluent.IVirtualGroups.GetGroups(Fluent.GroupingParameters)">
            <summary>
            Return the list of groups that should be shown according to the given parameters
            </summary>
            <param name="parameters"></param>
            <returns></returns>
        </member>
        <member name="M:Fluent.IVirtualGroups.GetGroupMember(Fluent.OLVGroup,System.Int32)">
            <summary>
            Return the index of the item that appears at the given position within the given group.
            </summary>
            <param name="group"></param>
            <param name="indexWithinGroup"></param>
            <returns></returns>
        </member>
        <member name="M:Fluent.IVirtualGroups.GetGroup(System.Int32)">
            <summary>
            Return the index of the group to which the given item belongs
            </summary>
            <param name="itemIndex"></param>
            <returns></returns>
        </member>
        <member name="M:Fluent.IVirtualGroups.GetIndexWithinGroup(Fluent.OLVGroup,System.Int32)">
            <summary>
            Return the index at which the given item is shown in the given group
            </summary>
            <param name="group"></param>
            <param name="itemIndex"></param>
            <returns></returns>
        </member>
        <member name="M:Fluent.IVirtualGroups.CacheHint(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            A hint that the given range of items are going to be required
            </summary>
            <param name="fromGroupIndex"></param>
            <param name="fromIndex"></param>
            <param name="toGroupIndex"></param>
            <param name="toIndex"></param>
        </member>
        <member name="T:Fluent.AbstractVirtualGroups">
            <summary>
            This is a safe, do nothing implementation of a grouping strategy
            </summary>
        </member>
        <member name="M:Fluent.AbstractVirtualGroups.GetGroups(Fluent.GroupingParameters)">
            <summary>
            Return the list of groups that should be shown according to the given parameters
            </summary>
            <param name="parameters"></param>
            <returns></returns>
        </member>
        <member name="M:Fluent.AbstractVirtualGroups.GetGroupMember(Fluent.OLVGroup,System.Int32)">
            <summary>
            Return the index of the item that appears at the given position within the given group.
            </summary>
            <param name="group"></param>
            <param name="indexWithinGroup"></param>
            <returns></returns>
        </member>
        <member name="M:Fluent.AbstractVirtualGroups.GetGroup(System.Int32)">
            <summary>
            Return the index of the group to which the given item belongs
            </summary>
            <param name="itemIndex"></param>
            <returns></returns>
        </member>
        <member name="M:Fluent.AbstractVirtualGroups.GetIndexWithinGroup(Fluent.OLVGroup,System.Int32)">
            <summary>
            Return the index at which the given item is shown in the given group
            </summary>
            <param name="group"></param>
            <param name="itemIndex"></param>
            <returns></returns>
        </member>
        <member name="M:Fluent.AbstractVirtualGroups.CacheHint(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            A hint that the given range of items are going to be required
            </summary>
            <param name="fromGroupIndex"></param>
            <param name="fromIndex"></param>
            <param name="toGroupIndex"></param>
            <param name="toIndex"></param>
        </member>
        <member name="T:Fluent.FastListGroupingStrategy">
            <summary>
            Provides grouping functionality to a FastFluentListView
            </summary>
        </member>
        <member name="M:Fluent.FastListGroupingStrategy.GetGroups(Fluent.GroupingParameters)">
            <summary>
            Create groups for FastListView
            </summary>
            <param name="parmameters"></param>
            <returns></returns>
        </member>
        <member name="M:Fluent.FastListGroupingStrategy.GetGroupMember(Fluent.OLVGroup,System.Int32)">
            <summary>
            
            </summary>
            <param name="group"></param>
            <param name="indexWithinGroup"></param>
            <returns></returns>
        </member>
        <member name="M:Fluent.FastListGroupingStrategy.GetGroup(System.Int32)">
            <summary>
            
            </summary>
            <param name="itemIndex"></param>
            <returns></returns>
        </member>
        <member name="M:Fluent.FastListGroupingStrategy.GetIndexWithinGroup(Fluent.OLVGroup,System.Int32)">
            <summary>
            
            </summary>
            <param name="group"></param>
            <param name="itemIndex"></param>
            <returns></returns>
        </member>
        <member name="T:Fluent.IOwnerDataCallback">
            <summary>
            This is the COM interface that a ListView must be given in order for groups in virtual lists to work.
            </summary>
            <remarks>
            This interface is NOT documented by MS. It was found on Greg Chapell's site. This means that there is
            no guarantee that it will work on future versions of Windows, nor continue to work on current ones.
            </remarks>
        </member>
        <member name="M:Fluent.IOwnerDataCallback.GetItemPosition(System.Int32,Fluent.NativeMethods.POINT@)">
            <summary>
            Not sure what this does
            </summary>
            <param name="i"></param>
            <param name="pt"></param>
        </member>
        <member name="M:Fluent.IOwnerDataCallback.SetItemPosition(System.Int32,Fluent.NativeMethods.POINT)">
            <summary>
            Not sure what this does
            </summary>
            <param name="t"></param>
            <param name="pt"></param>
        </member>
        <member name="M:Fluent.IOwnerDataCallback.GetItemInGroup(System.Int32,System.Int32,System.Int32@)">
            <summary>
            Get the index of the item that occurs at the n'th position of the indicated group.
            </summary>
            <param name="groupIndex">Index of the group</param>
            <param name="n">Index within the group</param>
            <param name="itemIndex">Index of the item within the whole list</param>
        </member>
        <member name="M:Fluent.IOwnerDataCallback.GetItemGroup(System.Int32,System.Int32,System.Int32@)">
            <summary>
            Get the index of the group to which the given item belongs
            </summary>
            <param name="itemIndex">Index of the item within the whole list</param>
            <param name="occurrenceCount">Which occurences of the item is wanted</param>
            <param name="groupIndex">Index of the group</param>
        </member>
        <member name="M:Fluent.IOwnerDataCallback.GetItemGroupCount(System.Int32,System.Int32@)">
            <summary>
            Get the number of groups that contain the given item
            </summary>
            <param name="itemIndex">Index of the item within the whole list</param>
            <param name="occurrenceCount">How many groups does it occur within</param>
        </member>
        <member name="M:Fluent.IOwnerDataCallback.OnCacheHint(Fluent.NativeMethods.LVITEMINDEX,Fluent.NativeMethods.LVITEMINDEX)">
            <summary>
            A hint to prepare any cache for the given range of requests
            </summary>
            <param name="i"></param>
            <param name="j"></param>
        </member>
        <member name="T:Fluent.OwnerDataCallbackImpl">
            <summary>
            A default implementation of the IOwnerDataCallback interface
            </summary>
        </member>
        <member name="T:Fluent.IVirtualListDataSource">
            <summary>
            A VirtualListDataSource is a complete manner to provide functionality to a virtual list.
            An object that implements this interface provides a VirtualFluentListView with all the
            information it needs to be fully functional.
            </summary>
            <remarks>Implementors must provide functioning implementations of at least GetObjectCount()
            and GetNthObject(), otherwise nothing will appear in the list.</remarks>
        </member>
        <member name="M:Fluent.IVirtualListDataSource.GetNthObject(System.Int32)">
            <summary>
            Return the object that should be displayed at the n'th row.
            </summary>
            <param name="n">The index of the row whose object is to be returned.</param>
            <returns>The model object at the n'th row, or null if the fetching was unsuccessful.</returns>
        </member>
        <member name="M:Fluent.IVirtualListDataSource.GetObjectCount">
            <summary>
            Return the number of rows that should be visible in the virtual list
            </summary>
            <returns>The number of rows the list view should have.</returns>
        </member>
        <member name="M:Fluent.IVirtualListDataSource.GetObjectIndex(System.Object)">
            <summary>
            Get the index of the row that is showing the given model object
            </summary>
            <param name="model">The model object sought</param>
            <returns>The index of the row showing the model, or -1 if the object could not be found.</returns>
        </member>
        <member name="M:Fluent.IVirtualListDataSource.PrepareCache(System.Int32,System.Int32)">
            <summary>
            The ListView is about to request the given range of items. Do
            whatever caching seems appropriate.
            </summary>
            <param name="first"></param>
            <param name="last"></param>
        </member>
        <member name="M:Fluent.IVirtualListDataSource.SearchText(System.String,System.Int32,System.Int32,Fluent.OLVColumn)">
            <summary>
            Find the first row that "matches" the given text in the given range.
            </summary>
            <param name="value">The text typed by the user</param>
            <param name="first">Start searching from this index. This may be greater than the 'to' parameter, 
            in which case the search should descend</param>
            <param name="last">Do not search beyond this index. This may be less than the 'from' parameter.</param>
            <param name="column">The column that should be considered when looking for a match.</param>
            <returns>Return the index of row that was matched, or -1 if no match was found</returns>
        </member>
        <member name="M:Fluent.IVirtualListDataSource.Sort(Fluent.OLVColumn,System.Windows.Forms.SortOrder)">
            <summary>
            Sort the model objects in the data source.
            </summary>
            <param name="column"></param>
            <param name="order"></param>
        </member>
        <member name="M:Fluent.IVirtualListDataSource.AddObjects(System.Collections.ICollection)">
            <summary>
            Add the given collection of model objects to this control.
            </summary>
            <param name="modelObjects">A collection of model objects</param>
        </member>
        <member name="M:Fluent.IVirtualListDataSource.InsertObjects(System.Int32,System.Collections.ICollection)">
            <summary>
            Insert the given collection of model objects to this control at the position
            </summary>
            <param name="index">Index where the collection will be added</param>
            <param name="modelObjects">A collection of model objects</param>
        </member>
        <member name="M:Fluent.IVirtualListDataSource.RemoveObjects(System.Collections.ICollection)">
            <summary>
            Remove all of the given objects from the control
            </summary>
            <param name="modelObjects">Collection of objects to be removed</param>
        </member>
        <member name="M:Fluent.IVirtualListDataSource.SetObjects(System.Collections.IEnumerable)">
            <summary>
            Set the collection of objects that this control will show.
            </summary>
            <param name="collection"></param>
        </member>
        <member name="M:Fluent.IVirtualListDataSource.UpdateObject(System.Int32,System.Object)">
            <summary>
            Update/replace the nth object with the given object
            </summary>
            <param name="index"></param>
            <param name="modelObject"></param>
        </member>
        <member name="T:Fluent.IFilterableDataSource">
            <summary>
            This extension allow virtual lists to filter their contents
            </summary>
        </member>
        <member name="M:Fluent.IFilterableDataSource.ApplyFilters(Fluent.IModelFilter,Fluent.IListFilter)">
            <summary>
            All subsequent retrievals on this data source should be filtered
            through the given filters. null means no filtering of that kind.
            </summary>
            <param name="modelFilter"></param>
            <param name="listFilter"></param>
        </member>
        <member name="T:Fluent.AbstractVirtualListDataSource">
            <summary>
            A do-nothing implementation of the VirtualListDataSource interface.
            </summary>
        </member>
        <member name="M:Fluent.AbstractVirtualListDataSource.#ctor(Fluent.Lists.VirtualFluentListView)">
            <summary>
            Creates an AbstractVirtualListDataSource
            </summary>
            <param name="listView"></param>
        </member>
        <member name="F:Fluent.AbstractVirtualListDataSource.listView">
            <summary>
            The list view that this data source is giving information to.
            </summary>
        </member>
        <member name="M:Fluent.AbstractVirtualListDataSource.GetNthObject(System.Int32)">
            <summary>
            
            </summary>
            <param name="n"></param>
            <returns></returns>
        </member>
        <member name="M:Fluent.AbstractVirtualListDataSource.GetObjectCount">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:Fluent.AbstractVirtualListDataSource.GetObjectIndex(System.Object)">
            <summary>
            
            </summary>
            <param name="model"></param>
            <returns></returns>
        </member>
        <member name="M:Fluent.AbstractVirtualListDataSource.PrepareCache(System.Int32,System.Int32)">
            <summary>
            
            </summary>
            <param name="from"></param>
            <param name="to"></param>
        </member>
        <member name="M:Fluent.AbstractVirtualListDataSource.SearchText(System.String,System.Int32,System.Int32,Fluent.OLVColumn)">
            <summary>
            
            </summary>
            <param name="value"></param>
            <param name="first"></param>
            <param name="last"></param>
            <param name="column"></param>
            <returns></returns>
        </member>
        <member name="M:Fluent.AbstractVirtualListDataSource.Sort(Fluent.OLVColumn,System.Windows.Forms.SortOrder)">
            <summary>
            
            </summary>
            <param name="column"></param>
            <param name="order"></param>
        </member>
        <member name="M:Fluent.AbstractVirtualListDataSource.AddObjects(System.Collections.ICollection)">
            <summary>
            
            </summary>
            <param name="modelObjects"></param>
        </member>
        <member name="M:Fluent.AbstractVirtualListDataSource.InsertObjects(System.Int32,System.Collections.ICollection)">
            <summary>
            
            </summary>
            <param name="index"></param>
            <param name="modelObjects"></param>
        </member>
        <member name="M:Fluent.AbstractVirtualListDataSource.RemoveObjects(System.Collections.ICollection)">
            <summary>
            
            </summary>
            <param name="modelObjects"></param>
        </member>
        <member name="M:Fluent.AbstractVirtualListDataSource.SetObjects(System.Collections.IEnumerable)">
            <summary>
            
            </summary>
            <param name="collection"></param>
        </member>
        <member name="M:Fluent.AbstractVirtualListDataSource.UpdateObject(System.Int32,System.Object)">
            <summary>
            Update/replace the nth object with the given object
            </summary>
            <param name="index"></param>
            <param name="modelObject"></param>
        </member>
        <member name="M:Fluent.AbstractVirtualListDataSource.DefaultSearchText(System.String,System.Int32,System.Int32,Fluent.OLVColumn,Fluent.IVirtualListDataSource)">
            <summary>
            This is a useful default implementation of SearchText method, intended to be called
            by implementors of IVirtualListDataSource.
            </summary>
            <param name="value"></param>
            <param name="first"></param>
            <param name="last"></param>
            <param name="column"></param>
            <param name="source"></param>
            <returns></returns>
        </member>
        <member name="M:Fluent.AbstractVirtualListDataSource.ApplyFilters(Fluent.IModelFilter,Fluent.IListFilter)">
            <summary>
            
            </summary>
            <param name="modelFilter"></param>
            <param name="listFilter"></param>
        </member>
        <member name="T:Fluent.VirtualListVersion1DataSource">
            <summary>
            This class mimics the behavior of VirtualFluentListView v1.x.
            </summary>
        </member>
        <member name="M:Fluent.VirtualListVersion1DataSource.#ctor(Fluent.Lists.VirtualFluentListView)">
            <summary>
            Creates a VirtualListVersion1DataSource
            </summary>
            <param name="listView"></param>
        </member>
        <member name="P:Fluent.VirtualListVersion1DataSource.RowGetter">
            <summary>
            How will the n'th object of the data source be fetched?
            </summary>
        </member>
        <member name="M:Fluent.VirtualListVersion1DataSource.GetNthObject(System.Int32)">
            <summary>
            
            </summary>
            <param name="n"></param>
            <returns></returns>
        </member>
        <member name="M:Fluent.VirtualListVersion1DataSource.SearchText(System.String,System.Int32,System.Int32,Fluent.OLVColumn)">
            <summary>
            
            </summary>
            <param name="value"></param>
            <param name="first"></param>
            <param name="last"></param>
            <param name="column"></param>
            <returns></returns>
        </member>
        <member name="T:Fluent.OLVColumn">
            <summary>
            An OLVColumn knows which aspect of an object it should present.
            </summary>
            <remarks>
            The column knows how to:
            <list type="bullet">
            <item><description>extract its aspect from the row object</description></item>
            <item><description>convert an aspect to a string</description></item>
            <item><description>calculate the image for the row object</description></item>
            <item><description>extract a group "key" from the row object</description></item>
            <item><description>convert a group "key" into a title for the group</description></item>
            </list>
            <para>For sorting to work correctly, aspects from the same column
            must be of the same type, that is, the same aspect cannot sometimes
            return strings and other times integers.</para>
            </remarks>
        </member>
        <member name="T:Fluent.OLVColumn.ButtonSizingMode">
            <summary>
            How should the button be sized?
            </summary>
        </member>
        <member name="F:Fluent.OLVColumn.ButtonSizingMode.FixedBounds">
            <summary>
            Every cell will have the same sized button, as indicated by ButtonSize property
            </summary>
        </member>
        <member name="F:Fluent.OLVColumn.ButtonSizingMode.CellBounds">
            <summary>
            Every cell will draw a button that fills the cell, inset by ButtonPadding
            </summary>
        </member>
        <member name="F:Fluent.OLVColumn.ButtonSizingMode.TextBounds">
            <summary>
            Each button will be resized to contain the text of the Aspect
            </summary>
        </member>
        <member name="M:Fluent.OLVColumn.#ctor">
            <summary>
            Create an OLVColumn
            </summary>
        </member>
        <member name="M:Fluent.OLVColumn.#ctor(System.String,System.String)">
            <summary>
            Initialize a column to have the given title, and show the given aspect
            </summary>
            <param name="title">The title of the column</param>
            <param name="aspect">The aspect to be shown in the column</param>
        </member>
        <member name="P:Fluent.OLVColumn.AspectGetter">
            <summary>
            This delegate will be used to extract a value to be displayed in this column.
            </summary>
            <remarks>
            If this is set, AspectName is ignored.
            </remarks>
        </member>
        <member name="P:Fluent.OLVColumn.AspectGetterAutoGenerated">
            <summary>
            Remember if this aspect getter for this column was generated internally, and can therefore
            be regenerated at will
            </summary>
        </member>
        <member name="P:Fluent.OLVColumn.AspectName">
            <summary>
            The name of the property or method that should be called to get the value to display in this column.
            This is only used if a ValueGetterDelegate has not been given.
            </summary>
            <remarks>This name can be dotted to chain references to properties or parameter-less methods.</remarks>
            <example>"DateOfBirth"</example>
            <example>"Owner.HomeAddress.Postcode"</example>
        </member>
        <member name="P:Fluent.OLVColumn.AspectPutter">
            <summary>
            This delegate will be used to put an edited value back into the model object.
            </summary>
            <remarks>
            This does nothing if IsEditable == false.
            </remarks>
        </member>
        <member name="P:Fluent.OLVColumn.AspectToStringConverter">
            <summary>
            The delegate that will be used to translate the aspect to display in this column into a string.
            </summary>
            <remarks>If this value is set, AspectToStringFormat will be ignored.</remarks>
        </member>
        <member name="P:Fluent.OLVColumn.AspectToStringFormat">
            <summary>
            This format string will be used to convert an aspect to its string representation.
            </summary>
            <remarks>
            This string is passed as the first parameter to the String.Format() method.
            This is only used if AspectToStringConverter has not been set.</remarks>
            <example>"{0:C}" to convert a number to currency</example>
        </member>
        <member name="P:Fluent.OLVColumn.AutoCompleteEditor">
            <summary>
            Gets or sets whether the cell editor should use AutoComplete
            </summary>
        </member>
        <member name="P:Fluent.OLVColumn.AutoCompleteEditorMode">
            <summary>
            Gets or sets whether the cell editor should use AutoComplete
            </summary>
        </member>
        <member name="P:Fluent.OLVColumn.CanBeHidden">
            <summary>
            Gets whether this column can be hidden by user actions
            </summary>
            <remarks>This take into account both the Hideable property and whether this column
            is the primary column of the listview (column 0).</remarks>
        </member>
        <member name="P:Fluent.OLVColumn.CellEditUseWholeCell">
            <summary>
            When a cell is edited, should the whole cell be used (minus any space used by checkbox or image)?
            </summary>
            <remarks>
            <para>This is always treated as true when the control is NOT owner drawn.</para>
            <para>
            When this is false (the default) and the control is owner drawn, 
            FluentListView will try to calculate the width of the cell's
            actual contents, and then size the editing control to be just the right width. If this is true,
            the whole width of the cell will be used, regardless of the cell's contents.
            </para>
            <para>If this property is not set on the column, the value from the control will be used
            </para>
            <para>This value is only used when the control is in Details view.</para>
            <para>Regardless of this setting, developers can specify the exact size of the editing control
            by listening for the CellEditStarting event.</para>
            </remarks>
        </member>
        <member name="P:Fluent.OLVColumn.CellEditUseWholeCellEffective">
            <summary>
            Get whether the whole cell should be used when editing a cell in this column
            </summary>
            <remarks>This calculates the current effective value, which may be different to CellEditUseWholeCell</remarks>
        </member>
        <member name="P:Fluent.OLVColumn.CellPadding">
            <summary>
            Gets or sets how many pixels will be left blank around this cells in this column
            </summary>
            <remarks>This setting only takes effect when the control is owner drawn.</remarks>
        </member>
        <member name="P:Fluent.OLVColumn.CellVerticalAlignment">
            <summary>
            Gets or sets how cells in this column will be vertically aligned.
            </summary>
            <remarks>
            <para>
            This setting only takes effect when the control is owner drawn.
            </para>        
            <para>
            If this is not set, the value from the control itself will be used.
            </para>
            </remarks>
        </member>
        <member name="P:Fluent.OLVColumn.CheckBoxes">
            <summary>
            Gets or sets whether this column will show a checkbox.
            </summary>
            <remarks>
            Setting this on column 0 has no effect. Column 0 check box is controlled
            by the CheckBoxes property on the FluentListView itself.
            </remarks>
        </member>
        <member name="P:Fluent.OLVColumn.ClusteringStrategy">
            <summary>
            Gets or sets the clustering strategy used for this column. 
            </summary>
            <remarks>
            <para>
            The clustering strategy is used to build a Filtering menu for this item. 
            If this is null, a useful default will be chosen. 
            </para>
            <para>
            To disable filtering on this colummn, set UseFiltering to false.
            </para>
            <para>
            Cluster strategies belong to a particular column. The same instance
            cannot be shared between multiple columns.
            </para>
            </remarks>
        </member>
        <member name="P:Fluent.OLVColumn.EnableButtonWhenItemIsDisabled">
            <summary>
            Gets or sets whether the button in this column (if this column is drawing buttons) will be enabled
            even if the row itself is disabled
            </summary>
        </member>
        <member name="P:Fluent.OLVColumn.FillsFreeSpace">
            <summary>
            Should this column resize to fill the free space in the listview?
            </summary>
            <remarks>
            <para>
            If you want two (or more) columns to equally share the available free space, set this property to True.
            If you want this column to have a larger or smaller share of the free space, you must
            set the FreeSpaceProportion property explicitly.
            </para>
            <para>
            Space filling columns are still governed by the MinimumWidth and MaximumWidth properties.
            </para>
            /// </remarks>
        </member>
        <member name="P:Fluent.OLVColumn.FreeSpaceProportion">
            <summary>
            What proportion of the unoccupied horizontal space in the control should be given to this column?
            </summary>
            <remarks>
            <para>
            There are situations where it would be nice if a column (normally the rightmost one) would expand as
            the list view expands, so that as much of the column was visible as possible without having to scroll
            horizontally (you should never, ever make your users have to scroll anything horizontally!).
            </para>
            <para>
            A space filling column is resized to occupy a proportion of the unoccupied width of the listview (the
            unoccupied width is the width left over once all the the non-filling columns have been given their space).
            This property indicates the relative proportion of that unoccupied space that will be given to this column.
            The actual value of this property is not important -- only its value relative to the value in other columns.
            For example:
            <list type="bullet">
            <item><description>
            If there is only one space filling column, it will be given all the free space, regardless of the value in FreeSpaceProportion.
            </description></item>
            <item><description>
            If there are two or more space filling columns and they all have the same value for FreeSpaceProportion,
            they will share the free space equally.
            </description></item>
            <item><description>
            If there are three space filling columns with values of 3, 2, and 1
            for FreeSpaceProportion, then the first column with occupy half the free space, the second will
            occupy one-third of the free space, and the third column one-sixth of the free space.
            </description></item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="P:Fluent.OLVColumn.Groupable">
            <summary>
            Gets or sets whether groups will be rebuild on this columns values when this column's header is clicked.
            </summary>
            <remarks>
            <para>This setting is only used when ShowGroups is true.</para>
            <para>
            If this is false, clicking the header will not rebuild groups. It will not provide
            any feedback as to why the list is not being regrouped. It is the programmers responsibility to
            provide appropriate feedback.
            </para>
            <para>When this is false, BeforeCreatingGroups events are still fired, which can be used to allow grouping
            or give feedback, on a case by case basis.</para>
            </remarks>
        </member>
        <member name="P:Fluent.OLVColumn.GroupFormatter">
            <summary>
            This delegate is called when a group has been created but not yet made
            into a real ListViewGroup. The user can take this opportunity to fill
            in lots of other details about the group.
            </summary>
        </member>
        <member name="P:Fluent.OLVColumn.GroupKeyGetter">
            <summary>
            This delegate is called to get the object that is the key for the group
            to which the given row belongs.
            </summary>
        </member>
        <member name="P:Fluent.OLVColumn.GroupKeyToTitleConverter">
            <summary>
            This delegate is called to convert a group key into a title for that group.
            </summary>
        </member>
        <member name="P:Fluent.OLVColumn.GroupWithItemCountFormat">
            <summary>
            When the listview is grouped by this column and group title has an item count,
            how should the lable be formatted?
            </summary>
            <remarks>
            The given format string can/should have two placeholders:
            <list type="bullet">
            <item><description>{0} - the original group title</description></item>
            <item><description>{1} - the number of items in the group</description></item>
            </list>
            </remarks>
            <example>"{0} [{1} items]"</example>
        </member>
        <member name="P:Fluent.OLVColumn.GroupWithItemCountFormatOrDefault">
            <summary>
            Gets this.GroupWithItemCountFormat or a reasonable default
            </summary>
            <remarks>
            If GroupWithItemCountFormat is not set, its value will be taken from the FluentListView if possible.
            </remarks>
        </member>
        <member name="P:Fluent.OLVColumn.GroupWithItemCountSingularFormat">
            <summary>
            When the listview is grouped by this column and a group title has an item count,
            how should the lable be formatted if there is only one item in the group?
            </summary>
            <remarks>
            The given format string can/should have two placeholders:
            <list type="bullet">
            <item><description>{0} - the original group title</description></item>
            <item><description>{1} - the number of items in the group (always 1)</description></item>
            </list>
            </remarks>
            <example>"{0} [{1} item]"</example>
        </member>
        <member name="P:Fluent.OLVColumn.GroupWithItemCountSingularFormatOrDefault">
            <summary>
            Get this.GroupWithItemCountSingularFormat or a reasonable default
            </summary>
            <remarks>
            <para>If this value is not set, the values from the list view will be used</para>
            </remarks>
        </member>
        <member name="P:Fluent.OLVColumn.HasFilterIndicator">
            <summary>
            Gets whether this column should be drawn with a filter indicator in the column header.
            </summary>
        </member>
        <member name="P:Fluent.OLVColumn.HeaderDrawing">
            <summary>
            Gets or sets a delegate that will be used to own draw header column.
            </summary>
        </member>
        <member name="P:Fluent.OLVColumn.HeaderFormatStyle">
            <summary>
            Gets or sets the style that will be used to draw the header for this column
            </summary>
            <remarks>This is only uses when the owning FluentListView has HeaderUsesThemes set to false.</remarks>
        </member>
        <member name="P:Fluent.OLVColumn.HeaderFont">
            <summary>
            Gets or sets the font in which the header for this column will be drawn
            </summary>
            <remarks>You should probably use a HeaderFormatStyle instead of this property</remarks>
            <remarks>This is only uses when HeaderUsesThemes is false.</remarks>
        </member>
        <member name="P:Fluent.OLVColumn.HeaderForeColor">
            <summary>
            Gets or sets the color in which the text of the header for this column will be drawn
            </summary>
            <remarks>You should probably use a HeaderFormatStyle instead of this property</remarks>
            <remarks>This is only uses when HeaderUsesThemes is false.</remarks>
        </member>
        <member name="P:Fluent.OLVColumn.HeaderImageKey">
            <summary>
            Gets or sets whether the text values in this column will act like hyperlinks
            </summary>
            <remarks>This is only taken into account when HeaderUsesThemes is false.</remarks>
        </member>
        <member name="P:Fluent.OLVColumn.HeaderTextAlign">
            <summary>
            Gets or sets how the text of the header will be drawn?
            </summary>
        </member>
        <member name="P:Fluent.OLVColumn.HeaderTextAlignOrDefault">
            <summary>
            Return the text alignment of the header. This will either have been set explicitly,
            or will follow the alignment of the text in the column
            </summary>
        </member>
        <member name="P:Fluent.OLVColumn.HeaderTextAlignAsStringAlignment">
            <summary>
            Gets the header alignment converted to a StringAlignment
            </summary>
        </member>
        <member name="P:Fluent.OLVColumn.HasHeaderImage">
            <summary>
            Gets whether or not this column has an image in the header
            </summary>
        </member>
        <member name="P:Fluent.OLVColumn.HeaderCheckBox">
            <summary>
            Gets or sets whether this header will place a checkbox in the header
            </summary>
        </member>
        <member name="P:Fluent.OLVColumn.HeaderTriStateCheckBox">
            <summary>
            Gets or sets whether this header will place a tri-state checkbox in the header
            </summary>
        </member>
        <member name="P:Fluent.OLVColumn.HeaderCheckState">
            <summary>
            Gets or sets the checkedness of the checkbox in the header of this column
            </summary>
        </member>
        <member name="P:Fluent.OLVColumn.HeaderCheckBoxUpdatesRowCheckBoxes">
            <summary>
            Gets or sets whether the 
            checking/unchecking the value of the header's checkbox will result in the
            checkboxes for all cells in this column being set to the same checked/unchecked.
            Defaults to true.
            </summary>
            <remarks>
            <para>
            There is no reverse of this function that automatically updates the header when the 
            checkedness of a cell changes.
            </para>
            <para>
            This property's behaviour on a TreeListView is probably best describes as undefined 
            and should be avoided.
            </para>
            <para>
            The performance of this action (checking/unchecking all rows) is O(n) where n is the 
            number of rows. It will work on large virtual lists, but it may take some time.
            </para>
            </remarks>
        </member>
        <member name="P:Fluent.OLVColumn.HeaderCheckBoxDisabled">
            <summary>
            Gets or sets whether the checkbox in the header is disabled
            </summary>
            <remarks>
            Clicking on a disabled checkbox does not change its value, though it does raise
            a HeaderCheckBoxChanging event, which allows the programmer the opportunity to do 
            something appropriate.</remarks>
        </member>
        <member name="P:Fluent.OLVColumn.Hideable">
            <summary>
            Gets or sets whether this column can be hidden by the user.
            </summary>
            <remarks>
            <para>Column 0 can never be hidden, regardless of this setting.</para>
            </remarks>
        </member>
        <member name="P:Fluent.OLVColumn.Hyperlink">
            <summary>
            Gets or sets whether the text values in this column will act like hyperlinks
            </summary>
        </member>
        <member name="P:Fluent.OLVColumn.ImageAspectName">
            <summary>
            This is the name of property that will be invoked to get the image selector of the
            image that should be shown in this column.
            It can return an int, string, Image or null.
            </summary>
            <remarks>
            <para>This is ignored if ImageGetter is not null.</para>
            <para>The property can use these return value to identify the image:</para>
            <list type="bullet">
            <item><description>null or -1 -- indicates no image</description></item>
            <item><description>an int -- the int value will be used as an index into the image list</description></item>
            <item><description>a String -- the string value will be used as a key into the image list</description></item>
            <item><description>an Image -- the Image will be drawn directly (only in OwnerDrawn mode)</description></item>
            </list>
            </remarks>
        </member>
        <member name="P:Fluent.OLVColumn.ImageGetter">
            <summary>
            This delegate is called to get the image selector of the image that should be shown in this column.
            It can return an int, string, Image or null.
            </summary>
            <remarks><para>This delegate can use these return value to identify the image:</para>
            <list type="bullet">
            <item><description>null or -1 -- indicates no image</description></item>
            <item><description>an int -- the int value will be used as an index into the image list</description></item>
            <item><description>a String -- the string value will be used as a key into the image list</description></item>
            <item><description>an Image -- the Image will be drawn directly (only in OwnerDrawn mode)</description></item>
            </list>
            </remarks>
        </member>
        <member name="P:Fluent.OLVColumn.IsButton">
            <summary>
            Gets or sets whether this column will draw buttons in its cells
            </summary>
            <remarks>
            <para>
            When this is set to true, the renderer for the column is become a ColumnButtonRenderer
            if it isn't already. If this is set to false, any previous button renderer will be discarded
            </para>
            If the cell's aspect is null or empty, nothing will be drawn in the cell.</remarks>
        </member>
        <member name="M:Fluent.OLVColumn.CreateColumnButtonRenderer">
            <summary>
            Create a ColumnButtonRenderer to draw buttons in this column
            </summary>
            <returns></returns>
        </member>
        <member name="M:Fluent.OLVColumn.FillInColumnButtonRenderer">
            <summary>
            Fill in details to our ColumnButtonRenderer based on the properties set on the column
            </summary>
        </member>
        <member name="P:Fluent.OLVColumn.ButtonMaxWidth">
            <summary>
            Gets or sets the maximum width that a button can occupy.
            -1 means there is no maximum width.
            </summary>
            <remarks>This is only considered when the SizingMode is TextBounds</remarks>
        </member>
        <member name="P:Fluent.OLVColumn.ButtonPadding">
            <summary>
            Gets or sets the extra space that surrounds the cell when the SizingMode is TextBounds
            </summary>
        </member>
        <member name="P:Fluent.OLVColumn.ButtonSize">
            <summary>
            Gets or sets the size of the button when the SizingMode is FixedBounds
            </summary>
            <remarks>If this is not set, the bounds of the cell will be used</remarks>
        </member>
        <member name="P:Fluent.OLVColumn.ButtonSizing">
            <summary>
            Gets or sets how each button will be sized if this column is displaying buttons
            </summary>
        </member>
        <member name="P:Fluent.OLVColumn.IsEditable">
            <summary>
            Can the values shown in this column be edited?
            </summary>
            <remarks>This defaults to true, since the primary means to control the editability of a listview
            is on the listview itself. Once a listview is editable, all the columns are too, unless the
            programmer explicitly marks them as not editable</remarks>
        </member>
        <member name="P:Fluent.OLVColumn.IsFixedWidth">
            <summary>
            Is this column a fixed width column?
            </summary>
        </member>
        <member name="P:Fluent.OLVColumn.IsTileViewColumn">
            <summary>
            Get/set whether this column should be used when the view is switched to tile view.
            </summary>
            <remarks>Column 0 is always included in tileview regardless of this setting.
            Tile views do not work well with many "columns" of information. 
            Two or three works best.</remarks>
        </member>
        <member name="P:Fluent.OLVColumn.IsHeaderVertical">
            <summary>
            Gets or sets whether the text of this header should be rendered vertically.
            </summary>
            <remarks>
            <para>If this is true, it is a good idea to set ToolTipText to the name of the column so it's easy to read.</para>
            <para>Vertical headers are text only. They do not draw their image.</para>
            </remarks>
        </member>
        <member name="P:Fluent.OLVColumn.IsVisible">
            <summary>
            Can this column be seen by the user?
            </summary>
            <remarks>After changing this value, you must call RebuildColumns() before the changes will take effect.</remarks>
        </member>
        <member name="P:Fluent.OLVColumn.LastDisplayIndex">
            <summary>
            Where was this column last positioned within the Detail view columns
            </summary>
            <remarks>DisplayIndex is volatile. Once a column is removed from the control,
            there is no way to discover where it was in the display order. This property
            guards that information even when the column is not in the listview's active columns.</remarks>
        </member>
        <member name="P:Fluent.OLVColumn.MaximumWidth">
            <summary>
            What is the maximum width that the user can give to this column?
            </summary>
            <remarks>-1 means there is no maximum width. Give this the same value as MinimumWidth to make a fixed width column.</remarks>
        </member>
        <member name="P:Fluent.OLVColumn.MinimumWidth">
            <summary>
            What is the minimum width that the user can give to this column?
            </summary>
            <remarks>-1 means there is no minimum width. Give this the same value as MaximumWidth to make a fixed width column.</remarks>
        </member>
        <member name="P:Fluent.OLVColumn.Renderer">
            <summary>
            Get/set the renderer that will be invoked when a cell needs to be redrawn
            </summary>
        </member>
        <member name="P:Fluent.OLVColumn.RendererDelegate">
            <summary>
            This delegate is called when a cell needs to be drawn in OwnerDrawn mode.
            </summary>
            <remarks>This method is kept primarily for backwards compatibility.
            New code should implement an IRenderer, though this property will be maintained.</remarks>
        </member>
        <member name="P:Fluent.OLVColumn.Searchable">
            <summary>
            Gets or sets whether the text in this column's cell will be used when doing text searching.
            </summary>
            <remarks>
            <para>
            If this is false, text filters will not trying searching this columns cells when looking for matches.
            </para>
            </remarks>
        </member>
        <member name="P:Fluent.OLVColumn.SearchValueGetter">
            <summary>
            Gets or sets a delegate which will return the array of text values that should be 
            considered for text matching when using a text based filter.
            </summary>
        </member>
        <member name="P:Fluent.OLVColumn.ShowTextInHeader">
            <summary>
            Gets or sets whether the header for this column will include the column's Text.
            </summary>
            <remarks>
            <para>
            If this is false, the only thing rendered in the column header will be the image from <see cref="P:Fluent.OLVColumn.HeaderImageKey"/>.
            </para>
            <para>This setting is only considered when <see cref="P:Fluent.Lists.AdvancedListView.HeaderUsesThemes"/> is false on the owning FluentListView.</para>
            </remarks>
        </member>
        <member name="P:Fluent.OLVColumn.Sortable">
            <summary>
            Gets or sets whether the contents of the list will be resorted when the user clicks the 
            header of this column.
            </summary>
            <remarks>
            <para>
            If this is false, clicking the header will not sort the list, but will not provide
            any feedback as to why the list is not being sorted. It is the programmers responsibility to
            provide appropriate feedback.
            </para>
            <para>When this is false, BeforeSorting events are still fired, which can be used to allow sorting
            or give feedback, on a case by case basis.</para>
            </remarks>
        </member>
        <member name="P:Fluent.OLVColumn.TextAlign">
            <summary>
            Gets or sets the horizontal alignment of the contents of the column.
            </summary>
            <remarks>.NET will not allow column 0 to have any alignment except
            to the left. We can't change the basic behaviour of the listview,
            but when owner drawn, column 0 can now have other alignments.</remarks>
        </member>
        <member name="P:Fluent.OLVColumn.TextStringAlign">
            <summary>
            Gets the StringAlignment equivilent of the column text alignment
            </summary>
        </member>
        <member name="P:Fluent.OLVColumn.ToolTipText">
            <summary>
            What string should be displayed when the mouse is hovered over the header of this column?
            </summary>
            <remarks>If a HeaderToolTipGetter is installed on the owning FluentListView, this
            value will be ignored.</remarks>
        </member>
        <member name="P:Fluent.OLVColumn.TriStateCheckBoxes">
            <summary>
            Should this column have a tri-state checkbox?
            </summary>
            <remarks>
            If this is true, the user can choose the third state (normally Indeterminate).
            </remarks>
        </member>
        <member name="P:Fluent.OLVColumn.UseInitialLetterForGroup">
            <summary>
            Group objects by the initial letter of the aspect of the column
            </summary>
            <remarks>
            One common pattern is to group column by the initial letter of the value for that group.
            The aspect must be a string (obviously).
            </remarks>
        </member>
        <member name="P:Fluent.OLVColumn.UseFiltering">
            <summary>
            Gets or sets whether or not this column should be user filterable
            </summary>
        </member>
        <member name="P:Fluent.OLVColumn.ValueBasedFilter">
            <summary>
            Gets or sets a filter that will only include models where the model's value
            for this column is one of the values in ValuesChosenForFiltering
            </summary>
        </member>
        <member name="P:Fluent.OLVColumn.ValuesChosenForFiltering">
            <summary>
            Gets or sets the values that will be used to generate a filter for this
            column. For a model to be included by the generated filter, its value for this column
            must be in this list. If the list is null or empty, this column will
            not be used for filtering.
            </summary>
        </member>
        <member name="P:Fluent.OLVColumn.Width">
            <summary>
            What is the width of this column?
            </summary>
        </member>
        <member name="P:Fluent.OLVColumn.WordWrap">
            <summary>
            Gets or set whether the contents of this column's cells should be word wrapped
            </summary>
            <remarks>If this column uses a custom IRenderer (that is, one that is not descended
            from BaseRenderer), then that renderer is responsible for implementing word wrapping.</remarks>
        </member>
        <member name="M:Fluent.OLVColumn.ConvertGroupKeyToTitle(System.Object)">
            <summary>
            For a given group value, return the string that should be used as the groups title.
            </summary>
            <param name="value">The group key that is being converted to a title</param>
            <returns>string</returns>
        </member>
        <member name="M:Fluent.OLVColumn.GetCheckState(System.Object)">
            <summary>
            Get the checkedness of the given object for this column
            </summary>
            <param name="rowObject">The row object that is being displayed</param>
            <returns>The checkedness of the object</returns>
        </member>
        <member name="M:Fluent.OLVColumn.PutCheckState(System.Object,System.Windows.Forms.CheckState)">
            <summary>
            Put the checkedness of the given object for this column
            </summary>
            <param name="rowObject">The row object that is being displayed</param>
            <param name="newState"></param>
            <returns>The checkedness of the object</returns>
        </member>
        <member name="M:Fluent.OLVColumn.GetAspectByName(System.Object)">
            <summary>
            For a given row object, extract the value indicated by the AspectName property of this column.
            </summary>
            <param name="rowObject">The row object that is being displayed</param>
            <returns>An object, which is the aspect named by AspectName</returns>
        </member>
        <member name="M:Fluent.OLVColumn.GetGroupKey(System.Object)">
            <summary>
            For a given row object, return the object that is the key of the group that this row belongs to.
            </summary>
            <param name="rowObject">The row object that is being displayed</param>
            <returns>Group key object</returns>
        </member>
        <member name="M:Fluent.OLVColumn.GetImage(System.Object)">
            <summary>
            For a given row object, return the image selector of the image that should displayed in this column.
            </summary>
            <param name="rowObject">The row object that is being displayed</param>
            <returns>int or string or Image. int or string will be used as index into image list. null or -1 means no image</returns>
        </member>
        <member name="M:Fluent.OLVColumn.GetCheckStateImage(System.Object)">
            <summary>
            Return the image that represents the check box for the given model
            </summary>
            <param name="rowObject"></param>
            <returns></returns>
        </member>
        <member name="M:Fluent.OLVColumn.GetSearchValues(System.Object)">
            <summary>
            For a given row object, return the strings that will be searched when trying to filter by string.
            </summary>
            <remarks>
            This will normally be the simple GetStringValue result, but if this column is non-textual (e.g. image)
            you might want to install a SearchValueGetter delegate which can return something that could be used
            for text filtering.
            </remarks>
            <param name="rowObject"></param>
            <returns>The array of texts to be searched. If this returns null, search will not match that object.</returns>
        </member>
        <member name="M:Fluent.OLVColumn.GetStringValue(System.Object)">
            <summary>
            For a given row object, return the string representation of the value shown in this column.
            </summary>
            <remarks>
            For aspects that are string (e.g. aPerson.Name), the aspect and its string representation are the same.
            For non-strings (e.g. aPerson.DateOfBirth), the string representation is very different.
            </remarks>
            <param name="rowObject"></param>
            <returns></returns>
        </member>
        <member name="M:Fluent.OLVColumn.GetValue(System.Object)">
            <summary>
            For a given row object, return the object that is to be displayed in this column.
            </summary>
            <param name="rowObject">The row object that is being displayed</param>
            <returns>An object, which is the aspect to be displayed</returns>
        </member>
        <member name="M:Fluent.OLVColumn.PutAspectByName(System.Object,System.Object)">
            <summary>
            Update the given model object with the given value using the column's
            AspectName.
            </summary>
            <param name="rowObject">The model object to be updated</param>
            <param name="newValue">The value to be put into the model</param>
        </member>
        <member name="M:Fluent.OLVColumn.PutValue(System.Object,System.Object)">
            <summary>
            Update the given model object with the given value
            </summary>
            <param name="rowObject">The model object to be updated</param>
            <param name="newValue">The value to be put into the model</param>
        </member>
        <member name="M:Fluent.OLVColumn.ValueToString(System.Object)">
            <summary>
            Convert the aspect object to its string representation.
            </summary>
            <remarks>
            If the column has been given a AspectToStringConverter, that will be used to do
            the conversion, otherwise just use ToString(). 
            The returned value will not be null. Nulls are always converted
            to empty strings.
            </remarks>
            <param name="value">The value of the aspect that should be displayed</param>
            <returns>A string representation of the aspect</returns>
        </member>
        <member name="M:Fluent.OLVColumn.DecideDefaultClusteringStrategy">
            <summary>
            Decide the clustering strategy that will be used for this column
            </summary>
            <returns></returns>
        </member>
        <member name="P:Fluent.OLVColumn.DataType">
            <summary>
            Gets or sets the type of data shown in this column.
            </summary>
            <remarks>If this is not set, it will try to get the type
            by looking through the rows of the listview.</remarks>
        </member>
        <member name="E:Fluent.OLVColumn.VisibilityChanged">
            <summary>
            This event is triggered when the visibility of this column changes.
            </summary>
        </member>
        <member name="M:Fluent.OLVColumn.OnVisibilityChanged(System.EventArgs)">
            <summary>
            Tell the world when visibility of a column changes.
            </summary>
        </member>
        <member name="M:Fluent.OLVColumn.MakeGroupies(System.Object[],System.String[])">
            <summary>
            Create groupies
            This is an untyped version to help with Generator and OLVColumn attributes
            </summary>
            <param name="values"></param>
            <param name="descriptions"></param>
        </member>
        <member name="M:Fluent.OLVColumn.MakeGroupies``1(``0[],System.String[])">
            <summary>
            Create groupies
            </summary>
            <typeparam name="T"></typeparam>
            <param name="values"></param>
            <param name="descriptions"></param>
        </member>
        <member name="M:Fluent.OLVColumn.MakeGroupies``1(``0[],System.String[],System.Object[])">
            <summary>
            Create groupies
            </summary>
            <typeparam name="T"></typeparam>
            <param name="values"></param>
            <param name="descriptions"></param>
            <param name="images"></param>
        </member>
        <member name="M:Fluent.OLVColumn.MakeGroupies``1(``0[],System.String[],System.Object[],System.String[])">
            <summary>
            Create groupies
            </summary>
            <typeparam name="T"></typeparam>
            <param name="values"></param>
            <param name="descriptions"></param>
            <param name="images"></param>
            <param name="subtitles"></param>
        </member>
        <member name="M:Fluent.OLVColumn.MakeGroupies``1(``0[],System.String[],System.Object[],System.String[],System.String[])">
            <summary>
            Create groupies.
            Install delegates that will group the columns aspects into progressive partitions.
            If an aspect is less than value[n], it will be grouped with description[n].
            If an aspect has a value greater than the last element in "values", it will be grouped
            with the last element in "descriptions".
            </summary>
            <param name="values">Array of values. Values must be able to be
            compared to the aspect (using IComparable)</param>
            <param name="descriptions">The description for the matching value. The last element is the default description.
            If there are n values, there must be n+1 descriptions.</param>
            <example>
            this.salaryColumn.MakeGroupies(
                new UInt32[] { 20000, 100000 },
                new string[] { "Lowly worker",  "Middle management", "Rarified elevation"});
            </example>
            <typeparam name="T"></typeparam>
            <param name="images"></param>
            <param name="subtitles"></param>
            <param name="tasks"></param>
        </member>
        <member name="M:Fluent.OLVColumn.MakeEqualGroupies``1(``0[],System.String[],System.Object[],System.String[],System.String[])">
            <summary>
            Create groupies based on exact value matches.
            </summary>
            <remarks>
            Install delegates that will group rows into partitions based on equality of this columns aspects.
            If an aspect is equal to value[n], it will be grouped with description[n].
            If an aspect is not equal to any value, it will be grouped with "[other]".
            </remarks>
            <param name="values">Array of values. Values must be able to be
            equated to the aspect</param>
            <param name="descriptions">The description for the matching value.</param>
            <example>
            this.marriedColumn.MakeEqualGroupies(
                new MaritalStatus[] { MaritalStatus.Single, MaritalStatus.Married, MaritalStatus.Divorced, MaritalStatus.Partnered },
                new string[] { "Looking",  "Content", "Looking again", "Mostly content" });
            </example>
            <typeparam name="T"></typeparam>
            <param name="images"></param>
            <param name="subtitles"></param>
            <param name="tasks"></param>
        </member>
        <member name="T:Fluent.Properties.Resources">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:Fluent.Properties.Resources.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:Fluent.Properties.Resources.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="P:Fluent.Properties.Resources.ClearFiltering">
            <summary>
              Looks up a localized resource of type System.Drawing.Bitmap.
            </summary>
        </member>
        <member name="P:Fluent.Properties.Resources.ColumnFilterIndicator">
            <summary>
              Looks up a localized resource of type System.Drawing.Bitmap.
            </summary>
        </member>
        <member name="P:Fluent.Properties.Resources.Filtering">
            <summary>
              Looks up a localized resource of type System.Drawing.Bitmap.
            </summary>
        </member>
        <member name="P:Fluent.Properties.Resources.SortAscending">
            <summary>
              Looks up a localized resource of type System.Drawing.Bitmap.
            </summary>
        </member>
        <member name="P:Fluent.Properties.Resources.SortDescending">
            <summary>
              Looks up a localized resource of type System.Drawing.Bitmap.
            </summary>
        </member>
        <member name="T:Fluent.GraphicAdornment">
            <summary>
            An adorment is the common base for overlays and decorations.
            </summary>
        </member>
        <member name="P:Fluent.GraphicAdornment.AdornmentCorner">
            <summary>
            Gets or sets the corner of the adornment that will be positioned at the reference corner
            </summary>
        </member>
        <member name="P:Fluent.GraphicAdornment.Alignment">
            <summary>
            Gets or sets location within the reference rectange where the adornment will be drawn
            </summary>
            <remarks>This is a simplied interface to ReferenceCorner and AdornmentCorner </remarks>
        </member>
        <member name="P:Fluent.GraphicAdornment.Offset">
            <summary>
            Gets or sets the offset by which the position of the adornment will be adjusted
            </summary>
        </member>
        <member name="P:Fluent.GraphicAdornment.ReferenceCorner">
            <summary>
            Gets or sets the point of the reference rectangle to which the adornment will be aligned.
            </summary>
        </member>
        <member name="P:Fluent.GraphicAdornment.Rotation">
            <summary>
            Gets or sets the degree of rotation by which the adornment will be transformed.
            The centre of rotation will be the center point of the adornment.
            </summary>
        </member>
        <member name="P:Fluent.GraphicAdornment.Transparency">
            <summary>
            Gets or sets the transparency of the overlay. 
            0 is completely transparent, 255 is completely opaque.
            </summary>
        </member>
        <member name="M:Fluent.GraphicAdornment.CalculateAlignedPosition(System.Drawing.Point,System.Drawing.Size,System.Drawing.ContentAlignment)">
            <summary>
            Calculate the location of rectangle of the given size,
            so that it's indicated corner would be at the given point.
            </summary>
            <param name="pt">The point</param>
            <param name="size"></param>
            <param name="corner">Which corner will be positioned at the reference point</param>
            <returns></returns>
            <example>CalculateAlignedPosition(new Point(50, 100), new Size(10, 20), System.Drawing.ContentAlignment.TopLeft) -> Point(50, 100)</example>
            <example>CalculateAlignedPosition(new Point(50, 100), new Size(10, 20), System.Drawing.ContentAlignment.MiddleCenter) -> Point(45, 90)</example>
            <example>CalculateAlignedPosition(new Point(50, 100), new Size(10, 20), System.Drawing.ContentAlignment.BottomRight) -> Point(40, 80)</example>
        </member>
        <member name="M:Fluent.GraphicAdornment.CreateAlignedRectangle(System.Drawing.Rectangle,System.Drawing.Size)">
            <summary>
            Calculate a rectangle that has the given size which is positioned so that
            its alignment point is at the reference location of the given rect.
            </summary>
            <param name="r"></param>
            <param name="sz"></param>
            <returns></returns>
        </member>
        <member name="M:Fluent.GraphicAdornment.CreateAlignedRectangle(System.Drawing.Rectangle,System.Drawing.Size,System.Drawing.ContentAlignment,System.Drawing.ContentAlignment,System.Drawing.Size)">
            <summary>
            Create a rectangle of the given size which is positioned so that
            its indicated corner is at the indicated corner of the reference rect.
            </summary>
            <param name="r"></param>
            <param name="sz"></param>
            <param name="corner"></param>
            <param name="referenceCorner"></param>
            <param name="offset"></param>
            <returns></returns>
            <remarks>
            <para>Creates a rectangle so that its bottom left is at the centre of the reference:
            corner=BottomLeft, referenceCorner=MiddleCenter</para>
            <para>This is a powerful concept that takes some getting used to, but is
            very neat once you understand it.</para>
            </remarks>
        </member>
        <member name="M:Fluent.GraphicAdornment.CalculateCorner(System.Drawing.Rectangle,System.Drawing.ContentAlignment)">
            <summary>
            Return the point at the indicated corner of the given rectangle (it doesn't
            have to be a corner, but a named location)
            </summary>
            <param name="r">The reference rectangle</param>
            <param name="corner">Which point of the rectangle should be returned?</param>
            <returns>A point</returns>
            <example>CalculateReferenceLocation(new Rectangle(0, 0, 50, 100), System.Drawing.ContentAlignment.TopLeft) -> Point(0, 0)</example>
            <example>CalculateReferenceLocation(new Rectangle(0, 0, 50, 100), System.Drawing.ContentAlignment.MiddleCenter) -> Point(25, 50)</example>
            <example>CalculateReferenceLocation(new Rectangle(0, 0, 50, 100), System.Drawing.ContentAlignment.BottomRight) -> Point(50, 100)</example>
        </member>
        <member name="M:Fluent.GraphicAdornment.CalculateItemBounds(Fluent.OLVListItem,Fluent.OLVListSubItem)">
            <summary>
            Given the item and the subitem, calculate its bounds.
            </summary>
            <param name="item"></param>
            <param name="subItem"></param>
            <returns></returns>
        </member>
        <member name="M:Fluent.GraphicAdornment.ApplyRotation(System.Drawing.Graphics,System.Drawing.Rectangle)">
            <summary>
            Apply any specified rotation to the Graphic content.
            </summary>
            <param name="g">The Graphics to be transformed</param>
            <param name="r">The rotation will be around the centre of this rect</param>
        </member>
        <member name="M:Fluent.GraphicAdornment.UnapplyRotation(System.Drawing.Graphics)">
            <summary>
            Reverse the rotation created by ApplyRotation()
            </summary>
            <param name="g"></param>
        </member>
        <member name="T:Fluent.ImageAdornment">
            <summary>
            An overlay that will draw an image over the top of the FluentListView
            </summary>
        </member>
        <member name="P:Fluent.ImageAdornment.Image">
            <summary>
            Gets or sets the image that will be drawn
            </summary>
        </member>
        <member name="P:Fluent.ImageAdornment.ShrinkToWidth">
            <summary>
            Gets or sets if the image will be shrunk to fit with its horizontal bounds
            </summary>
        </member>
        <member name="M:Fluent.ImageAdornment.DrawImage(System.Drawing.Graphics,System.Drawing.Rectangle)">
            <summary>
            Draw the image in its specified location
            </summary>
            <param name="g">The Graphics used for drawing</param>
            <param name="r">The bounds of the rendering</param>
        </member>
        <member name="M:Fluent.ImageAdornment.DrawImage(System.Drawing.Graphics,System.Drawing.Rectangle,System.Drawing.Image,System.Int32)">
            <summary>
            Draw the image in its specified location
            </summary>
            <param name="image">The image to be drawn</param>
            <param name="g">The Graphics used for drawing</param>
            <param name="r">The bounds of the rendering</param>
            <param name="transparency">How transparent should the image be (0 is completely transparent, 255 is opaque)</param>
        </member>
        <member name="M:Fluent.ImageAdornment.DrawImage(System.Drawing.Graphics,System.Drawing.Rectangle,System.Drawing.Image,System.Drawing.Size,System.Int32)">
            <summary>
            Draw the image in its specified location
            </summary>
            <param name="image">The image to be drawn</param>
            <param name="g">The Graphics used for drawing</param>
            <param name="r">The bounds of the rendering</param>
            <param name="sz">How big should the image be?</param>
            <param name="transparency">How transparent should the image be (0 is completely transparent, 255 is opaque)</param>
        </member>
        <member name="M:Fluent.ImageAdornment.DrawScaledImage(System.Drawing.Graphics,System.Drawing.Rectangle,System.Drawing.Image,System.Int32)">
            <summary>
            Draw the image in its specified location, scaled so that it is not wider
            than the given rectangle. Height is scaled proportional to the width.
            </summary>
            <param name="image">The image to be drawn</param>
            <param name="g">The Graphics used for drawing</param>
            <param name="r">The bounds of the rendering</param>
            <param name="transparency">How transparent should the image be (0 is completely transparent, 255 is opaque)</param>
        </member>
        <member name="M:Fluent.ImageAdornment.DrawTransparentBitmap(System.Drawing.Graphics,System.Drawing.Rectangle,System.Drawing.Image,System.Int32)">
            <summary>
            Utility to draw a bitmap transparenly.
            </summary>
            <param name="g"></param>
            <param name="r"></param>
            <param name="image"></param>
            <param name="transparency"></param>
        </member>
        <member name="T:Fluent.TextAdornment">
            <summary>
            An adornment that will draw text
            </summary>
        </member>
        <member name="P:Fluent.TextAdornment.BackColor">
            <summary>
            Gets or sets the background color of the text
            Set this to Color.Empty to not draw a background
            </summary>
        </member>
        <member name="P:Fluent.TextAdornment.BackgroundBrush">
            <summary>
            Gets the brush that will be used to paint the text
            </summary>
        </member>
        <member name="P:Fluent.TextAdornment.BorderColor">
            <summary>
            Gets or sets the color of the border around the billboard.
            Set this to Color.Empty to remove the border
            </summary>
        </member>
        <member name="P:Fluent.TextAdornment.BorderPen">
            <summary>
            Gets the brush that will be used to paint the text
            </summary>
        </member>
        <member name="P:Fluent.TextAdornment.BorderWidth">
            <summary>
            Gets or sets the width of the border around the text
            </summary>
        </member>
        <member name="P:Fluent.TextAdornment.CornerRounding">
            <summary>
            How rounded should the corners of the border be? 0 means no rounding.
            </summary>
            <remarks>If this value is too large, the edges of the border will appear odd.</remarks>
        </member>
        <member name="P:Fluent.TextAdornment.Font">
            <summary>
            Gets or sets the font that will be used to draw the text
            </summary>
        </member>
        <member name="P:Fluent.TextAdornment.FontOrDefault">
            <summary>
            Gets the font that will be used to draw the text or a reasonable default
            </summary>
        </member>
        <member name="P:Fluent.TextAdornment.HasBackground">
            <summary>
            Does this text have a background?
            </summary>
        </member>
        <member name="P:Fluent.TextAdornment.HasBorder">
            <summary>
            Does this overlay have a border?
            </summary>
        </member>
        <member name="P:Fluent.TextAdornment.MaximumTextWidth">
            <summary>
            Gets or sets the maximum width of the text. Text longer than this will wrap.
            0 means no maximum.
            </summary>
        </member>
        <member name="P:Fluent.TextAdornment.StringFormat">
            <summary>
            Gets or sets the formatting that should be used on the text
            </summary>
        </member>
        <member name="P:Fluent.TextAdornment.Text">
            <summary>
            Gets or sets the text that will be drawn
            </summary>
        </member>
        <member name="P:Fluent.TextAdornment.TextBrush">
            <summary>
            Gets the brush that will be used to paint the text
            </summary>
        </member>
        <member name="P:Fluent.TextAdornment.TextColor">
            <summary>
            Gets or sets the color of the text
            </summary>
        </member>
        <member name="P:Fluent.TextAdornment.Wrap">
            <summary>
            Gets or sets whether the text will wrap when it exceeds its bounds
            </summary>
        </member>
        <member name="M:Fluent.TextAdornment.DrawText(System.Drawing.Graphics,System.Drawing.Rectangle)">
            <summary>
            Draw our text with our stored configuration in relation to the given
            reference rectangle
            </summary>
            <param name="g">The Graphics used for drawing</param>
            <param name="r">The reference rectangle in relation to which the text will be drawn</param>
        </member>
        <member name="M:Fluent.TextAdornment.DrawText(System.Drawing.Graphics,System.Drawing.Rectangle,System.String,System.Int32)">
            <summary>
            Draw the given text with our stored configuration
            </summary>
            <param name="g">The Graphics used for drawing</param>
            <param name="r">The reference rectangle in relation to which the text will be drawn</param>
            <param name="s">The text to draw</param>
            <param name="transparency">How opaque should be text be</param>
        </member>
        <member name="M:Fluent.TextAdornment.DrawBorderedText(System.Drawing.Graphics,System.Drawing.Rectangle,System.String,System.Int32)">
            <summary>
            Draw the text with a border
            </summary>
            <param name="g">The Graphics used for drawing</param>
            <param name="textRect">The bounds within which the text should be drawn</param>
            <param name="text">The text to draw</param>
            <param name="transparency">How opaque should be text be</param>
        </member>
        <member name="M:Fluent.TextAdornment.CalculateTextBounds(System.Drawing.Graphics,System.Drawing.Rectangle,System.String)">
            <summary>
            Return the rectangle that will be the precise bounds of the displayed text
            </summary>
            <param name="g"></param>
            <param name="r"></param>
            <param name="s"></param>
            <returns>The bounds of the text</returns>
        </member>
        <member name="M:Fluent.TextAdornment.GetRoundedRect(System.Drawing.Rectangle,System.Single)">
            <summary>
            Return a GraphicPath that is a round cornered rectangle
            </summary>
            <param name="rect">The rectangle</param>
            <param name="diameter">The diameter of the corners</param>
            <returns>A round cornered rectagle path</returns>
            <remarks>If I could rely on people using C# 3.0+, this should be
            an extension method of GraphicsPath.</remarks>
        </member>
        <member name="T:Fluent.IDecoration">
            <summary>
            A decoration is an overlay that draws itself in relation to a given row or cell.
            Decorations scroll when the listview scrolls.
            </summary>
        </member>
        <member name="P:Fluent.IDecoration.ListItem">
            <summary>
            Gets or sets the row that is to be decorated
            </summary>
        </member>
        <member name="P:Fluent.IDecoration.SubItem">
            <summary>
            Gets or sets the subitem that is to be decorated
            </summary>
        </member>
        <member name="T:Fluent.AbstractDecoration">
            <summary>
            An AbstractDecoration is a safe do-nothing implementation of the IDecoration interface
            </summary>
        </member>
        <member name="P:Fluent.AbstractDecoration.ListItem">
            <summary>
            Gets or sets the row that is to be decorated
            </summary>
        </member>
        <member name="P:Fluent.AbstractDecoration.SubItem">
            <summary>
            Gets or sets the subitem that is to be decorated
            </summary>
        </member>
        <member name="P:Fluent.AbstractDecoration.RowBounds">
            <summary>
            Gets the bounds of the decorations row
            </summary>
        </member>
        <member name="P:Fluent.AbstractDecoration.CellBounds">
            <summary>
            Get the bounds of the decorations cell
            </summary>
        </member>
        <member name="M:Fluent.AbstractDecoration.Draw(Fluent.Lists.AdvancedListView,System.Drawing.Graphics,System.Drawing.Rectangle)">
            <summary>
            Draw the decoration
            </summary>
            <param name="olv"></param>
            <param name="g"></param>
            <param name="r"></param>
        </member>
        <member name="T:Fluent.TintedColumnDecoration">
            <summary>
            This decoration draws a slight tint over a column of the
            owning listview. If no column is explicitly set, the selected
            column in the listview will be used.
            The selected column is normally the sort column, but does not have to be.
            </summary>
        </member>
        <member name="M:Fluent.TintedColumnDecoration.#ctor">
            <summary>
            Create a TintedColumnDecoration
            </summary>
        </member>
        <member name="M:Fluent.TintedColumnDecoration.#ctor(Fluent.OLVColumn)">
            <summary>
            Create a TintedColumnDecoration
            </summary>
            <param name="column"></param>
        </member>
        <member name="P:Fluent.TintedColumnDecoration.ColumnToTint">
            <summary>
            Gets or sets the column that will be tinted
            </summary>
        </member>
        <member name="P:Fluent.TintedColumnDecoration.Tint">
            <summary>
            Gets or sets the color that will be 'tinted' over the selected column
            </summary>
        </member>
        <member name="M:Fluent.TintedColumnDecoration.Draw(Fluent.Lists.AdvancedListView,System.Drawing.Graphics,System.Drawing.Rectangle)">
            <summary>
            Draw a slight colouring over our tinted column
            </summary>
            <remarks>
            This overlay only works when:
            - the list is in Details view
            - there is at least one row
            - there is a selected column (or a specified tint column)
            </remarks>
            <param name="olv"></param>
            <param name="g"></param>
            <param name="r"></param>
        </member>
        <member name="T:Fluent.BorderDecoration">
            <summary>
            This decoration draws an optionally filled border around a rectangle.
            Subclasses must override CalculateBounds().
            </summary>
        </member>
        <member name="M:Fluent.BorderDecoration.#ctor">
            <summary>
            Create a BorderDecoration
            </summary>
        </member>
        <member name="M:Fluent.BorderDecoration.#ctor(System.Drawing.Pen)">
            <summary>
            Create a BorderDecoration
            </summary>
            <param name="borderPen">The pen used to draw the border</param>
        </member>
        <member name="M:Fluent.BorderDecoration.#ctor(System.Drawing.Pen,System.Drawing.Brush)">
            <summary>
            Create a BorderDecoration
            </summary>
            <param name="borderPen">The pen used to draw the border</param>
            <param name="fill">The brush used to fill the rectangle</param>
        </member>
        <member name="P:Fluent.BorderDecoration.BorderPen">
            <summary>
            Gets or sets the pen that will be used to draw the border
            </summary>
        </member>
        <member name="P:Fluent.BorderDecoration.BoundsPadding">
            <summary>
            Gets or sets the padding that will be added to the bounds of the item
            before drawing the border and fill.
            </summary>
        </member>
        <member name="P:Fluent.BorderDecoration.CornerRounding">
            <summary>
            How rounded should the corners of the border be? 0 means no rounding.
            </summary>
            <remarks>If this value is too large, the edges of the border will appear odd.</remarks>
        </member>
        <member name="P:Fluent.BorderDecoration.FillBrush">
            <summary>
            Gets or sets the brush that will be used to fill the border
            </summary>
            <remarks>This value is ignored when using gradient brush</remarks>
        </member>
        <member name="P:Fluent.BorderDecoration.FillGradientFrom">
            <summary>
            Gets or sets the color that will be used as the start of a gradient fill.
            </summary>
            <remarks>This and FillGradientTo must be given value to show a gradient</remarks>
        </member>
        <member name="P:Fluent.BorderDecoration.FillGradientTo">
            <summary>
            Gets or sets the color that will be used as the end of a gradient fill.
            </summary>
            <remarks>This and FillGradientFrom must be given value to show a gradient</remarks>
        </member>
        <member name="P:Fluent.BorderDecoration.FillGradientMode">
            <summary>
            Gets or sets the fill mode that will be used for the gradient.
            </summary>
        </member>
        <member name="M:Fluent.BorderDecoration.Draw(Fluent.Lists.AdvancedListView,System.Drawing.Graphics,System.Drawing.Rectangle)">
            <summary>
            Draw a filled border 
            </summary>
            <param name="olv"></param>
            <param name="g"></param>
            <param name="r"></param>
        </member>
        <member name="M:Fluent.BorderDecoration.CalculateBounds">
            <summary>
            Subclasses should override this to say where the border should be drawn
            </summary>
            <returns></returns>
        </member>
        <member name="M:Fluent.BorderDecoration.DrawFilledBorder(System.Drawing.Graphics,System.Drawing.Rectangle)">
            <summary>
            Do the actual work of drawing the filled border
            </summary>
            <param name="g"></param>
            <param name="bounds"></param>
        </member>
        <member name="M:Fluent.BorderDecoration.GetRoundedRect(System.Drawing.RectangleF,System.Single)">
            <summary>
            Create a GraphicsPath that represents a round cornered rectangle.
            </summary>
            <param name="rect"></param>
            <param name="diameter">If this is 0 or less, the rectangle will not be rounded.</param>
            <returns></returns>
        </member>
        <member name="T:Fluent.RowBorderDecoration">
            <summary>
            Instances of this class draw a border around the decorated row
            </summary>
        </member>
        <member name="P:Fluent.RowBorderDecoration.LeftColumn">
            <summary>
            Gets or sets the index of the left most column to be used for the border
            </summary>
        </member>
        <member name="P:Fluent.RowBorderDecoration.RightColumn">
            <summary>
            Gets or sets the index of the right most column to be used for the border
            </summary>
        </member>
        <member name="M:Fluent.RowBorderDecoration.CalculateBounds">
            <summary>
            Calculate the boundaries of the border
            </summary>
            <returns></returns>
        </member>
        <member name="T:Fluent.CellBorderDecoration">
            <summary>
            Instances of this class draw a border around the decorated subitem.
            </summary>
        </member>
        <member name="M:Fluent.CellBorderDecoration.CalculateBounds">
            <summary>
            Calculate the boundaries of the border
            </summary>
            <returns></returns>
        </member>
        <member name="T:Fluent.EditingCellBorderDecoration">
            <summary>
            This decoration puts a border around the cell being edited and
            optionally "lightboxes" the cell (makes the rest of the control dark).
            </summary>
        </member>
        <member name="M:Fluent.EditingCellBorderDecoration.#ctor">
            <summary>
            Create a EditingCellBorderDecoration
            </summary>
        </member>
        <member name="M:Fluent.EditingCellBorderDecoration.#ctor(System.Boolean)">
            <summary>
            Create a EditingCellBorderDecoration
            </summary>
            <param name="useLightBox">Should the decoration use a lighbox display style?</param>
        </member>
        <member name="P:Fluent.EditingCellBorderDecoration.UseLightbox">
            <summary>
            Gets or set whether the decoration should make the rest of
            the control dark when a cell is being edited
            </summary>
            <remarks>If this is true, FillBrush is used to overpaint
            the control.</remarks>
        </member>
        <member name="M:Fluent.EditingCellBorderDecoration.Draw(Fluent.Lists.AdvancedListView,System.Drawing.Graphics,System.Drawing.Rectangle)">
            <summary>
            Draw the decoration
            </summary>
            <param name="olv"></param>
            <param name="g"></param>
            <param name="r"></param>
        </member>
        <member name="T:Fluent.LightBoxDecoration">
            <summary>
            This decoration causes everything *except* the row under the mouse to be overpainted
            with a tint, making the row under the mouse stand out in comparison.
            The darker and more opaque the fill color, the more obvious the
            decorated row becomes.
            </summary>
        </member>
        <member name="M:Fluent.LightBoxDecoration.#ctor">
            <summary>
            Create a LightBoxDecoration
            </summary>
        </member>
        <member name="M:Fluent.LightBoxDecoration.Draw(Fluent.Lists.AdvancedListView,System.Drawing.Graphics,System.Drawing.Rectangle)">
            <summary>
            Draw a tint over everything in the FluentListView except the 
            row under the mouse.
            </summary>
            <param name="olv"></param>
            <param name="g"></param>
            <param name="r"></param>
        </member>
        <member name="T:Fluent.ImageDecoration">
            <summary>
            Instances of this class put an Image over the row/cell that it is decorating
            </summary>
        </member>
        <member name="M:Fluent.ImageDecoration.#ctor">
            <summary>
            Create an image decoration
            </summary>
        </member>
        <member name="M:Fluent.ImageDecoration.#ctor(System.Drawing.Image)">
            <summary>
            Create an image decoration
            </summary>
            <param name="image"></param>
        </member>
        <member name="M:Fluent.ImageDecoration.#ctor(System.Drawing.Image,System.Int32)">
            <summary>
            Create an image decoration
            </summary>
            <param name="image"></param>
            <param name="transparency"></param>
        </member>
        <member name="M:Fluent.ImageDecoration.#ctor(System.Drawing.Image,System.Drawing.ContentAlignment)">
            <summary>
            Create an image decoration
            </summary>
            <param name="image"></param>
            <param name="alignment"></param>
        </member>
        <member name="M:Fluent.ImageDecoration.#ctor(System.Drawing.Image,System.Int32,System.Drawing.ContentAlignment)">
            <summary>
            Create an image decoration
            </summary>
            <param name="image"></param>
            <param name="transparency"></param>
            <param name="alignment"></param>
        </member>
        <member name="P:Fluent.ImageDecoration.ListItem">
            <summary>
            Gets or sets the item being decorated
            </summary>
        </member>
        <member name="P:Fluent.ImageDecoration.SubItem">
            <summary>
            Gets or sets the sub item being decorated
            </summary>
        </member>
        <member name="M:Fluent.ImageDecoration.Draw(Fluent.Lists.AdvancedListView,System.Drawing.Graphics,System.Drawing.Rectangle)">
            <summary>
            Draw this decoration
            </summary>
            <param name="olv">The FluentListView being decorated</param>
            <param name="g">The Graphics used for drawing</param>
            <param name="r">The bounds of the rendering</param>
        </member>
        <member name="T:Fluent.TextDecoration">
            <summary>
            Instances of this class draw some text over the row/cell that they are decorating
            </summary>
        </member>
        <member name="M:Fluent.TextDecoration.#ctor">
            <summary>
            Create a TextDecoration
            </summary>
        </member>
        <member name="M:Fluent.TextDecoration.#ctor(System.String)">
            <summary>
            Create a TextDecoration
            </summary>
            <param name="text"></param>
        </member>
        <member name="M:Fluent.TextDecoration.#ctor(System.String,System.Int32)">
            <summary>
            Create a TextDecoration
            </summary>
            <param name="text"></param>
            <param name="transparency"></param>
        </member>
        <member name="M:Fluent.TextDecoration.#ctor(System.String,System.Drawing.ContentAlignment)">
            <summary>
            Create a TextDecoration
            </summary>
            <param name="text"></param>
            <param name="alignment"></param>
        </member>
        <member name="M:Fluent.TextDecoration.#ctor(System.String,System.Int32,System.Drawing.ContentAlignment)">
            <summary>
            Create a TextDecoration
            </summary>
            <param name="text"></param>
            <param name="transparency"></param>
            <param name="alignment"></param>
        </member>
        <member name="P:Fluent.TextDecoration.ListItem">
            <summary>
            Gets or sets the item being decorated
            </summary>
        </member>
        <member name="P:Fluent.TextDecoration.SubItem">
            <summary>
            Gets or sets the sub item being decorated
            </summary>
        </member>
        <member name="M:Fluent.TextDecoration.Draw(Fluent.Lists.AdvancedListView,System.Drawing.Graphics,System.Drawing.Rectangle)">
            <summary>
            Draw this decoration
            </summary>
            <param name="olv">The FluentListView being decorated</param>
            <param name="g">The Graphics used for drawing</param>
            <param name="r">The bounds of the rendering</param>
        </member>
        <member name="T:Fluent.IOverlay">
            <summary>
            The interface for an object which can draw itself over the top of
            an FluentListView.
            </summary>
        </member>
        <member name="M:Fluent.IOverlay.Draw(Fluent.Lists.AdvancedListView,System.Drawing.Graphics,System.Drawing.Rectangle)">
            <summary>
            Draw this overlay
            </summary>
            <param name="olv">The FluentListView that is being overlaid</param>
            <param name="g">The Graphics onto the given OLV</param>
            <param name="r">The content area of the OLV</param>
        </member>
        <member name="T:Fluent.ITransparentOverlay">
            <summary>
            An interface for an overlay that supports variable levels of transparency
            </summary>
        </member>
        <member name="P:Fluent.ITransparentOverlay.Transparency">
            <summary>
            Gets or sets the transparency of the overlay. 
            0 is completely transparent, 255 is completely opaque.
            </summary>
        </member>
        <member name="T:Fluent.AbstractOverlay">
            <summary>
            A null implementation of the IOverlay interface
            </summary>
        </member>
        <member name="M:Fluent.AbstractOverlay.Draw(Fluent.Lists.AdvancedListView,System.Drawing.Graphics,System.Drawing.Rectangle)">
            <summary>
            Draw this overlay
            </summary>
            <param name="olv">The FluentListView that is being overlaid</param>
            <param name="g">The Graphics onto the given OLV</param>
            <param name="r">The content area of the OLV</param>
        </member>
        <member name="P:Fluent.AbstractOverlay.Transparency">
            <summary>
            How transparent should this overlay be?
            </summary>
        </member>
        <member name="T:Fluent.ImageOverlay">
            <summary>
            An overlay that will draw an image over the top of the FluentListView
            </summary>
        </member>
        <member name="M:Fluent.ImageOverlay.#ctor">
            <summary>
            Create an ImageOverlay
            </summary>
        </member>
        <member name="P:Fluent.ImageOverlay.InsetX">
            <summary>
            Gets or sets the horizontal inset by which the position of the overlay will be adjusted
            </summary>
        </member>
        <member name="P:Fluent.ImageOverlay.InsetY">
            <summary>
            Gets or sets the vertical inset by which the position of the overlay will be adjusted
            </summary>
        </member>
        <member name="M:Fluent.ImageOverlay.Draw(Fluent.Lists.AdvancedListView,System.Drawing.Graphics,System.Drawing.Rectangle)">
            <summary>
            Draw this overlay
            </summary>
            <param name="olv">The FluentListView being decorated</param>
            <param name="g">The Graphics used for drawing</param>
            <param name="r">The bounds of the rendering</param>
        </member>
        <member name="T:Fluent.TextOverlay">
            <summary>
            An overlay that will draw text over the top of the FluentListView
            </summary>
        </member>
        <member name="M:Fluent.TextOverlay.#ctor">
            <summary>
            Create a TextOverlay
            </summary>
        </member>
        <member name="P:Fluent.TextOverlay.InsetX">
            <summary>
            Gets or sets the horizontal inset by which the position of the overlay will be adjusted
            </summary>
        </member>
        <member name="P:Fluent.TextOverlay.InsetY">
            <summary>
            Gets or sets the vertical inset by which the position of the overlay will be adjusted
            </summary>
        </member>
        <member name="P:Fluent.TextOverlay.RoundCorneredBorder">
            <summary>
            Gets or sets whether the border will be drawn with rounded corners
            </summary>
        </member>
        <member name="M:Fluent.TextOverlay.Draw(Fluent.Lists.AdvancedListView,System.Drawing.Graphics,System.Drawing.Rectangle)">
            <summary>
            Draw this overlay
            </summary>
            <param name="olv">The FluentListView being decorated</param>
            <param name="g">The Graphics used for drawing</param>
            <param name="r">The bounds of the rendering</param>
        </member>
        <member name="T:Fluent.BillboardOverlay">
            <summary>
            A Billboard overlay is a TextOverlay positioned at an absolute point
            </summary>
        </member>
        <member name="M:Fluent.BillboardOverlay.#ctor">
            <summary>
            Create a BillboardOverlay
            </summary>
        </member>
        <member name="P:Fluent.BillboardOverlay.Location">
            <summary>
            Gets or sets where should the top left of the billboard be placed
            </summary>
        </member>
        <member name="M:Fluent.BillboardOverlay.Draw(Fluent.Lists.AdvancedListView,System.Drawing.Graphics,System.Drawing.Rectangle)">
            <summary>
            Draw this overlay
            </summary>
            <param name="olv">The FluentListView being decorated</param>
            <param name="g">The Graphics used for drawing</param>
            <param name="r">The bounds of the rendering</param>
        </member>
        <member name="T:Fluent.IRenderer">
            <summary>
            Renderers are the mechanism used for owner drawing cells. As such, they can also handle
            hit detection and positioning of cell editing rectangles.
            </summary>
        </member>
        <member name="M:Fluent.IRenderer.RenderItem(System.Windows.Forms.DrawListViewItemEventArgs,System.Drawing.Graphics,System.Drawing.Rectangle,System.Object)">
            <summary>
            Render the whole item within an FluentListView. This is only used in non-Details views.
            </summary>
            <param name="e">The event</param>
            <param name="g">A Graphics for rendering</param>
            <param name="itemBounds">The bounds of the item</param>
            <param name="rowObject">The model object to be drawn</param>
            <returns>Return true to indicate that the event was handled and no further processing is needed.</returns>
        </member>
        <member name="M:Fluent.IRenderer.RenderSubItem(System.Windows.Forms.DrawListViewSubItemEventArgs,System.Drawing.Graphics,System.Drawing.Rectangle,System.Object)">
            <summary>
            Render one cell within an FluentListView when it is in Details mode.
            </summary>
            <param name="e">The event</param>
            <param name="g">A Graphics for rendering</param>
            <param name="cellBounds">The bounds of the cell</param>
            <param name="rowObject">The model object to be drawn</param>
            <returns>Return true to indicate that the event was handled and no further processing is needed.</returns>
        </member>
        <member name="M:Fluent.IRenderer.HitTest(Fluent.OlvListViewHitTestInfo,System.Int32,System.Int32)">
            <summary>
            What is under the given point?
            </summary>
            <param name="hti"></param>
            <param name="x">x co-ordinate</param>
            <param name="y">y co-ordinate</param>
            <remarks>This method should only alter HitTestLocation and/or UserData.</remarks>
        </member>
        <member name="M:Fluent.IRenderer.GetEditRectangle(System.Drawing.Graphics,System.Drawing.Rectangle,Fluent.OLVListItem,System.Int32,System.Drawing.Size)">
            <summary>
            When the value in the given cell is to be edited, where should the edit rectangle be placed?
            </summary>
            <param name="g"></param>
            <param name="cellBounds"></param>
            <param name="item"></param>
            <param name="subItemIndex"></param>
            <param name="preferredSize"> </param>
            <returns></returns>
        </member>
        <member name="T:Fluent.IFilterAwareRenderer">
            <summary>
            Renderers that implement this interface will have the filter property updated,
            each time the filter on the FluentListView is updated.
            </summary>
        </member>
        <member name="T:Fluent.AbstractRenderer">
            <summary>
            An AbstractRenderer is a do-nothing implementation of the IRenderer interface.
            </summary>
        </member>
        <member name="M:Fluent.AbstractRenderer.RenderItem(System.Windows.Forms.DrawListViewItemEventArgs,System.Drawing.Graphics,System.Drawing.Rectangle,System.Object)">
            <summary>
            Render the whole item within an FluentListView. This is only used in non-Details views.
            </summary>
            <param name="e">The event</param>
            <param name="g">A Graphics for rendering</param>
            <param name="itemBounds">The bounds of the item</param>
            <param name="rowObject">The model object to be drawn</param>
            <returns>Return true to indicate that the event was handled and no further processing is needed.</returns>
        </member>
        <member name="M:Fluent.AbstractRenderer.RenderSubItem(System.Windows.Forms.DrawListViewSubItemEventArgs,System.Drawing.Graphics,System.Drawing.Rectangle,System.Object)">
            <summary>
            Render one cell within an FluentListView when it is in Details mode.
            </summary>
            <param name="e">The event</param>
            <param name="g">A Graphics for rendering</param>
            <param name="cellBounds">The bounds of the cell</param>
            <param name="rowObject">The model object to be drawn</param>
            <returns>Return true to indicate that the event was handled and no further processing is needed.</returns>
        </member>
        <member name="M:Fluent.AbstractRenderer.HitTest(Fluent.OlvListViewHitTestInfo,System.Int32,System.Int32)">
            <summary>
            What is under the given point?
            </summary>
            <param name="hti"></param>
            <param name="x">x co-ordinate</param>
            <param name="y">y co-ordinate</param>
            <remarks>This method should only alter HitTestLocation and/or UserData.</remarks>
        </member>
        <member name="M:Fluent.AbstractRenderer.GetEditRectangle(System.Drawing.Graphics,System.Drawing.Rectangle,Fluent.OLVListItem,System.Int32,System.Drawing.Size)">
            <summary>
            When the value in the given cell is to be edited, where should the edit rectangle be placed?
            </summary>
            <param name="g"></param>
            <param name="cellBounds"></param>
            <param name="item"></param>
            <param name="subItemIndex"></param>
            <param name="preferredSize"> </param>
            <returns></returns>
        </member>
        <member name="T:Fluent.Version1Renderer">
            <summary>
            This class provides compatibility for v1 RendererDelegates
            </summary>
        </member>
        <member name="F:Fluent.Version1Renderer.RenderDelegate">
            <summary>
            The renderer delegate that this renderer wraps
            </summary>
        </member>
        <member name="T:Fluent.BaseRenderer">
            <summary>
            A BaseRenderer provides useful base level functionality for any custom renderer.
            </summary>
            <remarks>
            <para>Subclasses will normally override the Render or OptionalRender method, and use the other
            methods as helper functions.</para>
            </remarks>
        </member>
        <member name="P:Fluent.BaseRenderer.CanWrap">
            <summary>
            Can the renderer wrap lines that do not fit completely within the cell?
            </summary>
            <remarks>Wrapping text doesn't work with the GDI renderer.</remarks>
        </member>
        <member name="P:Fluent.BaseRenderer.CellPadding">
            <summary>
            Gets or sets how many pixels will be left blank around this cell
            </summary>
            <remarks>
            <para>
            This setting only takes effect when the control is owner drawn.
            </para>
            <para><see cref="P:Fluent.Lists.AdvancedListView.CellPadding"/> for more details.</para>
            </remarks>
        </member>
        <member name="P:Fluent.BaseRenderer.CellHorizontalAlignment">
            <summary>
            Gets the horiztonal alignment of the column
            </summary>
        </member>
        <member name="P:Fluent.BaseRenderer.CellVerticalAlignment">
            <summary>
            Gets or sets how cells drawn by this renderer will be vertically aligned.
            </summary>
            <remarks>
            <para>
            If this is not set, the value from the column or control itself will be used.
            </para>
            </remarks>
        </member>
        <member name="P:Fluent.BaseRenderer.EffectiveCellPadding">
            <summary>
            Gets the optional padding that this renderer should apply before drawing.
            This property considers all possible sources of padding
            </summary>
        </member>
        <member name="P:Fluent.BaseRenderer.EffectiveCellVerticalAlignment">
            <summary>
            Gets the vertical cell alignment that should govern the rendering.
            This property considers all possible sources.
            </summary>
        </member>
        <member name="P:Fluent.BaseRenderer.ImageList">
            <summary>
            Gets or sets the image list from which keyed images will be fetched
            </summary>
        </member>
        <member name="P:Fluent.BaseRenderer.Spacing">
            <summary>
            When rendering multiple images, how many pixels should be between each image?
            </summary>
        </member>
        <member name="P:Fluent.BaseRenderer.UseGdiTextRendering">
            <summary>
            Should text be rendered using GDI routines? This makes the text look more
            like a native List view control.
            </summary>
        </member>
        <member name="P:Fluent.BaseRenderer.Aspect">
            <summary>
            Get or set the aspect of the model object that this renderer should draw
            </summary>
        </member>
        <member name="P:Fluent.BaseRenderer.Bounds">
            <summary>
            What are the bounds of the cell that is being drawn?
            </summary>
        </member>
        <member name="P:Fluent.BaseRenderer.Column">
            <summary>
            Get or set the OLVColumn that this renderer will draw
            </summary>
        </member>
        <member name="P:Fluent.BaseRenderer.DrawItemEvent">
            <summary>
            Get/set the event that caused this renderer to be called
            </summary>
        </member>
        <member name="P:Fluent.BaseRenderer.Event">
            <summary>
            Get/set the event that caused this renderer to be called
            </summary>
        </member>
        <member name="P:Fluent.BaseRenderer.Font">
            <summary>
            Gets or  sets the font to be used for text in this cell
            </summary>
        </member>
        <member name="P:Fluent.BaseRenderer.ImageListOrDefault">
            <summary>
            Gets the image list from which keyed images will be fetched
            </summary>
        </member>
        <member name="P:Fluent.BaseRenderer.IsDrawBackground">
            <summary>
            Should this renderer fill in the background before drawing?
            </summary>
        </member>
        <member name="P:Fluent.BaseRenderer.IsItemSelected">
            <summary>
            Cache whether or not our item is selected
            </summary>
        </member>
        <member name="P:Fluent.BaseRenderer.IsPrinting">
            <summary>
            Is this renderer being used on a printer context?
            </summary>
        </member>
        <member name="P:Fluent.BaseRenderer.ListItem">
            <summary>
            Get or set the listitem that this renderer will be drawing
            </summary>
        </member>
        <member name="P:Fluent.BaseRenderer.ListView">
            <summary>
            Get/set the listview for which the drawing is to be done
            </summary>
        </member>
        <member name="P:Fluent.BaseRenderer.OLVSubItem">
            <summary>
            Get the specialized OLVSubItem that this renderer is drawing
            </summary>
            <remarks>This returns null for column 0.</remarks>
        </member>
        <member name="P:Fluent.BaseRenderer.RowObject">
            <summary>
            Get or set the model object that this renderer should draw
            </summary>
        </member>
        <member name="P:Fluent.BaseRenderer.SubItem">
            <summary>
            Get or set the list subitem that this renderer will be drawing
            </summary>
        </member>
        <member name="P:Fluent.BaseRenderer.TextBrush">
            <summary>
            The brush that will be used to paint the text
            </summary>
        </member>
        <member name="P:Fluent.BaseRenderer.UseCustomCheckboxImages">
            <summary>
            Will this renderer use the custom images from the parent FluentListView
            to draw the checkbox images.
            </summary>
            <remarks>
            <para>
            If this is true, the renderer will use the images from the 
            StateImageList to represent checkboxes. 0 - unchecked, 1 - checked, 2 - indeterminate.
            </para>
            <para>If this is false (the default), then the renderer will use .NET's standard
            CheckBoxRenderer.</para>
            </remarks>
        </member>
        <member name="M:Fluent.BaseRenderer.AlignRectangle(System.Drawing.Rectangle,System.Drawing.Rectangle)">
            <summary>
            Align the second rectangle with the first rectangle,
            according to the alignment of the column
            </summary>
            <param name="outer">The cell's bounds</param>
            <param name="inner">The rectangle to be aligned within the bounds</param>
            <returns>An aligned rectangle</returns>
        </member>
        <member name="M:Fluent.BaseRenderer.AlignHorizontally(System.Drawing.Rectangle,System.Drawing.Rectangle)">
            <summary>
            Calculate the left edge of the rectangle that aligns the outer rectangle with the inner one 
            according to this renderer's horizontal alignment
            </summary>
            <param name="outer"></param>
            <param name="inner"></param>
            <returns></returns>
        </member>
        <member name="M:Fluent.BaseRenderer.AlignVertically(System.Drawing.Rectangle,System.Drawing.Rectangle)">
            <summary>
            Calculate the top of the rectangle that aligns the outer rectangle with the inner rectangle
            according to this renders vertical alignment
            </summary>
            <param name="outer"></param>
            <param name="inner"></param>
            <returns></returns>
        </member>
        <member name="M:Fluent.BaseRenderer.AlignVertically(System.Drawing.Rectangle,System.Int32)">
            <summary>
            Calculate the top of the rectangle that aligns the outer rectangle with a rectangle of the given height
            according to this renderer's vertical alignment
            </summary>
            <param name="outer"></param>
            <param name="innerHeight"></param>
            <returns></returns>
        </member>
        <member name="M:Fluent.BaseRenderer.CalculateAlignedRectangle(System.Drawing.Graphics,System.Drawing.Rectangle)">
            <summary>
            Calculate the space that our rendering will occupy and then align that space
            with the given rectangle, according to the Column alignment
            </summary>
            <param name="g"></param>
            <param name="r">Pre-padded bounds of the cell</param>
            <returns></returns>
        </member>
        <member name="M:Fluent.BaseRenderer.CalculateContentSize(System.Drawing.Graphics,System.Drawing.Rectangle)">
            <summary>
            Calculate the size of the content of this cell.
            </summary>
            <param name="g"></param>
            <param name="r">Pre-padded bounds of the cell</param>
            <returns>The width and height of the content</returns>
        </member>
        <member name="M:Fluent.BaseRenderer.CalculateCheckBoxBounds(System.Drawing.Graphics,System.Drawing.Rectangle)">
            <summary>
            Calculate the bounds of a checkbox given the (pre-padded) cell bounds
            </summary>
            <param name="g"></param>
            <param name="cellBounds">Pre-padded cell bounds</param>
            <returns></returns>
        </member>
        <member name="M:Fluent.BaseRenderer.CalculateCheckBoxSize(System.Drawing.Graphics)">
            <summary>
            How much space will the check box for this cell occupy?
            </summary>
            <remarks>Only column 0 can have check boxes. Sub item checkboxes are
            treated as images</remarks>
            <param name="g"></param>
            <returns></returns>
        </member>
        <member name="M:Fluent.BaseRenderer.CalculatePrimaryCheckBoxSize(System.Drawing.Graphics)">
            <summary>
            How much space will the check box for this row occupy? 
            If the list doesn't have checkboxes, or this isn't the primary column,
            this returns an empty size.
            </summary>
            <param name="g"></param>
            <returns></returns>
        </member>
        <member name="M:Fluent.BaseRenderer.CalculateImageWidth(System.Drawing.Graphics,System.Object)">
            <summary>
            How much horizontal space will the image of this cell occupy?
            </summary>
            <param name="g"></param>
            <param name="imageSelector"></param>
            <returns></returns>
        </member>
        <member name="M:Fluent.BaseRenderer.CalculateImageHeight(System.Drawing.Graphics,System.Object)">
            <summary>
            How much vertical space will the image of this cell occupy?
            </summary>
            <param name="g"></param>
            <param name="imageSelector"></param>
            <returns></returns>
        </member>
        <member name="M:Fluent.BaseRenderer.CalculateImageSize(System.Drawing.Graphics,System.Object)">
            <summary>
            How much space will the image of this cell occupy?
            </summary>
            <param name="g"></param>
            <param name="imageSelector"></param>
            <returns></returns>
        </member>
        <member name="M:Fluent.BaseRenderer.CalculateTextWidth(System.Drawing.Graphics,System.String,System.Int32)">
            <summary>
            How much horizontal space will the text of this cell occupy?
            </summary>
            <param name="g"></param>
            <param name="txt"></param>
            <param name="width"></param>
            <returns></returns>
        </member>
        <member name="M:Fluent.BaseRenderer.CalculateTextSize(System.Drawing.Graphics,System.String,System.Int32)">
            <summary>
            How much space will the text of this cell occupy?
            </summary>
            <param name="g"></param>
            <param name="txt"></param>
            <param name="width"></param>
            <returns></returns>
        </member>
        <member name="M:Fluent.BaseRenderer.GetBackgroundColor">
            <summary>
            Return the Color that is the background color for this item's cell
            </summary>
            <returns>The background color of the subitem</returns>
        </member>
        <member name="M:Fluent.BaseRenderer.GetSelectedBackgroundColor">
            <summary>
            Return the color of the background color when the item is selected
            </summary>
            <returns>The background color of the subitem</returns>
        </member>
        <member name="M:Fluent.BaseRenderer.GetForegroundColor">
            <summary>
            Return the color to be used for text in this cell
            </summary>
            <returns>The text color of the subitem</returns>
        </member>
        <member name="M:Fluent.BaseRenderer.GetSelectedForegroundColor">
            <summary>
            Return the color of the foreground color when the item is selected
            </summary>
            <returns>The foreground color of the subitem</returns>
        </member>
        <member name="M:Fluent.BaseRenderer.GetImage">
            <summary>
            Return the image that should be drawn against this subitem
            </summary>
            <returns>An Image or null if no image should be drawn.</returns>
        </member>
        <member name="M:Fluent.BaseRenderer.GetImage(System.Object)">
            <summary>
            Return the actual image that should be drawn when keyed by the given image selector.
            An image selector can be: <list type="bullet">
            <item><description>an int, giving the index into the image list</description></item>
            <item><description>a string, giving the image key into the image list</description></item>
            <item><description>an Image, being the image itself</description></item>
            </list>
            </summary>
            <param name="imageSelector">The value that indicates the image to be used</param>
            <returns>An Image or null</returns>
        </member>
        <member name="M:Fluent.BaseRenderer.GetImageSelector">
            <summary>
            </summary>
        </member>
        <member name="M:Fluent.BaseRenderer.GetText">
            <summary>
            Return the string that should be drawn within this
            </summary>
            <returns></returns>
        </member>
        <member name="M:Fluent.BaseRenderer.GetTextBackgroundColor">
            <summary>
            Return the Color that is the background color for this item's text
            </summary>
            <returns>The background color of the subitem's text</returns>
        </member>
        <member name="M:Fluent.BaseRenderer.RenderItem(System.Windows.Forms.DrawListViewItemEventArgs,System.Drawing.Graphics,System.Drawing.Rectangle,System.Object)">
            <summary>
            Render the whole item in a non-details view.
            </summary>
            <param name="e"></param>
            <param name="g"></param>
            <param name="itemBounds"></param>
            <param name="model"></param>
            <returns></returns>
        </member>
        <member name="M:Fluent.BaseRenderer.ConfigureItem(System.Windows.Forms.DrawListViewItemEventArgs,System.Drawing.Rectangle,System.Object)">
            <summary>
            Prepare this renderer to draw in response to the given event
            </summary>
            <param name="e"></param>
            <param name="itemBounds"></param>
            <param name="model"></param>
            <remarks>Use this if you want to chain a second renderer within a primary renderer.</remarks>
        </member>
        <member name="M:Fluent.BaseRenderer.RenderSubItem(System.Windows.Forms.DrawListViewSubItemEventArgs,System.Drawing.Graphics,System.Drawing.Rectangle,System.Object)">
            <summary>
            Render one cell
            </summary>
            <param name="e"></param>
            <param name="g"></param>
            <param name="cellBounds"></param>
            <param name="model"></param>
            <returns></returns>
        </member>
        <member name="M:Fluent.BaseRenderer.ConfigureSubItem(System.Windows.Forms.DrawListViewSubItemEventArgs,System.Drawing.Rectangle,System.Object)">
            <summary>
            Prepare this renderer to draw in response to the given event
            </summary>
            <param name="e"></param>
            <param name="cellBounds"></param>
            <param name="model"></param>
            <remarks>Use this if you want to chain a second renderer within a primary renderer.</remarks>
        </member>
        <member name="M:Fluent.BaseRenderer.HitTest(Fluent.OlvListViewHitTestInfo,System.Int32,System.Int32)">
            <summary>
            Calculate which part of this cell was hit
            </summary>
            <param name="hti"></param>
            <param name="x"></param>
            <param name="y"></param>
        </member>
        <member name="M:Fluent.BaseRenderer.GetEditRectangle(System.Drawing.Graphics,System.Drawing.Rectangle,Fluent.OLVListItem,System.Int32,System.Drawing.Size)">
            <summary>
            Calculate the edit rectangle
            </summary>
            <param name="g"></param>
            <param name="cellBounds"></param>
            <param name="item"></param>
            <param name="subItemIndex"></param>
            <param name="preferredSize"> </param>
            <returns></returns>
        </member>
        <member name="M:Fluent.BaseRenderer.OptionalRender(System.Drawing.Graphics,System.Drawing.Rectangle)">
            <summary>
            Draw our data into the given rectangle using the given graphics context.
            </summary>
            <remarks>
            <para>Subclasses should override this method.</para></remarks>
            <param name="g">The graphics context that should be used for drawing</param>
            <param name="r">The bounds of the subitem cell</param>
            <returns>Returns whether the rendering has already taken place.
            If this returns false, the default processing will take over.
            </returns>
        </member>
        <member name="M:Fluent.BaseRenderer.Render(System.Drawing.Graphics,System.Drawing.Rectangle)">
            <summary>
            Draw our data into the given rectangle using the given graphics context.
            </summary>
            <remarks>
            <para>Subclasses should override this method if they never want
            to fall back on the default processing</para></remarks>
            <param name="g">The graphics context that should be used for drawing</param>
            <param name="r">The bounds of the subitem cell</param>
        </member>
        <member name="M:Fluent.BaseRenderer.HandleHitTest(System.Drawing.Graphics,Fluent.OlvListViewHitTestInfo,System.Int32,System.Int32)">
            <summary>
            Do the actual work of hit testing. Subclasses should override this rather than HitTest()
            </summary>
            <param name="g"></param>
            <param name="hti"></param>
            <param name="x"></param>
            <param name="y"></param>
        </member>
        <member name="M:Fluent.BaseRenderer.HandleGetEditRectangle(System.Drawing.Graphics,System.Drawing.Rectangle,Fluent.OLVListItem,System.Int32,System.Drawing.Size)">
            <summary>
            Handle a HitTest request after all state information has been initialized
            </summary>
            <param name="g"></param>
            <param name="cellBounds"></param>
            <param name="item"></param>
            <param name="subItemIndex"></param>
            <param name="preferredSize"> </param>
            <returns></returns>
        </member>
        <member name="M:Fluent.BaseRenderer.StandardRender(System.Drawing.Graphics,System.Drawing.Rectangle)">
            <summary>
            Draw the standard "[checkbox] [image] [text]" cell after the state properties have been initialized.
            </summary>
            <param name="g"></param>
            <param name="r"></param>
        </member>
        <member name="M:Fluent.BaseRenderer.ApplyCellPadding(System.Drawing.Rectangle)">
            <summary>
            Change the bounds of the given rectangle to take any cell padding into account
            </summary>
            <param name="r"></param>
            <returns></returns>
        </member>
        <member name="M:Fluent.BaseRenderer.StandardHitTest(System.Drawing.Graphics,Fluent.OlvListViewHitTestInfo,System.Drawing.Rectangle,System.Int32,System.Int32)">
            <summary>
            Perform normal hit testing relative to the given aligned content bounds
            </summary>
            <param name="g"></param>
            <param name="hti"></param>
            <param name="bounds"></param>
            <param name="x"></param>
            <param name="y"></param>
        </member>
        <member name="M:Fluent.BaseRenderer.StandardGetEditRectangle(System.Drawing.Graphics,System.Drawing.Rectangle,System.Drawing.Size)">
            <summary>
            This method calculates the bounds of the text within a standard layout
            (i.e. optional checkbox, optional image, text)
            </summary>
            <remarks>This method only works correctly if the state of the renderer
            has been fully initialized (see BaseRenderer.GetEditRectangle)</remarks>
            <param name="g"></param>
            <param name="cellBounds"></param>
            <param name="preferredSize"> </param>
            <returns></returns>
        </member>
        <member name="M:Fluent.BaseRenderer.CalculatePaddedAlignedBounds(System.Drawing.Graphics,System.Drawing.Rectangle,System.Drawing.Size)">
            <summary>
            Apply any padding to the given bounds, and then align a rectangle of the given
            size within that padded area.
            </summary>
            <param name="g"></param>
            <param name="cellBounds"></param>
            <param name="preferredSize"></param>
            <returns></returns>
        </member>
        <member name="M:Fluent.BaseRenderer.DrawAlignedImage(System.Drawing.Graphics,System.Drawing.Rectangle,System.Drawing.Image)">
            <summary>
            Draw the given image aligned horizontally within the column.
            </summary>
            <remarks>
            Over tall images are scaled to fit. Over-wide images are
            truncated. This is by design!
            </remarks>
            <param name="g">Graphics context to use for drawing</param>
            <param name="r">Bounds of the cell</param>
            <param name="image">The image to be drawn</param>
        </member>
        <member name="M:Fluent.BaseRenderer.DrawAlignedImageAndText(System.Drawing.Graphics,System.Drawing.Rectangle)">
            <summary>
            Draw our subitems image and text
            </summary>
            <param name="g">Graphics context to use for drawing</param>
            <param name="r">Pre-padded bounds of the cell</param>
        </member>
        <member name="M:Fluent.BaseRenderer.DrawBackground(System.Drawing.Graphics,System.Drawing.Rectangle)">
            <summary>
            Fill in the background of this cell
            </summary>
            <param name="g">Graphics context to use for drawing</param>
            <param name="r">Bounds of the cell</param>
        </member>
        <member name="M:Fluent.BaseRenderer.DrawCheckBox(System.Drawing.Graphics,System.Drawing.Rectangle)">
            <summary>
            Draw the primary check box of this row (checkboxes in other sub items use a different method)
            </summary>
            <param name="g">Graphics context to use for drawing</param>
            <param name="r">The pre-aligned and padded target rectangle</param>
        </member>
        <member name="M:Fluent.BaseRenderer.GetCheckBoxState(System.Windows.Forms.CheckState)">
            <summary>
            Calculate the CheckBoxState we need to correctly draw the given state
            </summary>
            <param name="checkState"></param>
            <returns></returns>
        </member>
        <member name="P:Fluent.BaseRenderer.IsCheckBoxDisabled">
            <summary>
            Should this checkbox be drawn as disabled?
            </summary>
        </member>
        <member name="P:Fluent.BaseRenderer.IsCellHot">
            <summary>
            Is the current item hot (i.e. under the mouse)?
            </summary>
        </member>
        <member name="P:Fluent.BaseRenderer.IsCheckboxHot">
            <summary>
            Is the mouse over a checkbox in this cell?
            </summary>
        </member>
        <member name="M:Fluent.BaseRenderer.DrawImage(System.Drawing.Graphics,System.Drawing.Rectangle,System.Object)">
            <summary>
            Draw the given text and optional image in the "normal" fashion
            </summary>
            <param name="g">Graphics context to use for drawing</param>
            <param name="r">Bounds of the cell</param>
            <param name="imageSelector">The optional image to be drawn</param>
        </member>
        <member name="M:Fluent.BaseRenderer.DrawImageAndText(System.Drawing.Graphics,System.Drawing.Rectangle)">
            <summary>
            Draw our subitems image and text
            </summary>
            <param name="g">Graphics context to use for drawing</param>
            <param name="r">Bounds of the cell</param>
        </member>
        <member name="M:Fluent.BaseRenderer.DrawImages(System.Drawing.Graphics,System.Drawing.Rectangle,System.Collections.ICollection)">
            <summary>
            Draw the given collection of image selectors
            </summary>
            <param name="g"></param>
            <param name="r"></param>
            <param name="imageSelectors"></param>
        </member>
        <member name="M:Fluent.BaseRenderer.DrawText(System.Drawing.Graphics,System.Drawing.Rectangle,System.String)">
            <summary>
            Draw the given text and optional image in the "normal" fashion
            </summary>
            <param name="g">Graphics context to use for drawing</param>
            <param name="r">Bounds of the cell</param>
            <param name="txt">The string to be drawn</param>
        </member>
        <member name="M:Fluent.BaseRenderer.DrawTextGdi(System.Drawing.Graphics,System.Drawing.Rectangle,System.String)">
            <summary>
            Print the given text in the given rectangle using only GDI routines
            </summary>
            <param name="g"></param>
            <param name="r"></param>
            <param name="txt"></param>
            <remarks>
            The native list control uses GDI routines to do its drawing, so using them
            here makes the owner drawn mode looks more natural.
            <para>This method doesn't honour the CanWrap setting on the renderer. All
            text is single line</para>
            </remarks>
        </member>
        <member name="P:Fluent.BaseRenderer.CellVerticalAlignmentAsTextFormatFlag">
            <summary>
            Gets the cell's vertical alignment as a TextFormatFlag
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="P:Fluent.BaseRenderer.StringFormatForGdiPlus">
            <summary>
            Gets the StringFormat needed when drawing text using GDI+
            </summary>
        </member>
        <member name="M:Fluent.BaseRenderer.DrawTextGdiPlus(System.Drawing.Graphics,System.Drawing.Rectangle,System.String)">
            <summary>
            Print the given text in the given rectangle using normal GDI+ .NET methods
            </summary>
            <remarks>Printing to a printer dc has to be done using this method.</remarks>
        </member>
        <member name="T:Fluent.HighlightTextRenderer">
            <summary>
            This renderer highlights substrings that match a given text filter. 
            </summary>
        </member>
        <member name="M:Fluent.HighlightTextRenderer.#ctor">
            <summary>
            Create a HighlightTextRenderer
            </summary>
        </member>
        <member name="M:Fluent.HighlightTextRenderer.#ctor(Fluent.TextMatchFilter)">
            <summary>
            Create a HighlightTextRenderer
            </summary>
            <param name="filter"></param>
        </member>
        <member name="M:Fluent.HighlightTextRenderer.#ctor(System.String)">
            <summary>
            Create a HighlightTextRenderer
            </summary>
            <param name="text"></param>
        </member>
        <member name="P:Fluent.HighlightTextRenderer.CornerRoundness">
            <summary>
            Gets or set how rounded will be the corners of the text match frame
            </summary>
        </member>
        <member name="P:Fluent.HighlightTextRenderer.FillBrush">
            <summary>
            Gets or set the brush will be used to paint behind the matched substrings.
            Set this to null to not fill the frame.
            </summary>
        </member>
        <member name="P:Fluent.HighlightTextRenderer.Filter">
            <summary>
            Gets or sets the filter that is filtering the FluentListView and for
            which this renderer should highlight text
            </summary>
        </member>
        <member name="P:Fluent.HighlightTextRenderer.Fluent#IFilterAwareRenderer#Filter">
            <summary>
            When a filter changes, keep track of the text matching filters
            </summary>
        </member>
        <member name="P:Fluent.HighlightTextRenderer.FramePen">
            <summary>
            Gets or set the pen will be used to frame the matched substrings.
            Set this to null to not draw a frame.
            </summary>
        </member>
        <member name="P:Fluent.HighlightTextRenderer.UseRoundedRectangle">
            <summary>
            Gets or sets whether the frame around a text match will have rounded corners
            </summary>
        </member>
        <member name="P:Fluent.HighlightTextRenderer.TextToHighlight">
            <summary>
            Gets or set the text that will be highlighted
            </summary>
        </member>
        <member name="P:Fluent.HighlightTextRenderer.StringComparison">
            <summary>
            Gets or sets the manner in which substring will be compared.
            </summary>
            <remarks>
            Use this to control if substring matches are case sensitive or insensitive.</remarks>
        </member>
        <member name="M:Fluent.HighlightTextRenderer.HandleGetEditRectangle(System.Drawing.Graphics,System.Drawing.Rectangle,Fluent.OLVListItem,System.Int32,System.Drawing.Size)">
            <summary>
            Handle a HitTest request after all state information has been initialized
            </summary>
            <param name="g"></param>
            <param name="cellBounds"></param>
            <param name="item"></param>
            <param name="subItemIndex"></param>
            <param name="preferredSize"> </param>
            <returns></returns>
        </member>
        <member name="M:Fluent.HighlightTextRenderer.DrawTextGdi(System.Drawing.Graphics,System.Drawing.Rectangle,System.String)">
            <summary>
            Draw text using GDI
            </summary>
            <param name="g"></param>
            <param name="r"></param>
            <param name="txt"></param>
        </member>
        <member name="M:Fluent.HighlightTextRenderer.DrawGdiTextHighlighting(System.Drawing.Graphics,System.Drawing.Rectangle,System.String)">
            <summary>
            Draw the highlighted text using GDI
            </summary>
            <param name="g"></param>
            <param name="r"></param>
            <param name="txt"></param>
        </member>
        <member name="M:Fluent.HighlightTextRenderer.DrawSubstringFrame(System.Drawing.Graphics,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Draw an indication around the given frame that shows a text match
            </summary>
            <param name="g"></param>
            <param name="x"></param>
            <param name="y"></param>
            <param name="width"></param>
            <param name="height"></param>
        </member>
        <member name="M:Fluent.HighlightTextRenderer.DrawTextGdiPlus(System.Drawing.Graphics,System.Drawing.Rectangle,System.String)">
            <summary>
            Draw the text using GDI+
            </summary>
            <param name="g"></param>
            <param name="r"></param>
            <param name="txt"></param>
        </member>
        <member name="M:Fluent.HighlightTextRenderer.DrawGdiPlusTextHighlighting(System.Drawing.Graphics,System.Drawing.Rectangle,System.String)">
            <summary>
            Draw the highlighted text using GDI+
            </summary>
            <param name="g"></param>
            <param name="r"></param>
            <param name="txt"></param>
        </member>
        <member name="P:Fluent.HighlightTextRenderer.ShouldDrawHighlighting">
            <summary>
            Gets whether the renderer should actually draw highlighting
            </summary>
        </member>
        <member name="M:Fluent.HighlightTextRenderer.GetRoundedRect(System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Return a GraphicPath that is a round cornered rectangle
            </summary>
            <returns>A round cornered rectangle path</returns>
            <remarks>If I could rely on people using C# 3.0+, this should be
            an extension method of GraphicsPath.</remarks>        
            <param name="x"></param>
            <param name="y"></param>
            <param name="width"></param>
            <param name="height"></param>
            <param name="diameter"></param>
        </member>
        <member name="M:Fluent.HighlightTextRenderer.GetRoundedRect(System.Drawing.RectangleF,System.Single)">
            <summary>
            Return a GraphicPath that is a round cornered rectangle
            </summary>
            <param name="rect">The rectangle</param>
            <param name="diameter">The diameter of the corners</param>
            <returns>A round cornered rectangle path</returns>
            <remarks>If I could rely on people using C# 3.0+, this should be
            an extension method of GraphicsPath.</remarks>
        </member>
        <member name="T:Fluent.MappedImageRenderer">
            <summary>
            This class maps a data value to an image that should be drawn for that value.
            </summary>
            <remarks><para>It is useful for drawing data that is represented as an enum or boolean.</para></remarks>
        </member>
        <member name="M:Fluent.MappedImageRenderer.Boolean(System.Object,System.Object)">
            <summary>
            Return a renderer that draw boolean values using the given images
            </summary>
            <param name="trueImage">Draw this when our data value is true</param>
            <param name="falseImage">Draw this when our data value is false</param>
            <returns>A Renderer</returns>
        </member>
        <member name="M:Fluent.MappedImageRenderer.TriState(System.Object,System.Object,System.Object)">
            <summary>
            Return a renderer that draw tristate boolean values using the given images
            </summary>
            <param name="trueImage">Draw this when our data value is true</param>
            <param name="falseImage">Draw this when our data value is false</param>
            <param name="nullImage">Draw this when our data value is null</param>
            <returns>A Renderer</returns>
        </member>
        <member name="M:Fluent.MappedImageRenderer.#ctor">
            <summary>
            Make a new empty renderer
            </summary>
        </member>
        <member name="M:Fluent.MappedImageRenderer.#ctor(System.Object,System.Object)">
            <summary>
            Make a new renderer that will show the given image when the given key is the aspect value
            </summary>
            <param name="key">The data value to be matched</param>
            <param name="image">The image to be shown when the key is matched</param>
        </member>
        <member name="M:Fluent.MappedImageRenderer.#ctor(System.Object,System.Object,System.Object,System.Object)">
            <summary>
            Make a new renderer that will show the given images when it receives the given keys
            </summary>
            <param name="key1"></param>
            <param name="image1"></param>
            <param name="key2"></param>
            <param name="image2"></param>
        </member>
        <member name="M:Fluent.MappedImageRenderer.#ctor(System.Object[])">
            <summary>
            Build a renderer from the given array of keys and their matching images
            </summary>
            <param name="keysAndImages">An array of key/image pairs</param>
        </member>
        <member name="M:Fluent.MappedImageRenderer.Add(System.Object,System.Object)">
            <summary>
            Register the image that should be drawn when our Aspect has the data value.
            </summary>
            <param name="value">Value that the Aspect must match</param>
            <param name="image">An ImageSelector -- an int, string or image</param>
        </member>
        <member name="M:Fluent.MappedImageRenderer.Render(System.Drawing.Graphics,System.Drawing.Rectangle)">
            <summary>
            Render our value
            </summary>
            <param name="g"></param>
            <param name="r"></param>
        </member>
        <member name="M:Fluent.MappedImageRenderer.RenderCollection(System.Drawing.Graphics,System.Drawing.Rectangle,System.Collections.ICollection)">
            <summary>
            Draw a collection of images
            </summary>
            <param name="g"></param>
            <param name="r"></param>
            <param name="imageSelectors"></param>
        </member>
        <member name="M:Fluent.MappedImageRenderer.RenderOne(System.Drawing.Graphics,System.Drawing.Rectangle,System.Object)">
            <summary>
            Draw one image
            </summary>
            <param name="g"></param>
            <param name="r"></param>
            <param name="selector"></param>
        </member>
        <member name="T:Fluent.CheckStateRenderer">
            <summary>
            This renderer draws just a checkbox to match the check state of our model object.
            </summary>
        </member>
        <member name="M:Fluent.CheckStateRenderer.Render(System.Drawing.Graphics,System.Drawing.Rectangle)">
            <summary>
            Draw our cell
            </summary>
            <param name="g"></param>
            <param name="r"></param>
        </member>
        <member name="M:Fluent.CheckStateRenderer.HandleGetEditRectangle(System.Drawing.Graphics,System.Drawing.Rectangle,Fluent.OLVListItem,System.Int32,System.Drawing.Size)">
            <summary>
            Handle the GetEditRectangle request
            </summary>
            <param name="g"></param>
            <param name="cellBounds"></param>
            <param name="item"></param>
            <param name="subItemIndex"></param>
            <param name="preferredSize"> </param>
            <returns></returns>
        </member>
        <member name="M:Fluent.CheckStateRenderer.HandleHitTest(System.Drawing.Graphics,Fluent.OlvListViewHitTestInfo,System.Int32,System.Int32)">
            <summary>
            Handle the HitTest request
            </summary>
            <param name="g"></param>
            <param name="hti"></param>
            <param name="x"></param>
            <param name="y"></param>
        </member>
        <member name="T:Fluent.ImageRenderer">
            <summary>
            Render an image that comes from our data source.
            </summary>
            <remarks>The image can be sourced from:
            <list type="bullet">
            <item><description>a byte-array (normally when the image to be shown is
            stored as a value in a database)</description></item>
            <item><description>an int, which is treated as an index into the image list</description></item>
            <item><description>a string, which is treated first as a file name, and failing that as an index into the image list</description></item>
            <item><description>an ICollection of ints or strings, which will be drawn as consecutive images</description></item>
            </list>
            <para>If an image is an animated GIF, it's state is stored in the SubItem object.</para>
            <para>By default, the image renderer does not render animations (it begins life with animations paused).
            To enable animations, you must call Unpause().</para>
            <para>In the current implementation (2009-09), each column showing animated gifs must have a 
            different instance of ImageRenderer assigned to it. You cannot share the same instance of
            an image renderer between two animated gif columns. If you do, only the last column will be
            animated.</para>
            </remarks>
        </member>
        <member name="M:Fluent.ImageRenderer.#ctor">
            <summary>
            Make an empty image renderer
            </summary>
        </member>
        <member name="M:Fluent.ImageRenderer.#ctor(System.Boolean)">
            <summary>
            Make an empty image renderer that begins life ready for animations
            </summary>
        </member>
        <member name="M:Fluent.ImageRenderer.Dispose(System.Boolean)">
            <summary>
            Finalizer
            </summary>
        </member>
        <member name="P:Fluent.ImageRenderer.Paused">
            <summary>
            Should the animations in this renderer be paused?
            </summary>
        </member>
        <member name="P:Fluent.ImageRenderer.Tickler">
            <summary>
            Gets a timer that can be used to trigger redraws on animations
            </summary>
        </member>
        <member name="M:Fluent.ImageRenderer.Pause">
            <summary>
            Pause any animations
            </summary>
        </member>
        <member name="M:Fluent.ImageRenderer.Unpause">
            <summary>
            Unpause any animations
            </summary>
        </member>
        <member name="M:Fluent.ImageRenderer.Render(System.Drawing.Graphics,System.Drawing.Rectangle)">
            <summary>
            Draw our image
            </summary>
            <param name="g"></param>
            <param name="r"></param>
        </member>
        <member name="M:Fluent.ImageRenderer.GetImageFromAspect">
             <summary>
             Translate our Aspect into an image.
             </summary>
             <remarks>The strategy is:<list type="bullet">
             <item><description>If its a byte array, we treat it as an in-memory image</description></item>
             <item><description>If it's an int, we use that as an index into our image list</description></item>
             <item><description>If it's a string, we try to load a file by that name. If we can't, 
             we use the string as an index into our image list.</description></item>
            </list></remarks>
             <returns>An image</returns>
        </member>
        <member name="M:Fluent.ImageRenderer.OnTimer(System.Object)">
            <summary>
            This is the method that is invoked by the timer. It basically switches control to the listview thread.
            </summary>
            <param name="state">not used</param>
        </member>
        <member name="M:Fluent.ImageRenderer.OnTimerInThread">
            <summary>
            This is the OnTimer callback, but invoked in the same thread as the creator of the ListView.
            This method can use all of ListViews methods without creating a CrossThread exception.
            </summary>
        </member>
        <member name="T:Fluent.ImageRenderer.AnimationState">
            <summary>
            Instances of this class kept track of the animation state of a single image.
            </summary>
        </member>
        <member name="M:Fluent.ImageRenderer.AnimationState.IsAnimation(System.Drawing.Image)">
            <summary>
            Is the given image an animation
            </summary>
            <param name="image">The image to be tested</param>
            <returns>Is the image an animation?</returns>
        </member>
        <member name="M:Fluent.ImageRenderer.AnimationState.#ctor">
            <summary>
            Create an AnimationState in a quiet state
            </summary>
        </member>
        <member name="M:Fluent.ImageRenderer.AnimationState.#ctor(System.Drawing.Image)">
            <summary>
            Create an animation state for the given image, which may or may not
            be an animation
            </summary>
            <param name="image">The image to be rendered</param>
        </member>
        <member name="P:Fluent.ImageRenderer.AnimationState.IsValid">
            <summary>
            Does this state represent a valid animation
            </summary>
        </member>
        <member name="M:Fluent.ImageRenderer.AnimationState.AdvanceFrame(System.Int64)">
            <summary>
            Advance our images current frame and calculate when it will expire
            </summary>
        </member>
        <member name="T:Fluent.BarRenderer">
            <summary>
            Render our Aspect as a progress bar
            </summary>
        </member>
        <member name="M:Fluent.BarRenderer.#ctor">
            <summary>
            Make a BarRenderer
            </summary>
        </member>
        <member name="M:Fluent.BarRenderer.#ctor(System.Int32,System.Int32)">
            <summary>
            Make a BarRenderer for the given range of data values
            </summary>
        </member>
        <member name="M:Fluent.BarRenderer.#ctor(System.Drawing.Pen,System.Drawing.Brush)">
            <summary>
            Make a BarRenderer using a custom bar scheme
            </summary>
        </member>
        <member name="M:Fluent.BarRenderer.#ctor(System.Int32,System.Int32,System.Drawing.Pen,System.Drawing.Brush)">
            <summary>
            Make a BarRenderer using a custom bar scheme
            </summary>
        </member>
        <member name="M:Fluent.BarRenderer.#ctor(System.Drawing.Pen,System.Drawing.Color,System.Drawing.Color)">
            <summary>
            Make a BarRenderer that uses a horizontal gradient
            </summary>
        </member>
        <member name="M:Fluent.BarRenderer.#ctor(System.Int32,System.Int32,System.Drawing.Pen,System.Drawing.Color,System.Drawing.Color)">
            <summary>
            Make a BarRenderer that uses a horizontal gradient
            </summary>
        </member>
        <member name="P:Fluent.BarRenderer.UseStandardBar">
            <summary>
            Should this bar be drawn in the system style?
            </summary>
        </member>
        <member name="P:Fluent.BarRenderer.Padding">
            <summary>
            How many pixels in from our cell border will this bar be drawn
            </summary>
        </member>
        <member name="P:Fluent.BarRenderer.BackgroundColor">
            <summary>
            What color will be used to fill the interior of the control before the 
            progress bar is drawn?
            </summary>
        </member>
        <member name="P:Fluent.BarRenderer.FrameColor">
            <summary>
            What color should the frame of the progress bar be?
            </summary>
        </member>
        <member name="P:Fluent.BarRenderer.FrameWidth">
            <summary>
            How many pixels wide should the frame of the progress bar be?
            </summary>
        </member>
        <member name="P:Fluent.BarRenderer.FillColor">
            <summary>
            What color should the 'filled in' part of the progress bar be?
            </summary>
            <remarks>This is only used if GradientStartColor is Color.Empty</remarks>
        </member>
        <member name="P:Fluent.BarRenderer.GradientStartColor">
            <summary>
            Use a gradient to fill the progress bar starting with this color
            </summary>
        </member>
        <member name="P:Fluent.BarRenderer.GradientEndColor">
            <summary>
            Use a gradient to fill the progress bar ending with this color
            </summary>
        </member>
        <member name="P:Fluent.BarRenderer.MaximumWidth">
            <summary>
            Regardless of how wide the column become the progress bar will never be wider than this
            </summary>
        </member>
        <member name="P:Fluent.BarRenderer.MaximumHeight">
            <summary>
            Regardless of how high the cell is  the progress bar will never be taller than this
            </summary>
        </member>
        <member name="P:Fluent.BarRenderer.MinimumValue">
            <summary>
            The minimum data value expected. Values less than this will given an empty bar
            </summary>
        </member>
        <member name="P:Fluent.BarRenderer.MaximumValue">
            <summary>
            The maximum value for the range. Values greater than this will give a full bar
            </summary>
        </member>
        <member name="P:Fluent.BarRenderer.Pen">
            <summary>
            The Pen that will draw the frame surrounding this bar
            </summary>
        </member>
        <member name="P:Fluent.BarRenderer.Brush">
            <summary>
            The brush that will be used to fill the bar
            </summary>
        </member>
        <member name="P:Fluent.BarRenderer.BackgroundBrush">
            <summary>
            The brush that will be used to fill the background of the bar
            </summary>
        </member>
        <member name="M:Fluent.BarRenderer.SetGradient(System.Drawing.Color,System.Drawing.Color)">
            <summary>
            Draw this progress bar using a gradient
            </summary>
            <param name="start"></param>
            <param name="end"></param>
        </member>
        <member name="M:Fluent.BarRenderer.Render(System.Drawing.Graphics,System.Drawing.Rectangle)">
            <summary>
            Draw our aspect
            </summary>
            <param name="g"></param>
            <param name="r"></param>
        </member>
        <member name="M:Fluent.BarRenderer.HandleGetEditRectangle(System.Drawing.Graphics,System.Drawing.Rectangle,Fluent.OLVListItem,System.Int32,System.Drawing.Size)">
            <summary>
            Handle the GetEditRectangle request
            </summary>
            <param name="g"></param>
            <param name="cellBounds"></param>
            <param name="item"></param>
            <param name="subItemIndex"></param>
            <param name="preferredSize"> </param>
            <returns></returns>
        </member>
        <member name="T:Fluent.ImagesRenderer">
            <summary>
            An ImagesRenderer draws zero or more images depending on the data returned by its Aspect.
            </summary>
            <remarks><para>This renderer's Aspect must return a ICollection of ints, strings or Images,
            each of which will be drawn horizontally one after the other.</para>
            <para>As of v2.1, this functionality has been absorbed into ImageRenderer and this is now an
            empty shell, solely for backwards compatibility.</para>
            </remarks>
        </member>
        <member name="T:Fluent.MultiImageRenderer">
            <summary>
            A MultiImageRenderer draws the same image a number of times based on our data value
            </summary>
            <remarks><para>The stars in the Rating column of iTunes is a good example of this type of renderer.</para></remarks>
        </member>
        <member name="M:Fluent.MultiImageRenderer.#ctor">
            <summary>
            Make a quiet renderer
            </summary>
        </member>
        <member name="M:Fluent.MultiImageRenderer.#ctor(System.Object,System.Int32,System.Int32,System.Int32)">
            <summary>
            Make an image renderer that will draw the indicated image, at most maxImages times.
            </summary>
            <param name="imageSelector"></param>
            <param name="maxImages"></param>
            <param name="minValue"></param>
            <param name="maxValue"></param>
        </member>
        <member name="P:Fluent.MultiImageRenderer.ImageIndex">
            <summary>
            The index of the image that should be drawn
            </summary>
        </member>
        <member name="P:Fluent.MultiImageRenderer.ImageName">
            <summary>
            The name of the image that should be drawn
            </summary>
        </member>
        <member name="P:Fluent.MultiImageRenderer.ImageSelector">
            <summary>
            The image selector that will give the image to be drawn
            </summary>
            <remarks>Like all image selectors, this can be an int, string or Image</remarks>
        </member>
        <member name="P:Fluent.MultiImageRenderer.MaxNumberImages">
            <summary>
            What is the maximum number of images that this renderer should draw?
            </summary>
        </member>
        <member name="P:Fluent.MultiImageRenderer.MinimumValue">
            <summary>
            Values less than or equal to this will have 0 images drawn
            </summary>
        </member>
        <member name="P:Fluent.MultiImageRenderer.MaximumValue">
            <summary>
            Values greater than or equal to this will have MaxNumberImages images drawn
            </summary>
        </member>
        <member name="M:Fluent.MultiImageRenderer.Render(System.Drawing.Graphics,System.Drawing.Rectangle)">
            <summary>
            Draw our data value
            </summary>
            <param name="g"></param>
            <param name="r"></param>
        </member>
        <member name="T:Fluent.FlagRenderer">
            <summary>
            A class to render a value that contains a bitwise-OR'ed collection of values.
            </summary>
        </member>
        <member name="M:Fluent.FlagRenderer.Add(System.Object,System.Object)">
            <summary>
            Register the given image to the given value
            </summary>
            <param name="key">When this flag is present...</param>
            <param name="imageSelector">...draw this image</param>
        </member>
        <member name="M:Fluent.FlagRenderer.Render(System.Drawing.Graphics,System.Drawing.Rectangle)">
            <summary>
            Draw the flags
            </summary>
            <param name="g"></param>
            <param name="r"></param>
        </member>
        <member name="M:Fluent.FlagRenderer.HandleHitTest(System.Drawing.Graphics,Fluent.OlvListViewHitTestInfo,System.Int32,System.Int32)">
            <summary>
            Do the actual work of hit testing. Subclasses should override this rather than HitTest()
            </summary>
            <param name="g"></param>
            <param name="hti"></param>
            <param name="x"></param>
            <param name="y"></param>
        </member>
        <member name="T:Fluent.DescribedTaskRenderer">
            <summary>
            This renderer draws an image, a single line title, and then multi-line description
            under the title.
            </summary>
            <remarks>
            <para>This class works best with FullRowSelect = true.</para>
            <para>It's not designed to work with cell editing -- it will work but will look odd.</para>
            <para>
            It's not RightToLeft friendly.
            </para>
            </remarks>
        </member>
        <member name="M:Fluent.DescribedTaskRenderer.#ctor">
            <summary>
            Create a DescribedTaskRenderer
            </summary>
        </member>
        <member name="P:Fluent.DescribedTaskRenderer.UseGdiTextRendering">
            <summary>
            Should text be rendered using GDI routines? This makes the text look more
            like a native List view control.
            </summary>
        </member>
        <member name="P:Fluent.DescribedTaskRenderer.TitleFont">
            <summary>
            Gets or set the font that will be used to draw the title of the task
            </summary>
            <remarks>If this is null, the ListView's font will be used</remarks>
        </member>
        <member name="P:Fluent.DescribedTaskRenderer.TitleFontOrDefault">
            <summary>
            Return a font that has been set for the title or a reasonable default
            </summary>
        </member>
        <member name="P:Fluent.DescribedTaskRenderer.TitleColor">
            <summary>
            Gets or set the color of the title of the task
            </summary>
            <remarks>This color is used when the task is not selected or when the listview
            has a translucent selection mechanism.</remarks>
        </member>
        <member name="P:Fluent.DescribedTaskRenderer.TitleColorOrDefault">
            <summary>
            Return the color of the title of the task or a reasonable default
            </summary>
        </member>
        <member name="P:Fluent.DescribedTaskRenderer.DescriptionFont">
            <summary>
            Gets or set the font that will be used to draw the description of the task
            </summary>
            <remarks>If this is null, the ListView's font will be used</remarks>
        </member>
        <member name="P:Fluent.DescribedTaskRenderer.DescriptionFontOrDefault">
            <summary>
            Return a font that has been set for the title or a reasonable default
            </summary>
        </member>
        <member name="P:Fluent.DescribedTaskRenderer.DescriptionColor">
            <summary>
            Gets or set the color of the description of the task
            </summary>
            <remarks>This color is used when the task is not selected or when the listview
            has a translucent selection mechanism.</remarks>
        </member>
        <member name="P:Fluent.DescribedTaskRenderer.DescriptionColorOrDefault">
            <summary>
            Return the color of the description of the task or a reasonable default
            </summary>
        </member>
        <member name="P:Fluent.DescribedTaskRenderer.ImageTextSpace">
            <summary>
            Gets or sets the number of pixels that will be left between the image and the text
            </summary>
        </member>
        <member name="P:Fluent.DescribedTaskRenderer.TitleDescriptionSpace">
            <summary>
            Gets or sets the number of pixels that will be left between the title and the description
            </summary>
        </member>
        <member name="P:Fluent.DescribedTaskRenderer.DescriptionAspectName">
            <summary>
            Gets or sets the name of the aspect of the model object that contains the task description
            </summary>
        </member>
        <member name="P:Fluent.DescribedTaskRenderer.Filter">
            <summary>
            Gets or sets the filter that is filtering the FluentListView and for
            which this renderer should highlight text
            </summary>
        </member>
        <member name="P:Fluent.DescribedTaskRenderer.Fluent#IFilterAwareRenderer#Filter">
            <summary>
            When a filter changes, keep track of the text matching filters
            </summary>
        </member>
        <member name="M:Fluent.DescribedTaskRenderer.GetDescription(System.Object)">
            <summary>
            Fetch the description from the model class
            </summary>
            <param name="model"></param>
            <returns></returns>
        </member>
        <member name="M:Fluent.DescribedTaskRenderer.Render(System.Drawing.Graphics,System.Drawing.Rectangle)">
            <summary>
            Draw our item
            </summary>
            <param name="g"></param>
            <param name="r"></param>
        </member>
        <member name="M:Fluent.DescribedTaskRenderer.DrawDescribedTask(System.Drawing.Graphics,System.Drawing.Rectangle,System.String,System.String,System.Object)">
            <summary>
            Draw the task
            </summary>
            <param name="g"></param>
            <param name="r"></param>
            <param name="title"></param>
            <param name="description"></param>
            <param name="imageSelector"></param>
        </member>
        <member name="M:Fluent.DescribedTaskRenderer.HandleHitTest(System.Drawing.Graphics,Fluent.OlvListViewHitTestInfo,System.Int32,System.Int32)">
            <summary>
            Handle the HitTest request
            </summary>
            <param name="g"></param>
            <param name="hti"></param>
            <param name="x"></param>
            <param name="y"></param>
        </member>
        <member name="T:Fluent.ColumnButtonRenderer">
            <summary>
            This renderer draws a functioning button in its cell
            </summary>
        </member>
        <member name="P:Fluent.ColumnButtonRenderer.SizingMode">
            <summary>
            Gets or sets how each button will be sized
            </summary>
        </member>
        <member name="P:Fluent.ColumnButtonRenderer.ButtonSize">
            <summary>
            Gets or sets the size of the button when the SizingMode is FixedBounds
            </summary>
            <remarks>If this is not set, the bounds of the cell will be used</remarks>
        </member>
        <member name="P:Fluent.ColumnButtonRenderer.ButtonPadding">
            <summary>
            Gets or sets the extra space that surrounds the cell when the SizingMode is TextBounds
            </summary>
        </member>
        <member name="P:Fluent.ColumnButtonRenderer.MaxButtonWidth">
            <summary>
            Gets or sets the maximum width that a button can occupy.
            -1 means there is no maximum width.
            </summary>
            <remarks>This is only considered when the SizingMode is TextBounds</remarks>
        </member>
        <member name="P:Fluent.ColumnButtonRenderer.MinButtonWidth">
            <summary>
            Gets or sets the minimum width that a button can occupy.
            -1 means there is no minimum width.
            </summary>
            <remarks>This is only considered when the SizingMode is TextBounds</remarks>
        </member>
        <member name="M:Fluent.ColumnButtonRenderer.CalculateContentSize(System.Drawing.Graphics,System.Drawing.Rectangle)">
            <summary>
            Calculate the size of the contents
            </summary>
            <param name="g"></param>
            <param name="r"></param>
            <returns></returns>
        </member>
        <member name="M:Fluent.ColumnButtonRenderer.DrawImageAndText(System.Drawing.Graphics,System.Drawing.Rectangle)">
            <summary>
            Draw the button
            </summary>
            <param name="g"></param>
            <param name="r"></param>
        </member>
        <member name="M:Fluent.ColumnButtonRenderer.StandardHitTest(System.Drawing.Graphics,Fluent.OlvListViewHitTestInfo,System.Drawing.Rectangle,System.Int32,System.Int32)">
            <summary>
            What part of the control is under the given point?
            </summary>
            <param name="g"></param>
            <param name="hti"></param>
            <param name="bounds"></param>
            <param name="x"></param>
            <param name="y"></param>
        </member>
        <member name="M:Fluent.ColumnButtonRenderer.CalculatePushButtonState">
            <summary>
            What is the state of the button?
            </summary>
            <returns></returns>
        </member>
        <member name="P:Fluent.ColumnButtonRenderer.IsButtonHot">
            <summary>
            Is the mouse over the button?
            </summary>
        </member>
        <member name="T:Fluent.IItemStyle">
            <summary>
            The common interface supported by all style objects
            </summary>
        </member>
        <member name="P:Fluent.IItemStyle.Font">
            <summary>
            Gets or set the font that will be used by this style
            </summary>
        </member>
        <member name="P:Fluent.IItemStyle.FontStyle">
            <summary>
            Gets or set the font style
            </summary>
        </member>
        <member name="P:Fluent.IItemStyle.ForeColor">
            <summary>
            Gets or sets the ForeColor
            </summary>
        </member>
        <member name="P:Fluent.IItemStyle.BackColor">
            <summary>
            Gets or sets the BackColor
            </summary>
        </member>
        <member name="T:Fluent.SimpleItemStyle">
            <summary>
            Basic implementation of IItemStyle
            </summary>
        </member>
        <member name="P:Fluent.SimpleItemStyle.Font">
            <summary>
            Gets or sets the font that will be applied by this style
            </summary>
        </member>
        <member name="P:Fluent.SimpleItemStyle.FontStyle">
            <summary>
            Gets or sets the style of font that will be applied by this style
            </summary>
        </member>
        <member name="P:Fluent.SimpleItemStyle.ForeColor">
            <summary>
            Gets or sets the color of the text that will be applied by this style
            </summary>
        </member>
        <member name="P:Fluent.SimpleItemStyle.BackColor">
            <summary>
            Gets or sets the background color that will be applied by this style
            </summary>
        </member>
        <member name="T:Fluent.HotItemStyle">
            <summary>
            Instances of this class specify how should "hot items" (non-selected
            rows under the cursor) be renderered.
            </summary>
        </member>
        <member name="P:Fluent.HotItemStyle.Overlay">
            <summary>
            Gets or sets the overlay that should be drawn as part of the hot item
            </summary>
        </member>
        <member name="P:Fluent.HotItemStyle.Decoration">
            <summary>
            Gets or sets the decoration that should be drawn as part of the hot item
            </summary>
            <remarks>A decoration is different from an overlay in that an decoration
            scrolls with the listview contents, whilst an overlay does not.</remarks>
        </member>
        <member name="T:Fluent.CellStyle">
            <summary>
            This class defines how a cell should be formatted
            </summary>
        </member>
        <member name="P:Fluent.CellStyle.Font">
            <summary>
            Gets or sets the font that will be applied by this style
            </summary>
        </member>
        <member name="P:Fluent.CellStyle.FontStyle">
            <summary>
            Gets or sets the style of font that will be applied by this style
            </summary>
        </member>
        <member name="P:Fluent.CellStyle.ForeColor">
            <summary>
            Gets or sets the color of the text that will be applied by this style
            </summary>
        </member>
        <member name="P:Fluent.CellStyle.BackColor">
            <summary>
            Gets or sets the background color that will be applied by this style
            </summary>
        </member>
        <member name="T:Fluent.HyperlinkStyle">
            <summary>
            Instances of this class describe how hyperlinks will appear
            </summary>
        </member>
        <member name="M:Fluent.HyperlinkStyle.#ctor">
            <summary>
            Create a HyperlinkStyle
            </summary>
        </member>
        <member name="P:Fluent.HyperlinkStyle.Normal">
            <summary>
            What sort of formatting should be applied to hyperlinks in their normal state?
            </summary>
        </member>
        <member name="P:Fluent.HyperlinkStyle.Over">
            <summary>
            What sort of formatting should be applied to hyperlinks when the mouse is over them?
            </summary>
        </member>
        <member name="P:Fluent.HyperlinkStyle.Visited">
            <summary>
            What sort of formatting should be applied to hyperlinks after they have been clicked?
            </summary>
        </member>
        <member name="P:Fluent.HyperlinkStyle.OverCursor">
            <summary>
            Gets or sets the cursor that should be shown when the mouse is over a hyperlink.
            </summary>
        </member>
        <member name="T:Fluent.HeaderStateStyle">
            <summary>
            Instances of this class control one the styling of one particular state
            (normal, hot, pressed) of a header control
            </summary>
        </member>
        <member name="P:Fluent.HeaderStateStyle.Font">
            <summary>
            Gets or sets the font that will be applied by this style
            </summary>
        </member>
        <member name="P:Fluent.HeaderStateStyle.ForeColor">
            <summary>
            Gets or sets the color of the text that will be applied by this style
            </summary>
        </member>
        <member name="P:Fluent.HeaderStateStyle.BackColor">
            <summary>
            Gets or sets the background color that will be applied by this style
            </summary>
        </member>
        <member name="P:Fluent.HeaderStateStyle.FrameColor">
            <summary>
            Gets or sets the color in which a frame will be drawn around the header for this column
            </summary>
        </member>
        <member name="P:Fluent.HeaderStateStyle.FrameWidth">
            <summary>
            Gets or sets the width of the frame that will be drawn around the header for this column
            </summary>
        </member>
        <member name="T:Fluent.HeaderFormatStyle">
            <summary>
            This class defines how a header should be formatted in its various states.
            </summary>
        </member>
        <member name="M:Fluent.HeaderFormatStyle.#ctor">
            <summary>
            Create a new HeaderFormatStyle
            </summary>
        </member>
        <member name="P:Fluent.HeaderFormatStyle.Hot">
            <summary>
            What sort of formatting should be applied to a column header when the mouse is over it?
            </summary>
        </member>
        <member name="P:Fluent.HeaderFormatStyle.Normal">
            <summary>
            What sort of formatting should be applied to a column header in its normal state?
            </summary>
        </member>
        <member name="P:Fluent.HeaderFormatStyle.Pressed">
            <summary>
            What sort of formatting should be applied to a column header when pressed?
            </summary>
        </member>
        <member name="M:Fluent.HeaderFormatStyle.SetFont(System.Drawing.Font)">
            <summary>
            Set the font for all three states
            </summary>
            <param name="font"></param>
        </member>
        <member name="M:Fluent.HeaderFormatStyle.SetForeColor(System.Drawing.Color)">
            <summary>
            Set the fore color for all three states
            </summary>
            <param name="color"></param>
        </member>
        <member name="M:Fluent.HeaderFormatStyle.SetBackColor(System.Drawing.Color)">
            <summary>
            Set the back color for all three states
            </summary>
            <param name="color"></param>
        </member>
        <member name="T:Fluent.GlassPanelForm">
            <summary>
            A GlassPanelForm sits transparently over an FluentListView to show overlays.
            </summary>
        </member>
        <member name="P:Fluent.GlassPanelForm.CreateParams">
            <summary>
            Get the low-level windows flag that will be given to CreateWindow.
            </summary>
        </member>
        <member name="M:Fluent.GlassPanelForm.Bind(Fluent.Lists.AdvancedListView,Fluent.IOverlay)">
            <summary>
            Attach this form to the given FluentListView
            </summary>        
        </member>
        <member name="M:Fluent.GlassPanelForm.HideGlass">
            <summary>
            Made the overlay panel invisible
            </summary>
        </member>
        <member name="M:Fluent.GlassPanelForm.ShowGlass">
            <summary>
            Show the overlay panel in its correctly location
            </summary>
            <remarks>
            If the panel is always shown, this method does nothing.
            If the panel is being resized, this method also does nothing.
            </remarks>
        </member>
        <member name="M:Fluent.GlassPanelForm.Unbind">
            <summary>
            Detach this glass panel from its previous FluentListView
            </summary>        
            <remarks>
            You should unbind the overlay panel before making any changes to the 
            widget hierarchy.
            </remarks>
        </member>
        <member name="M:Fluent.GlassPanelForm.Owner_ResizeBegin(System.Object,System.EventArgs)">
            <summary>
            Handle when the form that owns the FluentListView begins to be resized
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="M:Fluent.GlassPanelForm.Owner_ResizeEnd(System.Object,System.EventArgs)">
            <summary>
            Handle when the form that owns the FluentListView finished to be resized
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="M:Fluent.GlassPanelForm.Owner_LocationChanged(System.Object,System.EventArgs)">
            <summary>
            The owning form has moved. Move the overlay panel too.
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="M:Fluent.GlassPanelForm.Owner_SizeChanged(System.Object,System.EventArgs)">
            <summary>
            The owning form is resizing. Hide our overlay panel until the resizing stops
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="M:Fluent.GlassPanelForm.objectListView_LocationChanged(System.Object,System.EventArgs)">
            <summary>
            Handle when the bound OLV changes its location. The overlay panel must 
            be moved too, IFF it is currently visible.
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="M:Fluent.GlassPanelForm.objectListView_SizeChanged(System.Object,System.EventArgs)">
            <summary>
            Handle when the bound OLV changes size. The overlay panel must 
            resize too, IFF it is currently visible.
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="M:Fluent.GlassPanelForm.tabControl_Selected(System.Object,System.Windows.Forms.TabControlEventArgs)">
            <summary>
            Handle when the bound OLV is part of a TabControl and that
            TabControl changes tabs. The overlay panel is hidden. The
            first time the bound OLV is redrawn, the overlay panel will
            be shown again.
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="M:Fluent.GlassPanelForm.objectListView_ParentChanged(System.Object,System.EventArgs)">
            <summary>
            Somewhere the parent of the bound OLV has changed. Update
            our events.
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="M:Fluent.GlassPanelForm.objectListView_VisibleChanged(System.Object,System.EventArgs)">
            <summary>
            Handle when the bound OLV changes its visibility.
            The overlay panel should match the OLV's visibility.
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="T:Fluent.HeaderControl">
            <summary>
            Class used to capture window messages for the header of the list view
            control.
            </summary>
        </member>
        <member name="M:Fluent.HeaderControl.#ctor(Fluent.Lists.AdvancedListView)">
            <summary>
            Create a header control for the given FluentListView.
            </summary>
            <param name="olv"></param>
        </member>
        <member name="P:Fluent.HeaderControl.ColumnIndexUnderCursor">
            <summary>
            Return the index of the column under the current cursor position,
            or -1 if the cursor is not over a column
            </summary>
            <returns>Index of the column under the cursor, or -1</returns>
        </member>
        <member name="P:Fluent.HeaderControl.Handle">
            <summary>
            Return the Windows handle behind this control
            </summary>
            <remarks>
            When an FluentListView is initialized as part of a UserControl, the
            GetHeaderControl() method returns 0 until the UserControl is
            completely initialized. So the AssignHandle() call in the constructor
            doesn't work. So we override the Handle property so value is always
            current.
            </remarks>
        </member>
        <member name="P:Fluent.HeaderControl.HotFontStyle">
            <summary>
            Gets or sets a style that should be applied to the font of the
            column's header text when the mouse is over that column
            </summary>
            <remarks>THIS IS EXPERIMENTAL. USE AT OWN RISK. August 2009</remarks>
        </member>
        <member name="M:Fluent.HeaderControl.GetColumnCheckBoxUnderCursor">
            <summary>
            Gets the index of the column under the cursor if the cursor is over it's checkbox
            </summary>
        </member>
        <member name="P:Fluent.HeaderControl.ClientRectangle">
            <summary>
            Gets the client rectangle for the header
            </summary>
        </member>
        <member name="M:Fluent.HeaderControl.IsPointOverHeaderCheckBox(System.Int32,System.Drawing.Point)">
            <summary>
            Return true if the given point is over the checkbox for the given column.
            </summary>
            <param name="columnIndex"></param>
            <param name="pt"></param>
            <returns></returns>
        </member>
        <member name="P:Fluent.HeaderControl.IsCursorOverLockedDivider">
            <summary>
            Gets whether the cursor is over a "locked" divider, i.e.
            one that cannot be dragged by the user.
            </summary>
        </member>
        <member name="P:Fluent.HeaderControl.ListView">
            <summary>
            Gets or sets the listview that this header belongs to
            </summary>
        </member>
        <member name="P:Fluent.HeaderControl.MaximumHeight">
            <summary>
            Gets the maximum height of the header. -1 means no maximum.
            </summary>
        </member>
        <member name="P:Fluent.HeaderControl.MinimumHeight">
            <summary>
            Gets the minimum height of the header. -1 means no minimum.
            </summary>
        </member>
        <member name="P:Fluent.HeaderControl.ToolTip">
            <summary>
            Get or set the ToolTip that shows tips for the header
            </summary>
        </member>
        <member name="P:Fluent.HeaderControl.WordWrap">
            <summary>
            Gets or sets whether the text in column headers should be word
            wrapped when it is too long to fit within the column
            </summary>
        </member>
        <member name="M:Fluent.HeaderControl.CalculateHeight(System.Drawing.Graphics)">
            <summary>
            Calculate how height the header needs to be
            </summary>
            <returns>Height in pixels</returns>
        </member>
        <member name="M:Fluent.HeaderControl.GetCheckBoxBounds(Fluent.OLVColumn)">
            <summary>
            Get the bounds of the checkbox against the given column
            </summary>
            <param name="column"></param>
            <returns></returns>
        </member>
        <member name="M:Fluent.HeaderControl.HasCheckBox(Fluent.OLVColumn)">
            <summary>
            Should the given column be drawn with a checkbox against it?
            </summary>
            <param name="column"></param>
            <returns></returns>
        </member>
        <member name="M:Fluent.HeaderControl.HasSortIndicator(Fluent.OLVColumn)">
            <summary>
            Should the given column show a sort indicator?
            </summary>
            <param name="column"></param>
            <returns></returns>
        </member>
        <member name="M:Fluent.HeaderControl.HasFilterIndicator(Fluent.OLVColumn)">
            <summary>
            Should the given column be drawn with a filter indicator against it?
            </summary>
            <param name="column"></param>
            <returns></returns>
        </member>
        <member name="M:Fluent.HeaderControl.HasNonThemedSortIndicator(Fluent.OLVColumn)">
            <summary>
            Should the given column show a non-themed sort indicator?
            </summary>
            <param name="column"></param>
            <returns></returns>
        </member>
        <member name="M:Fluent.HeaderControl.GetItemRect(System.Int32)">
            <summary>
            Return the bounds of the item with the given index
            </summary>
            <param name="itemIndex"></param>
            <returns></returns>
        </member>
        <member name="M:Fluent.HeaderControl.GetHeaderDrawRect(System.Int32)">
            <summary>
            Return the bounds within which the given column will be drawn
            </summary>
            <param name="itemIndex"></param>
            <returns></returns>
        </member>
        <member name="M:Fluent.HeaderControl.Invalidate">
            <summary>
            Force the header to redraw by invalidating it
            </summary>
        </member>
        <member name="M:Fluent.HeaderControl.Invalidate(Fluent.OLVColumn)">
            <summary>
            Force the header to redraw a single column by invalidating it
            </summary>
        </member>
        <member name="M:Fluent.HeaderControl.CreateToolTip">
            <summary>
            Create a native tool tip control for this listview
            </summary>
        </member>
        <member name="M:Fluent.HeaderControl.WndProc(System.Windows.Forms.Message@)">
            <summary>
            Override the basic message pump
            </summary>
            <param name="m"></param>
        </member>
        <member name="M:Fluent.HeaderControl.HandleLButtonDown(System.Windows.Forms.Message@)">
            <summary>
            Handle the LButtonDown windows message
            </summary>
            <param name="m"></param>
            <returns></returns>
        </member>
        <member name="M:Fluent.HeaderControl.HandleLButtonUp(System.Windows.Forms.Message@)">
            <summary>
            Handle the LButtonUp windows message
            </summary>
            <param name="m"></param>
            <returns></returns>
        </member>
        <member name="M:Fluent.HeaderControl.HandleSetCursor(System.Windows.Forms.Message@)">
            <summary>
            Handle the SetCursor windows message
            </summary>
            <param name="m"></param>
            <returns></returns>
        </member>
        <member name="M:Fluent.HeaderControl.HandleMouseMove(System.Windows.Forms.Message@)">
            <summary>
            Handle the MouseMove windows message
            </summary>
            <param name="m"></param>
            <returns></returns>
        </member>
        <member name="M:Fluent.HeaderControl.HandleMouseLeave(System.Windows.Forms.Message@)">
            <summary>
            Handle the MouseLeave windows message
            </summary>
            <param name="m"></param>
            <returns></returns>
        </member>
        <member name="M:Fluent.HeaderControl.HandleNotify(System.Windows.Forms.Message@)">
            <summary>
            Handle the Notify windows message
            </summary>
            <param name="m"></param>
            <returns></returns>
        </member>
        <member name="M:Fluent.HeaderControl.HandleHeaderCustomDraw(System.Windows.Forms.Message@)">
            <summary>
            Handle the CustomDraw windows message
            </summary>
            <param name="m"></param>
            <returns></returns>
        </member>
        <member name="M:Fluent.HeaderControl.HandleLayout(System.Windows.Forms.Message@)">
            <summary>
            The message divides a ListView's space between the header and the rows of the listview.
            The WINDOWPOS structure controls the headers bounds, the RECT controls the listview bounds.
            </summary>
            <param name="m"></param>
            <returns></returns>
        </member>
        <member name="M:Fluent.HeaderControl.HandleDestroy(System.Windows.Forms.Message@)">
            <summary>
            Handle when the underlying header control is destroyed
            </summary>
            <param name="m"></param>
            <returns></returns>
        </member>
        <member name="M:Fluent.HeaderControl.NeedsCustomDraw">
            <summary>
            Does this header need to be custom drawn?
            </summary>
            <remarks>Word wrapping and colored text require custom drawning. Funnily enough, we
            can change the font natively.</remarks>
        </member>
        <member name="M:Fluent.HeaderControl.CustomDrawHeaderCell(System.Drawing.Graphics,System.Int32,System.Int32)">
            <summary>
            Draw one cell of the header
            </summary>
            <param name="g"></param>
            <param name="columnIndex"></param>
            <param name="itemState"></param>
        </member>
        <member name="M:Fluent.HeaderControl.DrawUnthemedBackground(System.Drawing.Graphics,System.Drawing.Rectangle,System.Int32,System.Boolean,System.Boolean,Fluent.HeaderStateStyle)">
            <summary>
            Draw a background for the header, without using Themes.
            </summary>
            <param name="g"></param>
            <param name="r"></param>
            <param name="columnIndex"></param>
            <param name="isPressed"></param>
            <param name="isHot"></param>
            <param name="stateStyle"></param>
        </member>
        <member name="M:Fluent.HeaderControl.DrawThemedBackground(System.Drawing.Graphics,System.Drawing.Rectangle,System.Int32,System.Boolean,System.Boolean)">
            <summary>
            Draw a more-or-less pure themed header background.
            </summary>
            <param name="g"></param>
            <param name="r"></param>
            <param name="columnIndex"></param>
            <param name="isPressed"></param>
            <param name="isHot"></param>
        </member>
        <member name="M:Fluent.HeaderControl.DrawThemedSortIndicator(System.Drawing.Graphics,System.Drawing.Rectangle)">
            <summary>
            Draw a sort indicator using themes
            </summary>
            <param name="g"></param>
            <param name="r"></param>
        </member>
        <member name="M:Fluent.HeaderControl.DrawUnthemedSortIndicator(System.Drawing.Graphics,System.Drawing.Rectangle)">
            <summary>
            Draw a sort indicator without using themes
            </summary>
            <param name="g"></param>
            <param name="r"></param>
            <returns></returns>
        </member>
        <member name="M:Fluent.HeaderControl.DrawFilterIndicator(System.Drawing.Graphics,System.Drawing.Rectangle)">
            <summary>
            Draw an indication that this column has a filter applied to it
            </summary>
            <param name="g"></param>
            <param name="r"></param>
            <returns></returns>
        </member>
        <member name="M:Fluent.HeaderControl.DrawHeaderImageAndText(System.Drawing.Graphics,System.Drawing.Rectangle,Fluent.OLVColumn,Fluent.HeaderStateStyle)">
            <summary>
            Draw the header's image and text
            </summary>
            <param name="g"></param>
            <param name="r"></param>
            <param name="column"></param>
            <param name="stateStyle"></param>
        </member>
        <member name="M:Fluent.HeaderControl.CalculateHeaderStyle(Fluent.OLVColumn)">
            <summary>
            Return the header format that should be used for the given column
            </summary>
            <param name="column"></param>
            <returns></returns>
        </member>
        <member name="M:Fluent.HeaderControl.CalculateStateStyle(Fluent.OLVColumn,System.Boolean,System.Boolean)">
            <summary>
            What style should be applied to the header?
            </summary>
            <param name="column"></param>
            <param name="isHot"></param>
            <param name="isPressed"></param>
            <returns></returns>
        </member>
        <member name="M:Fluent.HeaderControl.CalculateFont(Fluent.OLVColumn,System.Boolean,System.Boolean)">
            <summary>
            What font should be used to draw the header text?
            </summary>
            <param name="column"></param>
            <param name="isHot"></param>
            <param name="isPressed"></param>
            <returns></returns>
        </member>
        <member name="P:Fluent.HeaderControl.TextFormatFlags">
            <summary>
            What flags will be used when drawing text
            </summary>
        </member>
        <member name="M:Fluent.HeaderControl.HitTest(System.Int32,System.Int32)">
            <summary>
            Perform a HitTest for the header control
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <returns>Null if the given point isn't over the header</returns>
        </member>
        <member name="T:Fluent.ToolStripCheckedListBox">
            <summary>
            Instances of this class put a CheckedListBox into a tool strip menu item.
            </summary>
        </member>
        <member name="M:Fluent.ToolStripCheckedListBox.#ctor">
            <summary>
            Create a ToolStripCheckedListBox
            </summary>
        </member>
        <member name="P:Fluent.ToolStripCheckedListBox.CheckedListBoxControl">
            <summary>
            Gets the control embedded in the menu
            </summary>
        </member>
        <member name="P:Fluent.ToolStripCheckedListBox.Items">
            <summary>
            Gets the items shown in the checkedlistbox
            </summary>
        </member>
        <member name="P:Fluent.ToolStripCheckedListBox.CheckedOnClick">
            <summary>
            Gets or sets whether an item should be checked when it is clicked
            </summary>
        </member>
        <member name="P:Fluent.ToolStripCheckedListBox.CheckedItems">
            <summary>
            Gets a collection of the checked items
            </summary>
        </member>
        <member name="M:Fluent.ToolStripCheckedListBox.AddItem(System.Object,System.Boolean)">
            <summary>
            Add a possibly checked item to the control
            </summary>
            <param name="item"></param>
            <param name="isChecked"></param>
        </member>
        <member name="M:Fluent.ToolStripCheckedListBox.AddItem(System.Object,System.Windows.Forms.CheckState)">
            <summary>
            Add an item with the given state to the control
            </summary>
            <param name="item"></param>
            <param name="state"></param>
        </member>
        <member name="M:Fluent.ToolStripCheckedListBox.GetItemCheckState(System.Int32)">
            <summary>
            Gets the checkedness of the i'th item
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:Fluent.ToolStripCheckedListBox.SetItemState(System.Int32,System.Windows.Forms.CheckState)">
            <summary>
            Set the checkedness of the i'th item
            </summary>
            <param name="i"></param>
            <param name="checkState"></param>
        </member>
        <member name="M:Fluent.ToolStripCheckedListBox.CheckAll">
            <summary>
            Check all the items in the control
            </summary>
        </member>
        <member name="M:Fluent.ToolStripCheckedListBox.UncheckAll">
            <summary>
            Unchecked all the items in the control
            </summary>
        </member>
        <member name="M:Fluent.ToolStripCheckedListBox.OnSubscribeControlEvents(System.Windows.Forms.Control)">
            <summary>
            Listen for events on the underlying control
            </summary>
            <param name="c"></param>
        </member>
        <member name="M:Fluent.ToolStripCheckedListBox.OnUnsubscribeControlEvents(System.Windows.Forms.Control)">
            <summary>
            Stop listening for events on the underlying control
            </summary>
            <param name="c"></param>
        </member>
        <member name="E:Fluent.ToolStripCheckedListBox.ItemCheck">
            <summary>
            Tell the world that an item was checked
            </summary>
        </member>
        <member name="M:Fluent.ToolStripCheckedListBox.OnItemCheck(System.Object,System.Windows.Forms.ItemCheckEventArgs)">
            <summary>
            Trigger the ItemCheck event
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="T:Fluent.ToolTipControl">
            <summary>
            A limited wrapper around a Windows tooltip window.
            </summary>
        </member>
        <member name="T:Fluent.ToolTipControl.StandardIcons">
            <summary>
            These are the standard icons that a tooltip can display.
            </summary>
        </member>
        <member name="F:Fluent.ToolTipControl.StandardIcons.None">
            <summary>
            No icon
            </summary>
        </member>
        <member name="F:Fluent.ToolTipControl.StandardIcons.Info">
            <summary>
            Info
            </summary>
        </member>
        <member name="F:Fluent.ToolTipControl.StandardIcons.Warning">
            <summary>
            Warning
            </summary>
        </member>
        <member name="F:Fluent.ToolTipControl.StandardIcons.Error">
            <summary>
            Error
            </summary>
        </member>
        <member name="F:Fluent.ToolTipControl.StandardIcons.InfoLarge">
            <summary>
            Large info (Vista and later only)
            </summary>
        </member>
        <member name="F:Fluent.ToolTipControl.StandardIcons.WarningLarge">
            <summary>
            Large warning (Vista and later only)
            </summary>
        </member>
        <member name="F:Fluent.ToolTipControl.StandardIcons.ErrorLarge">
            <summary>
            Large error (Vista and later only)
            </summary>
        </member>
        <member name="F:Fluent.ToolTipControl.TTN_SHOW">
            <summary>
            
            </summary>
        </member>
        <member name="F:Fluent.ToolTipControl.TTN_POP">
            <summary>
            
            </summary>
        </member>
        <member name="F:Fluent.ToolTipControl.TTN_LINKCLICK">
            <summary>
            
            </summary>
        </member>
        <member name="F:Fluent.ToolTipControl.TTN_GETDISPINFO">
            <summary>
            
            </summary>
        </member>
        <member name="P:Fluent.ToolTipControl.WindowStyle">
            <summary>
            Get or set if the style of the tooltip control
            </summary>
        </member>
        <member name="P:Fluent.ToolTipControl.IsBalloon">
            <summary>
            Get or set if the tooltip should be shown as a ballon
            </summary>
        </member>
        <member name="P:Fluent.ToolTipControl.HasBorder">
            <summary>
            Get or set if the tooltip should be shown as a ballon
            </summary>
        </member>
        <member name="P:Fluent.ToolTipControl.BackColor">
            <summary>
            Get or set the background color of the tooltip
            </summary>
        </member>
        <member name="P:Fluent.ToolTipControl.ForeColor">
            <summary>
            Get or set the color of the text and border on the tooltip.
            </summary>
        </member>
        <member name="P:Fluent.ToolTipControl.Title">
            <summary>
            Get or set the title that will be shown on the tooltip.
            </summary>
        </member>
        <member name="P:Fluent.ToolTipControl.StandardIcon">
            <summary>
            Get or set the icon that will be shown on the tooltip.
            </summary>
        </member>
        <member name="P:Fluent.ToolTipControl.Font">
            <summary>
            Gets or sets the font that will be used to draw this control.
            is still.
            </summary>
            <remarks>Setting this to null reverts to the default font.</remarks>
        </member>
        <member name="P:Fluent.ToolTipControl.AutoPopDelay">
            <summary>
            Gets or sets how many milliseconds the tooltip will remain visible while the mouse
            is still.
            </summary>
        </member>
        <member name="P:Fluent.ToolTipControl.InitialDelay">
            <summary>
            Gets or sets how many milliseconds the mouse must be still before the tooltip is shown.
            </summary>
        </member>
        <member name="P:Fluent.ToolTipControl.ReshowDelay">
            <summary>
            Gets or sets how many milliseconds the mouse must be still before the tooltip is shown again.
            </summary>
        </member>
        <member name="M:Fluent.ToolTipControl.Create(System.IntPtr)">
            <summary>
            Create the underlying control.
            </summary>
            <param name="parentHandle">The parent of the tooltip</param>
            <remarks>This does nothing if the control has already been created</remarks>
        </member>
        <member name="M:Fluent.ToolTipControl.PushSettings">
            <summary>
            Take a copy of the current settings and restore them when the 
            tooltip is poppped.
            </summary>
            <remarks>
            This call cannot be nested. Subsequent calls to this method will be ignored
            until PopSettings() is called.
            </remarks>
        </member>
        <member name="M:Fluent.ToolTipControl.PopSettings">
            <summary>
            Restore the settings of the tooltip as they were when PushSettings()
            was last called.
            </summary>
        </member>
        <member name="M:Fluent.ToolTipControl.AddTool(System.Windows.Forms.IWin32Window)">
            <summary>
            Add the given window to those for whom this tooltip will show tips
            </summary>
            <param name="window">The window</param>
        </member>
        <member name="M:Fluent.ToolTipControl.PopToolTip(System.Windows.Forms.IWin32Window)">
            <summary>
            Hide any currently visible tooltip
            </summary>
            <param name="window"></param>
        </member>
        <member name="M:Fluent.ToolTipControl.RemoveToolTip(System.Windows.Forms.IWin32Window)">
            <summary>
            Remove the given window from those managed by this tooltip
            </summary>
            <param name="window"></param>
        </member>
        <member name="M:Fluent.ToolTipControl.SetMaxWidth">
            <summary>
            Set the maximum width of a tooltip string.
            </summary>
        </member>
        <member name="M:Fluent.ToolTipControl.SetMaxWidth(System.Int32)">
            <summary>
            Set the maximum width of a tooltip string.
            </summary>
            <remarks>Setting this ensures that line breaks in the tooltip are honoured.</remarks>
        </member>
        <member name="M:Fluent.ToolTipControl.MakeToolInfoStruct(System.Windows.Forms.IWin32Window)">
            <summary>
            Make a TOOLINFO structure for the given window
            </summary>
            <param name="window"></param>
            <returns>A filled in TOOLINFO</returns>
        </member>
        <member name="M:Fluent.ToolTipControl.HandleNotify(System.Windows.Forms.Message@)">
            <summary>
            Handle a WmNotify message
            </summary>
            <param name="msg">The msg</param>
            <returns>True if the message has been handled</returns>
        </member>
        <member name="M:Fluent.ToolTipControl.HandleGetDispInfo(System.Windows.Forms.Message@)">
            <summary>
            Handle a get display info message
            </summary>
            <param name="msg">The msg</param>
            <returns>True if the message has been handled</returns>
        </member>
        <member name="M:Fluent.ToolTipControl.HandleLinkClick(System.Windows.Forms.Message@)">
            <summary>
            Handle a TTN_LINKCLICK message
            </summary>
            <param name="msg">The msg</param>
            <returns>True if the message has been handled</returns>
            <remarks>This cannot call base.WndProc() since the msg may have come from another control.</remarks>
        </member>
        <member name="M:Fluent.ToolTipControl.HandlePop(System.Windows.Forms.Message@)">
            <summary>
            Handle a TTN_POP message
            </summary>
            <param name="msg">The msg</param>
            <returns>True if the message has been handled</returns>
            <remarks>This cannot call base.WndProc() since the msg may have come from another control.</remarks>
        </member>
        <member name="M:Fluent.ToolTipControl.HandleShow(System.Windows.Forms.Message@)">
            <summary>
            Handle a TTN_SHOW message
            </summary>
            <param name="msg">The msg</param>
            <returns>True if the message has been handled</returns>
            <remarks>This cannot call base.WndProc() since the msg may have come from another control.</remarks>
        </member>
        <member name="M:Fluent.ToolTipControl.HandleReflectNotify(System.Windows.Forms.Message@)">
            <summary>
            Handle a reflected notify message
            </summary>
            <param name="msg">The msg</param>
            <returns>True if the message has been handled</returns>
        </member>
        <member name="M:Fluent.ToolTipControl.WndProc(System.Windows.Forms.Message@)">
            <summary>
            Mess with the basic message pump of the tooltip
            </summary>
            <param name="msg"></param>
        </member>
        <member name="E:Fluent.ToolTipControl.Showing">
            <summary>
            Tell the world that a tooltip is about to show
            </summary>
        </member>
        <member name="E:Fluent.ToolTipControl.Pop">
            <summary>
            Tell the world that a tooltip is about to disappear
            </summary>
        </member>
        <member name="M:Fluent.ToolTipControl.OnShowing(Fluent.ToolTipShowingEventArgs)">
            <summary>
            
            </summary>
            <param name="e"></param>
        </member>
        <member name="M:Fluent.ToolTipControl.OnPop(System.EventArgs)">
            <summary>
            
            </summary>
            <param name="e"></param>
        </member>
        <member name="T:Fluent.ColumnSelectionForm">
            <summary>
            This form is an example of how an application could allows the user to select which columns 
            an FluentListView will display, as well as select which order the columns are displayed in.
            </summary>
            <remarks>
            <para>In Tile view, ColumnHeader.DisplayIndex does nothing. To reorder the columns you have
            to change the order of objects in the Columns property.</para>
            <para>Remember that the first column is special!
            It has to remain the first column.</para>
            </remarks>
        </member>
        <member name="M:Fluent.ColumnSelectionForm.#ctor">
            <summary>
            Make a new ColumnSelectionForm
            </summary>
        </member>
        <member name="M:Fluent.ColumnSelectionForm.OpenOn(Fluent.Lists.AdvancedListView)">
            <summary>
            Open this form so it will edit the columns that are available in the listview's current view
            </summary>
            <param name="olv">The FluentListView whose columns are to be altered</param>
        </member>
        <member name="M:Fluent.ColumnSelectionForm.OpenOn(Fluent.Lists.AdvancedListView,System.Windows.Forms.View)">
            <summary>
            Open this form so it will edit the columns that are available in the given listview
            when the listview is showing the given type of view.
            </summary>
            <param name="olv">The FluentListView whose columns are to be altered</param>
            <param name="view">The view that is to be altered. Must be View.Details or View.Tile</param>
        </member>
        <member name="M:Fluent.ColumnSelectionForm.InitializeForm(Fluent.Lists.AdvancedListView,System.Windows.Forms.View)">
            <summary>
            Initialize the form to show the columns of the given view
            </summary>
            <param name="olv"></param>
            <param name="view"></param>
        </member>
        <member name="M:Fluent.ColumnSelectionForm.Apply(Fluent.Lists.AdvancedListView,System.Windows.Forms.View)">
            <summary>
            The user has pressed OK. Do what's requied.
            </summary>
            <param name="olv"></param>
            <param name="view"></param>
        </member>
        <member name="M:Fluent.ColumnSelectionForm.EnableControls">
            <summary>
            Enable the controls on the dialog to match the current state
            </summary>
        </member>
        <member name="T:Fluent.ColumnSelectionForm.SortByDisplayOrder">
            <summary>
            A Comparer that will sort a list of columns so that visible ones come before hidden ones,
            and that are ordered by their display order.
            </summary>
        </member>
        <member name="F:Fluent.ColumnSelectionForm.components">
            <summary>
            Required designer variable.
            </summary>
        </member>
        <member name="M:Fluent.ColumnSelectionForm.Dispose(System.Boolean)">
            <summary>
            Clean up any resources being used.
            </summary>
            <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        </member>
        <member name="M:Fluent.ColumnSelectionForm.InitializeComponent">
            <summary>
            Required method for Designer support - do not modify
            the contents of this method with the code editor.
            </summary>
        </member>
        <member name="T:Fluent.IGenerator">
            <summary>
            An object that implements the IGenerator interface provides the ability 
            to dynamically create columns
            for an FluentListView based on the characteristics of a given collection
            of model objects.
            </summary>
        </member>
        <member name="M:Fluent.IGenerator.GenerateAndReplaceColumns(Fluent.Lists.AdvancedListView,System.Type,System.Boolean)">
            <summary>
            Generate columns into the given FluentListView that come from the given 
            model object type. 
            </summary>
            <param name="olv">The FluentListView to modify</param>
            <param name="type">The model type whose attributes will be considered.</param>
            <param name="allProperties">Will columns be generated for properties that are not marked with [OLVColumn].</param>
        </member>
        <member name="M:Fluent.IGenerator.GenerateColumns(System.Type,System.Boolean)">
            <summary>
            Generate a list of OLVColumns based on the attributes of the given type
            If allProperties to true, all public properties will have a matching column generated.
            If allProperties is false, only properties that have a OLVColumn attribute will have a column generated.
            </summary>
            <param name="type"></param>
            <param name="allProperties">Will columns be generated for properties that are not marked with [OLVColumn].</param>
            <returns>A collection of OLVColumns matching the attributes of Type that have OLVColumnAttributes.</returns>
        </member>
        <member name="T:Fluent.Generator">
            <summary>
            The Generator class provides methods to dynamically create columns
            for an FluentListView based on the characteristics of a given collection
            of model objects.
            </summary>
            <remarks>
            <para>For a given type, a Generator can create columns to match the public properties
            of that type. The generator can consider all public properties or only those public properties marked with
            [OLVColumn] attribute.</para>
            </remarks>
        </member>
        <member name="P:Fluent.Generator.Instance">
            <summary>
            Gets or sets the actual generator used by the static convinence methods.
            </summary>
            <remarks>If you subclass the standard generator or implement IGenerator yourself, 
            you should install an instance of your subclass/implementation here.</remarks>
        </member>
        <member name="M:Fluent.Generator.GenerateColumns(Fluent.Lists.AdvancedListView,System.Collections.IEnumerable)">
            <summary>
            Replace all columns of the given FluentListView with columns generated
            from the first member of the given enumerable. If the enumerable is 
            empty or null, the FluentListView will be cleared.
            </summary>
            <param name="olv">The FluentListView to modify</param>
            <param name="enumerable">The collection whose first element will be used to generate columns.</param>
        </member>
        <member name="M:Fluent.Generator.GenerateColumns(Fluent.Lists.AdvancedListView,System.Collections.IEnumerable,System.Boolean)">
            <summary>
            Replace all columns of the given FluentListView with columns generated
            from the first member of the given enumerable. If the enumerable is 
            empty or null, the FluentListView will be cleared.
            </summary>
            <param name="olv">The FluentListView to modify</param>
            <param name="enumerable">The collection whose first element will be used to generate columns.</param>
            <param name="allProperties">Will columns be generated for properties that are not marked with [OLVColumn].</param>
        </member>
        <member name="M:Fluent.Generator.GenerateColumns(Fluent.Lists.AdvancedListView,System.Type)">
            <summary>
            Generate columns into the given FluentListView that come from the public properties of the given 
            model object type. 
            </summary>
            <param name="olv">The FluentListView to modify</param>
            <param name="type">The model type whose attributes will be considered.</param>
        </member>
        <member name="M:Fluent.Generator.GenerateColumns(Fluent.Lists.AdvancedListView,System.Type,System.Boolean)">
            <summary>
            Generate columns into the given FluentListView that come from the public properties of the given 
            model object type. 
            </summary>
            <param name="olv">The FluentListView to modify</param>
            <param name="type">The model type whose attributes will be considered.</param>
            <param name="allProperties">Will columns be generated for properties that are not marked with [OLVColumn].</param>
        </member>
        <member name="M:Fluent.Generator.GenerateColumns(System.Type)">
            <summary>
            Generate a list of OLVColumns based on the public properties of the given type
            that have a OLVColumn attribute.
            </summary>
            <param name="type"></param>
            <returns>A collection of OLVColumns matching the attributes of Type that have OLVColumnAttributes.</returns>
        </member>
        <member name="M:Fluent.Generator.GenerateAndReplaceColumns(Fluent.Lists.AdvancedListView,System.Type,System.Boolean)">
            <summary>
            Generate columns into the given FluentListView that come from the given 
            model object type. 
            </summary>
            <param name="olv">The FluentListView to modify</param>
            <param name="type">The model type whose attributes will be considered.</param>
            <param name="allProperties">Will columns be generated for properties that are not marked with [OLVColumn].</param>
        </member>
        <member name="M:Fluent.Generator.GenerateColumns(System.Type,System.Boolean)">
            <summary>
            Generate a list of OLVColumns based on the attributes of the given type
            If allProperties to true, all public properties will have a matching column generated.
            If allProperties is false, only properties that have a OLVColumn attribute will have a column generated.
            </summary>
            <param name="type"></param>
            <param name="allProperties">Will columns be generated for properties that are not marked with [OLVColumn].</param>
            <returns>A collection of OLVColumns matching the attributes of Type that have OLVColumnAttributes.</returns>
        </member>
        <member name="M:Fluent.Generator.ReplaceColumns(Fluent.Lists.AdvancedListView,System.Collections.Generic.IList{Fluent.OLVColumn})">
            <summary>
            Replace all the columns in the given listview with the given list of columns.
            </summary>
            <param name="olv"></param>
            <param name="columns"></param>
        </member>
        <member name="M:Fluent.Generator.PostCreateColumns(Fluent.Lists.AdvancedListView)">
            <summary>
            Post process columns after creating them and adding them to the AllColumns collection.
            </summary>
            <param name="olv"></param>
        </member>
        <member name="M:Fluent.Generator.MakeColumnFromAttribute(System.Reflection.PropertyInfo,Fluent.OLVColumnAttribute)">
            <summary>
            Create a column from the given PropertyInfo and OLVColumn attribute
            </summary>
            <param name="pinfo"></param>
            <param name="attr"></param>
            <returns></returns>
        </member>
        <member name="M:Fluent.Generator.MakeColumnFromPropertyInfo(System.Reflection.PropertyInfo)">
            <summary>
            Make a column from the given PropertyInfo
            </summary>
            <param name="pinfo"></param>
            <returns></returns>
        </member>
        <member name="M:Fluent.Generator.MakeColumnFromPropertyDescriptor(System.ComponentModel.PropertyDescriptor)">
            <summary>
            Make a column from the given PropertyDescriptor
            </summary>
            <param name="pd"></param>
            <returns></returns>
        </member>
        <member name="M:Fluent.Generator.MakeColumn(System.String,System.String,System.Boolean,System.Type,Fluent.OLVColumnAttribute)">
            <summary>
            Create a column with all the given information
            </summary>
            <param name="aspectName"></param>
            <param name="title"></param>
            <param name="editable"></param>
            <param name="propertyType"></param>
            <param name="attr"></param>
            <returns></returns>
        </member>
        <member name="M:Fluent.Generator.MakeColumn(System.String,System.String,Fluent.OLVColumnAttribute)">
            <summary>
            Create a column.
            </summary>
            <param name="aspectName"></param>
            <param name="title"></param>
            <param name="attr"></param>
            <returns></returns>
        </member>
        <member name="M:Fluent.Generator.DisplayNameToColumnTitle(System.String)">
            <summary>
            Convert a property name to a displayable title.
            </summary>
            <param name="displayName"></param>
            <returns></returns>
        </member>
        <member name="M:Fluent.Generator.ConfigurePossibleBooleanColumn(Fluent.OLVColumn,System.Type)">
            <summary>
            Configure the given column to show a checkbox if appropriate
            </summary>
            <param name="column"></param>
            <param name="propertyType"></param>
        </member>
        <member name="M:Fluent.Generator.TryGenerateChildrenDelegates(Fluent.Lists.TreeListView,System.Type)">
            <summary>
            If this given type has an property marked with [OLVChildren], make delegates that will
            traverse that property as the children of an instance of the model
            </summary>
            <param name="tlv"></param>
            <param name="type"></param>
        </member>
        <member name="M:Fluent.Generator.GenerateChildrenDelegates(Fluent.Lists.TreeListView,System.Reflection.PropertyInfo)">
            <summary>
            Generate CanExpand and ChildrenGetter delegates from the given property.
            </summary>
            <param name="tlv"></param>
            <param name="pinfo"></param>
        </member>
        <member name="T:Fluent.OLVExporter">
            <summary>
            An OLVExporter converts a collection of rows from an FluentListView
            into a variety of textual formats.
            </summary>
        </member>
        <member name="T:Fluent.OLVExporter.ExportFormat">
            <summary>
            What format will be used for exporting
            </summary>
        </member>
        <member name="F:Fluent.OLVExporter.ExportFormat.TabSeparated">
            <summary>
            Tab separated values, according to http://www.iana.org/assignments/media-types/text/tab-separated-values
            </summary>
        </member>
        <member name="F:Fluent.OLVExporter.ExportFormat.TSV">
            <summary>
            Alias for TabSeparated
            </summary>
        </member>
        <member name="F:Fluent.OLVExporter.ExportFormat.CSV">
            <summary>
            Comma separated values, according to http://www.ietf.org/rfc/rfc4180.txt
            </summary>
        </member>
        <member name="F:Fluent.OLVExporter.ExportFormat.HTML">
            <summary>
            HTML table, according to me
            </summary>
        </member>
        <member name="M:Fluent.OLVExporter.#ctor">
            <summary>
            Create an empty exporter
            </summary>
        </member>
        <member name="M:Fluent.OLVExporter.#ctor(Fluent.Lists.AdvancedListView)">
            <summary>
            Create an exporter that will export all the rows of the given FluentListView
            </summary>
            <param name="olv"></param>
        </member>
        <member name="M:Fluent.OLVExporter.#ctor(Fluent.Lists.AdvancedListView,System.Collections.IEnumerable)">
            <summary>
            Create an exporter that will export all the given rows from the given FluentListView
            </summary>
            <param name="olv"></param>
            <param name="objectsToExport"></param>
        </member>
        <member name="P:Fluent.OLVExporter.IncludeHiddenColumns">
            <summary>
            Gets or sets whether hidden columns will also be included in the textual
            representation. If this is false (the default), only visible columns will
            be included.
            </summary>
        </member>
        <member name="P:Fluent.OLVExporter.IncludeColumnHeaders">
            <summary>
            Gets or sets whether column headers will also be included in the text
            and HTML representation. Default is true.
            </summary>
        </member>
        <member name="P:Fluent.OLVExporter.ListView">
            <summary>
            Gets the FluentListView that is being used as the source of the data
            to be exported
            </summary>
        </member>
        <member name="P:Fluent.OLVExporter.ModelObjects">
            <summary>
            Gets the model objects that are to be placed in the data object
            </summary>
        </member>
        <member name="M:Fluent.OLVExporter.ExportTo(Fluent.OLVExporter.ExportFormat)">
            <summary>
            Export the nominated rows from the nominated FluentListView.
            Returns the result in the expected format.
            </summary>
            <param name="format"></param>
            <returns></returns>
            <remarks>This will perform only one conversion, even if called multiple times with different formats.</remarks>
        </member>
        <member name="M:Fluent.OLVExporter.Convert">
            <summary>
            Convert 
            </summary>
        </member>
        <member name="M:Fluent.OLVExporter.CsvEncode(System.String)">
            <summary>
            Encode a string such that it can be used as a value in a CSV file.
            This basically means replacing any quote mark with two quote marks,
            and enclosing the whole string in quotes.
            </summary>
            <param name="text"></param>
            <returns></returns>
        </member>
        <member name="M:Fluent.OLVExporter.HtmlEncode(System.String)">
            <summary>
            HTML-encodes a string and returns the encoded string.
            </summary>
            <param name="text">The text string to encode. </param>
            <returns>The HTML-encoded text.</returns>
            <remarks>Taken from http://www.west-wind.com/weblog/posts/2009/Feb/05/Html-and-Uri-String-Encoding-without-SystemWeb</remarks>
        </member>
        <member name="T:Fluent.TypedFluentListView`1">
            <summary>
            A TypedFluentListView is a type-safe wrapper around an FluentListView.
            </summary>
            <remarks>
            <para>VCS does not support generics on controls. It can be faked to some degree, but it
            cannot be completely overcome. In our case in particular, there is no way to create
            the custom OLVColumn's that we need to truly be generic. So this wrapper is an 
            experiment in providing some type-safe access in a way that is useful and available today.</para>
            <para>A TypedFluentListView is not more efficient than a normal FluentListView.
            Underneath, the same name of casts are performed. But it is easier to use since you
            do not have to write the casts yourself.
            </para>
            </remarks>
            <typeparam name="T">The class of model object that the list will manage</typeparam>
            <example>
            To use a TypedFluentListView, you write code like this:
            <code>
            TypedFluentListView&lt;Person> tlist = new TypedFluentListView&lt;Person>(this.listView1);
            tlist.CheckStateGetter = delegate(Person x) { return x.IsActive; };
            tlist.GetColumn(0).AspectGetter = delegate(Person x) { return x.Name; };
            ...
            </code>
            To iterate over the selected objects, you can write something elegant like this:
            <code>
            foreach (Person x in tlist.SelectedObjects) {
                x.GrantSalaryIncrease();
            }
            </code>
            </example>
        </member>
        <member name="M:Fluent.TypedFluentListView`1.#ctor(Fluent.Lists.AdvancedListView)">
            <summary>
            Create a typed wrapper around the given list.
            </summary>
            <param name="olv">The listview to be wrapped</param>
        </member>
        <member name="P:Fluent.TypedFluentListView`1.CheckedObject">
            <summary>
            Return the model object that is checked, if only one row is checked.
            If zero rows are checked, or more than one row, null is returned.
            </summary>
        </member>
        <member name="P:Fluent.TypedFluentListView`1.CheckedObjects">
            <summary>
            Return the list of all the checked model objects
            </summary>
        </member>
        <member name="P:Fluent.TypedFluentListView`1.ListView">
            <summary>
            The FluentListView that is being wrapped
            </summary>
        </member>
        <member name="P:Fluent.TypedFluentListView`1.Objects">
            <summary>
            Get or set the list of all model objects
            </summary>
        </member>
        <member name="P:Fluent.TypedFluentListView`1.SelectedObject">
            <summary>
            Return the model object that is selected, if only one row is selected.
            If zero rows are selected, or more than one row, null is returned.
            </summary>
        </member>
        <member name="P:Fluent.TypedFluentListView`1.SelectedObjects">
            <summary>
            The list of model objects that are selected.
            </summary>
        </member>
        <member name="M:Fluent.TypedFluentListView`1.GetColumn(System.Int32)">
            <summary>
            Return a typed wrapper around the column at the given index
            </summary>
            <param name="i">The index of the column</param>
            <returns>A typed column or null</returns>
        </member>
        <member name="M:Fluent.TypedFluentListView`1.GetColumn(System.String)">
            <summary>
            Return a typed wrapper around the column with the given name
            </summary>
            <param name="name">The name of the column</param>
            <returns>A typed column or null</returns>
        </member>
        <member name="M:Fluent.TypedFluentListView`1.GetModelObject(System.Int32)">
            <summary>
            Return the model object at the given index
            </summary>
            <param name="index">The index of the model object</param>
            <returns>The model object or null</returns>
        </member>
        <member name="T:Fluent.TypedFluentListView`1.TypedCheckStateGetterDelegate">
            <summary>
            CheckStateGetter
            </summary>
            <param name="rowObject"></param>
            <returns></returns>
        </member>
        <member name="P:Fluent.TypedFluentListView`1.CheckStateGetter">
            <summary>
            Gets or sets the check state getter
            </summary>
        </member>
        <member name="T:Fluent.TypedFluentListView`1.TypedBooleanCheckStateGetterDelegate">
            <summary>
            BooleanCheckStateGetter
            </summary>
            <param name="rowObject"></param>
            <returns></returns>
        </member>
        <member name="P:Fluent.TypedFluentListView`1.BooleanCheckStateGetter">
            <summary>
            Gets or sets the boolean check state getter
            </summary>
        </member>
        <member name="T:Fluent.TypedFluentListView`1.TypedCheckStatePutterDelegate">
            <summary>
            CheckStatePutter
            </summary>
            <param name="rowObject"></param>
            <param name="newValue"></param>
            <returns></returns>
        </member>
        <member name="P:Fluent.TypedFluentListView`1.CheckStatePutter">
            <summary>
            Gets or sets the check state putter delegate
            </summary>
        </member>
        <member name="T:Fluent.TypedFluentListView`1.TypedBooleanCheckStatePutterDelegate">
            <summary>
            BooleanCheckStatePutter
            </summary>
            <param name="rowObject"></param>
            <param name="newValue"></param>
            <returns></returns>
        </member>
        <member name="P:Fluent.TypedFluentListView`1.BooleanCheckStatePutter">
            <summary>
            Gets or sets the boolean check state putter
            </summary>
        </member>
        <member name="T:Fluent.TypedFluentListView`1.TypedCellToolTipGetterDelegate">
            <summary>
            ToolTipGetter
            </summary>
            <param name="column"></param>
            <param name="modelObject"></param>
            <returns></returns>
        </member>
        <member name="P:Fluent.TypedFluentListView`1.CellToolTipGetter">
            <summary>
            Gets or sets the cell tooltip getter
            </summary>
        </member>
        <member name="P:Fluent.TypedFluentListView`1.HeaderToolTipGetter">
            <summary>
            Gets or sets the header tool tip getter
            </summary>
        </member>
        <member name="M:Fluent.TypedFluentListView`1.GenerateAspectGetters">
            <summary>
            This method will generate AspectGetters for any column that has an AspectName.
            </summary>
        </member>
        <member name="T:Fluent.TypedColumn`1">
            <summary>
            A type-safe wrapper around an OLVColumn
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Fluent.TypedColumn`1.#ctor(Fluent.OLVColumn)">
            <summary>
            Creates a TypedColumn
            </summary>
            <param name="column"></param>
        </member>
        <member name="T:Fluent.TypedColumn`1.TypedAspectGetterDelegate">
            <summary>
            
            </summary>
            <param name="rowObject"></param>
            <returns></returns>
        </member>
        <member name="T:Fluent.TypedColumn`1.TypedAspectPutterDelegate">
            <summary>
            
            </summary>
            <param name="rowObject"></param>
            <param name="newValue"></param>
        </member>
        <member name="T:Fluent.TypedColumn`1.TypedGroupKeyGetterDelegate">
            <summary>
            
            </summary>
            <param name="rowObject"></param>
            <returns></returns>
        </member>
        <member name="T:Fluent.TypedColumn`1.TypedImageGetterDelegate">
            <summary>
            
            </summary>
            <param name="rowObject"></param>
            <returns></returns>
        </member>
        <member name="P:Fluent.TypedColumn`1.AspectGetter">
            <summary>
            
            </summary>
        </member>
        <member name="P:Fluent.TypedColumn`1.AspectPutter">
            <summary>
            
            </summary>
        </member>
        <member name="P:Fluent.TypedColumn`1.ImageGetter">
            <summary>
            
            </summary>
        </member>
        <member name="P:Fluent.TypedColumn`1.GroupKeyGetter">
            <summary>
            
            </summary>
        </member>
        <member name="M:Fluent.TypedColumn`1.GenerateAspectGetter">
            <summary>
            Generate an aspect getter that does the same thing as the AspectName,
            except without using reflection.
            </summary>
            <remarks>
            <para>
            If you have an AspectName of "Owner.Address.Postcode", this will generate
            the equivilent of: <code>this.AspectGetter = delegate (object x) {
                return x.Owner.Address.Postcode;
            }
            </code>
            </para>
            <para>
            If AspectName is empty, this method will do nothing, otherwise 
            this will replace any existing AspectGetter.
            </para>
            </remarks>
        </member>
        <member name="M:Fluent.TypedColumn`1.GenerateAspectGetter(System.Type,System.String)">
            <summary>
            Generates an aspect getter method dynamically. The method will execute
            the given dotted chain of selectors against a model object given at runtime.
            </summary>
            <param name="type">The type of model object to be passed to the generated method</param>
            <param name="path">A dotted chain of selectors. Each selector can be the name of a 
            field, property or parameter-less method.</param>
            <returns>A typed delegate</returns>
        </member>
        <member name="M:Fluent.TypedColumn`1.GenerateIL(System.Type,System.String,System.Reflection.Emit.ILGenerator)">
            <summary>
            This method generates the actual IL for the method.
            </summary>
            <param name="type"></param>
            <param name="path"></param>
            <param name="il"></param>
        </member>
    </members>
</doc>
